declare module Microsoft.CodeAnalysis {
    class CSharpExtensions {
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class CSharpExtensions {
        static IsKind_2120(token: SyntaxToken, kind: CSharp.SyntaxKind): boolean;
        static IsContextualKind(token: SyntaxToken, kind: CSharp.SyntaxKind): boolean;
        static IsKind_9874(trivia: SyntaxTrivia, kind: CSharp.SyntaxKind): boolean;
        static IsKind_1139(node: SyntaxNode, kind: CSharp.SyntaxKind): boolean;
        static IsKind_7914(nodeOrToken: SyntaxNodeOrToken, kind: CSharp.SyntaxKind): boolean;
        static CSharpKind_1238(token: SyntaxToken): CSharp.SyntaxKind;
        static CSharpContextualKind(token: SyntaxToken): CSharp.SyntaxKind;
        static CSharpKind_4438(trivia: SyntaxTrivia): CSharp.SyntaxKind;
        static CSharpKind_1207(node: SyntaxNode): CSharp.SyntaxKind;
        static CSharpKind_1403(nodeOrToken: SyntaxNodeOrToken): CSharp.SyntaxKind;
        static IndexOf_6246<TNode extends SyntaxNode>(list: SyntaxList<TNode>, kind: CSharp.SyntaxKind): number;
        static Any_9151<TNode extends SyntaxNode>(list: SyntaxList<TNode>, kind: CSharp.SyntaxKind): boolean;
        static IndexOf_8583<TNode extends SyntaxNode>(list: SeparatedSyntaxList<TNode>, kind: CSharp.SyntaxKind): number;
        static Any_8065<TNode extends SyntaxNode>(list: SeparatedSyntaxList<TNode>, kind: CSharp.SyntaxKind): boolean;
        static IndexOf_5113(list: SyntaxTriviaList, kind: CSharp.SyntaxKind): number;
        static Any_1488(list: SyntaxTriviaList, kind: CSharp.SyntaxKind): boolean;
        static IndexOf_2988(list: SyntaxTokenList, kind: CSharp.SyntaxKind): number;
        static Any_2090(list: SyntaxTokenList, kind: CSharp.SyntaxKind): boolean;
        static FirstOrDefault(list: SyntaxTokenList, kind: CSharp.SyntaxKind): SyntaxToken;
        static IsKeyword(token: SyntaxToken): boolean;
        static IsContextualKeyword(token: SyntaxToken): boolean;
        static IsReservedKeyword(token: SyntaxToken): boolean;
        static IsVerbatimStringLiteral(token: SyntaxToken): boolean;
        static IsVerbatimIdentifier(token: SyntaxToken): boolean;
        static Insert(list: SyntaxTokenList, index: number, ...items: SyntaxToken[]): SyntaxTokenList;
        static ReplaceTrivia_1543(token: SyntaxToken, trivia: System.Collections.Generic.IEnumerable<SyntaxTrivia>, computeReplacementTrivia: (_: SyntaxTrivia, __: SyntaxTrivia) => SyntaxTrivia): SyntaxToken;
        static ReplaceTrivia_1458(token: SyntaxToken, oldTrivia: SyntaxTrivia, newTrivia: SyntaxTrivia): SyntaxToken;
        static ApplyDirectives_1810(node: SyntaxNode, stack: Syntax.InternalSyntax.DirectiveStack): Syntax.InternalSyntax.DirectiveStack;
        static ApplyDirectives_1105(token: SyntaxToken, stack: Syntax.InternalSyntax.DirectiveStack): Syntax.InternalSyntax.DirectiveStack;
        static ApplyDirectives_1395(nodeOrToken: SyntaxNodeOrToken, stack: Syntax.InternalSyntax.DirectiveStack): Syntax.InternalSyntax.DirectiveStack;
        static AsSeparatedList<TOther extends SyntaxNode>(list: SyntaxNodeOrTokenList): SeparatedSyntaxList<TOther>;
        static GetDirectives(node: SyntaxNode, filter?: (_: Syntax.DirectiveTriviaSyntax) => boolean): System.Collections.Generic.IList<Syntax.DirectiveTriviaSyntax>;
        static GetFirstDirective(node: SyntaxNode, predicate?: (_: Syntax.DirectiveTriviaSyntax) => boolean): Syntax.DirectiveTriviaSyntax;
        static GetLastDirective(node: SyntaxNode, predicate?: (_: Syntax.DirectiveTriviaSyntax) => boolean): Syntax.DirectiveTriviaSyntax;
        static GetCompilationUnitRoot(tree: SyntaxTree, cancellationToken?: System.Threading.CancellationToken): Syntax.CompilationUnitSyntax;
        static HasReferenceDirectives(tree: SyntaxTree): boolean;
        static IsAnyPreprocessorSymbolDefined(tree: SyntaxTree, conditionalSymbols: System.Collections.Immutable.ImmutableArray<string>): boolean;
        static IsPreprocessorSymbolDefined(tree: SyntaxTree, symbolName: string, position: number): boolean;
        static GetPragmaDirectiveWarningState(tree: SyntaxTree, id: string, position: number): ReportDiagnostic;
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    enum LanguageVersion {
        CSharp1 = 1,
        CSharp2 = 2,
        CSharp3 = 3,
        CSharp4 = 4,
        CSharp5 = 5,
        CSharp6 = 6,
    }
    class LanguageVersionExtensions {
        static IsValid(value: LanguageVersion): boolean;
        static Localize(value: LanguageVersion): Object;
        static GetErrorCode(version: LanguageVersion): ErrorCode;
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class CSharpParseOptions extends ParseOptions implements System.IEquatable<CSharpParseOptions> {
        static Default: CSharpParseOptions;
        LanguageVersion: LanguageVersion;
        PreprocessorSymbols: System.Collections.Immutable.ImmutableArray<string>;
        PreprocessorSymbolNames: System.Collections.Generic.IEnumerable<string>;
        ctor_2554(languageVersion?: LanguageVersion, documentationMode?: DocumentationMode, kind?: SourceCodeKind, preprocessorSymbols?: System.Collections.Generic.IEnumerable<string>): CSharpParseOptions;
        ctor_2353(other: CSharpParseOptions): CSharpParseOptions;
        ctor_1112(languageVersion: LanguageVersion, documentationMode: DocumentationMode, kind: SourceCodeKind, preprocessorSymbols: System.Collections.Immutable.ImmutableArray<string>): CSharpParseOptions;
        WithKind(kind: SourceCodeKind): CSharpParseOptions;
        WithLanguageVersion(version: LanguageVersion): CSharpParseOptions;
        WithPreprocessorSymbols_2136(preprocessorSymbols: System.Collections.Generic.IEnumerable<string>): CSharpParseOptions;
        WithPreprocessorSymbols_1878(...preprocessorSymbols: string[]): CSharpParseOptions;
        WithPreprocessorSymbols_1926(symbols: System.Collections.Immutable.ImmutableArray<string>): CSharpParseOptions;
        WithDocumentationMode(documentationMode: DocumentationMode): CSharpParseOptions;
        protected CommonWithKind(kind: SourceCodeKind): ParseOptions;
        protected CommonWithDocumentationMode(documentationMode: DocumentationMode): ParseOptions;
        protected CommonWithFeatures(features: System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>>): ParseOptions;
        WithFeatures(features: System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>>): CSharpParseOptions;
        Features: System.Collections.Generic.IReadOnlyDictionary<string, string>;
        Equals(obj: Object): boolean;
        Equals_1428(other: CSharpParseOptions): boolean;
        GetHashCode(): number;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class CSharpResources {
        static CantReferenceCompilationOf: string;
        static ChainingSpeculativeModelIsNotSupported: string;
        static CompilationC: string;
        static ElementIsExpected: string;
        static ElementsCannotBeNull: string;
        static ERR_AbstractAndExtern: string;
        static ERR_AbstractAndSealed: string;
        static ERR_AbstractAttributeClass: string;
        static ERR_AbstractBaseCall: string;
        static ERR_AbstractEventInitializer: string;
        static ERR_AbstractField: string;
        static ERR_AbstractHasBody: string;
        static ERR_AbstractInConcreteClass: string;
        static ERR_AbstractNotVirtual: string;
        static ERR_AbstractSealedStatic: string;
        static ERR_AccessModMissingAccessor: string;
        static ERR_AccessorImplementingMethod: string;
        static ERR_AccessorListAndExpressionBody: string;
        static ERR_AddModuleAssembly: string;
        static ERR_AddOrRemoveExpected: string;
        static ERR_AddRemoveMustHaveBody: string;
        static ERR_AddrOnReadOnlyLocal: string;
        static ERR_AgnosticToMachineModule: string;
        static ERR_AliasMissingFile: string;
        static ERR_AliasNotFound: string;
        static ERR_AliasQualAsExpression: string;
        static ERR_AliasQualifiedNameNotAnExpression: string;
        static ERR_AmbigBinaryOps: string;
        static ERR_AmbigCall: string;
        static ERR_AmbigContext: string;
        static ERR_AmbigMember: string;
        static ERR_AmbigousAttribute: string;
        static ERR_AmbigOverride: string;
        static ERR_AmbigQM: string;
        static ERR_AmbigUDConv: string;
        static ERR_AmbigUnaryOp: string;
        static ERR_AnonDelegateCantUse: string;
        static ERR_AnonMethGrpInForEach: string;
        static ERR_AnonMethToNonDel: string;
        static ERR_AnonymousMethodToExpressionTree: string;
        static ERR_AnonymousReturnExpected: string;
        static ERR_AnonymousTypeDuplicatePropertyName: string;
        static ERR_AnonymousTypeNotAvailable: string;
        static ERR_AnonymousTypePropertyAssignedBadValue: string;
        static ERR_ArgsInvalid: string;
        static ERR_ArrayElementCantBeRefAny: string;
        static ERR_ArrayInitializerExpected: string;
        static ERR_ArrayInitializerIncorrectLength: string;
        static ERR_ArrayInitInBadPlace: string;
        static ERR_ArrayInitToNonArrayType: string;
        static ERR_ArrayOfStaticClass: string;
        static ERR_ArraySizeInDeclaration: string;
        static ERR_AsMustHaveReferenceType: string;
        static ERR_AssemblyMatchBadVersion: string;
        static ERR_AssemblyNameOnNonModule: string;
        static ERR_AssemblySpecifiedForLinkAndRef: string;
        static ERR_AssgLvalueExpected: string;
        static ERR_AssgReadonly: string;
        static ERR_AssgReadonly2: string;
        static ERR_AssgReadonlyLocal: string;
        static ERR_AssgReadonlyLocal2Cause: string;
        static ERR_AssgReadonlyLocalCause: string;
        static ERR_AssgReadonlyProp: string;
        static ERR_AssgReadonlyStatic: string;
        static ERR_AssgReadonlyStatic2: string;
        static ERR_AsWithTypeVar: string;
        static ERR_AttrArgWithTypeVars: string;
        static ERR_AttributeCantBeGeneric: string;
        static ERR_AttributeNotOnAccessor: string;
        static ERR_AttributeOnBadSymbolType: string;
        static ERR_AttributeParameterRequired1: string;
        static ERR_AttributeParameterRequired2: string;
        static ERR_AttributesNotAllowed: string;
        static ERR_AttributeUsageOnNonAttributeClass: string;
        static ERR_AutoPropertyInitializerInInterface: string;
        static ERR_AutoPropertyMustHaveGetAccessor: string;
        static ERR_AutoPropertyMustOverrideSet: string;
        static ERR_AwaitInUnsafeContext: string;
        static ERR_BadAccess: string;
        static ERR_BadAppConfigPath: string;
        static ERR_BadArgCount: string;
        static ERR_BadArgExtraRef: string;
        static ERR_BadArgRef: string;
        static ERR_BadArgType: string;
        static ERR_BadArgTypeDynamicExtension: string;
        static ERR_BadArgTypesForCollectionAdd: string;
        static ERR_BadArgumentToAttribute: string;
        static ERR_BadArity: string;
        static ERR_BadArraySyntax: string;
        static ERR_BadAsyncArgType: string;
        static ERR_BadAsyncExpressionTree: string;
        static ERR_BadAsyncLacksBody: string;
        static ERR_BadAsyncReturn: string;
        static ERR_BadAsyncReturnExpression: string;
        static ERR_BadAttributeArgument: string;
        static ERR_BadAttributeParamDefaultArgument: string;
        static ERR_BadAttributeParamType: string;
        static ERR_BadAwaitArg: string;
        static ERR_BadAwaitArg_NeedSystem: string;
        static ERR_BadAwaitArgIntrinsic: string;
        static ERR_BadAwaitArgVoidCall: string;
        static ERR_BadAwaitAsIdentifier: string;
        static ERR_BadAwaiterPattern: string;
        static ERR_BadAwaitInCatch: string;
        static ERR_BadAwaitInCatchFilter: string;
        static ERR_BadAwaitInFinally: string;
        static ERR_BadAwaitInLock: string;
        static ERR_BadAwaitInQuery: string;
        static ERR_BadAwaitWithoutAsync: string;
        static ERR_BadAwaitWithoutAsyncLambda: string;
        static ERR_BadAwaitWithoutAsyncMethod: string;
        static ERR_BadAwaitWithoutVoidAsyncMethod: string;
        static ERR_BadBaseNumber: string;
        static ERR_BadBaseType: string;
        static ERR_BadBinaryOperatorSignature: string;
        static ERR_BadBinaryOps: string;
        static ERR_BadBinOpArgs: string;
        static ERR_BadBoolOp: string;
        static ERR_BadBoundType: string;
        static ERR_BadCallerFilePathParamWithoutDefaultValue: string;
        static ERR_BadCallerLineNumberParamWithoutDefaultValue: string;
        static ERR_BadCallerMemberNameParamWithoutDefaultValue: string;
        static ERR_BadCastInFixed: string;
        static ERR_BadCoClassSig: string;
        static ERR_BadCompatMode: string;
        static ERR_BadCompilationOption: string;
        static ERR_BadCompilationOptionValue: string;
        static ERR_BadConstraintType: string;
        static ERR_BadConstType: string;
        static ERR_BadCtorArgCount: string;
        static ERR_BadDebugType: string;
        static ERR_BadDelArgCount: string;
        static ERR_BadDelegateConstructor: string;
        static ERR_BadDelegateLeave: string;
        static ERR_BadDestructorName: string;
        static ERR_BadDirectivePlacement: string;
        static ERR_BadDynamicConversion: string;
        static ERR_BadDynamicMethodArg: string;
        static ERR_BadDynamicMethodArgLambda: string;
        static ERR_BadDynamicMethodArgMemgrp: string;
        static ERR_BadDynamicQuery: string;
        static ERR_BadDynamicTypeof: string;
        static ERR_BadEmbeddedStmt: string;
        static ERR_BadEmptyThrow: string;
        static ERR_BadEmptyThrowInFinally: string;
        static ERR_BadEventUsage: string;
        static ERR_BadEventUsageNoField: string;
        static ERR_BadExceptionType: string;
        static ERR_BadExtensionAgg: string;
        static ERR_BadExtensionArgTypes: string;
        static ERR_BadExtensionMeth: string;
        static ERR_BadExternAlias: string;
        static ERR_BadExternIdentifier: string;
        static ERR_BadFinallyLeave: string;
        static ERR_BadFixedInitType: string;
        static ERR_BadForeachDecl: string;
        static ERR_BadGetEnumerator: string;
        static ERR_BadIncDecRetType: string;
        static ERR_BadIncDecSignature: string;
        static ERR_BadIndexCount: string;
        static ERR_BadIndexerNameAttr: string;
        static ERR_BadIndexLHS: string;
        static ERR_BadInstanceArgType: string;
        static ERR_BadIteratorArgType: string;
        static ERR_BadIteratorReturn: string;
        static ERR_BadMemberFlag: string;
        static ERR_BadMemberProtection: string;
        static ERR_BadModifierLocation: string;
        static ERR_BadModifiersOnNamespace: string;
        static ERR_BadNamedArgument: string;
        static ERR_BadNamedArgumentForDelegateInvoke: string;
        static ERR_BadNamedAttributeArgument: string;
        static ERR_BadNamedAttributeArgumentType: string;
        static ERR_BadNewExpr: string;
        static ERR_BadOperatorSyntax: string;
        static ERR_BadOutWithThis: string;
        static ERR_BadParamExtraRef: string;
        static ERR_BadParamModThis: string;
        static ERR_BadParamRef: string;
        static ERR_BadParamType: string;
        static ERR_BadPlatformType: string;
        static ERR_BadPrefer32OnLib: string;
        static ERR_BadProtectedAccess: string;
        static ERR_BadRefWithThis: string;
        static ERR_BadResourceVis: string;
        static ERR_BadRetType: string;
        static ERR_BadShiftOperatorSignature: string;
        static ERR_BadSKknown: string;
        static ERR_BadSKunknown: string;
        static ERR_BadSpecialByRefLocal: string;
        static ERR_BadStackAllocExpr: string;
        static ERR_BadSwitch: string;
        static ERR_BadThisParam: string;
        static ERR_BadTypeArgument: string;
        static ERR_BadTypeforThis: string;
        static ERR_BadTypeReference: string;
        static ERR_BadUnaryOp: string;
        static ERR_BadUnaryOperatorSignature: string;
        static ERR_BadUnOpArgs: string;
        static ERR_BadUsingNamespace: string;
        static ERR_BadUsingType: string;
        static ERR_BadVarargs: string;
        static ERR_BadVarDecl: string;
        static ERR_BadVisBaseClass: string;
        static ERR_BadVisBaseInterface: string;
        static ERR_BadVisBound: string;
        static ERR_BadVisDelegateParam: string;
        static ERR_BadVisDelegateReturn: string;
        static ERR_BadVisEventType: string;
        static ERR_BadVisFieldType: string;
        static ERR_BadVisIndexerParam: string;
        static ERR_BadVisIndexerReturn: string;
        static ERR_BadVisOpParam: string;
        static ERR_BadVisOpReturn: string;
        static ERR_BadVisParamType: string;
        static ERR_BadVisPropertyType: string;
        static ERR_BadVisReturnType: string;
        static ERR_BadWarningLevel: string;
        static ERR_BadWin32Res: string;
        static ERR_BadYieldInCatch: string;
        static ERR_BadYieldInFinally: string;
        static ERR_BadYieldInTryOfCatch: string;
        static ERR_BaseClassMustBeFirst: string;
        static ERR_BaseConstraintConflict: string;
        static ERR_BaseIllegal: string;
        static ERR_BaseInBadContext: string;
        static ERR_BaseInStaticMeth: string;
        static ERR_BinaryFile: string;
        static ERR_BindToBogus: string;
        static ERR_BindToBogusProp1: string;
        static ERR_BindToBogusProp2: string;
        static ERR_BlockBodyAndExpressionBody: string;
        static ERR_BogusExplicitImpl: string;
        static ERR_BogusType: string;
        static ERR_ByRefParameterInExpressionTree: string;
        static ERR_ByRefReturnUnsupported: string;
        static ERR_ByRefTypeAndAwait: string;
        static ERR_CallingBaseFinalizeDeprecated: string;
        static ERR_CallingFinalizeDeprecated: string;
        static ERR_CannotPassNullForFriendAssembly: string;
        static ERR_CantCallSpecialMethod: string;
        static ERR_CantChangeAccessOnOverride: string;
        static ERR_CantChangeReturnTypeOnOverride: string;
        static ERR_CantChangeTypeOnOverride: string;
        static ERR_CantConvAnonMethNoParams: string;
        static ERR_CantConvAnonMethParams: string;
        static ERR_CantConvAnonMethReturns: string;
        static ERR_CantConvAsyncAnonFuncReturns: string;
        static ERR_CantDeriveFromSealedType: string;
        static ERR_CantHaveWin32ResAndIcon: string;
        static ERR_CantHaveWin32ResAndManifest: string;
        static ERR_CantInferMethTypeArgs: string;
        static ERR_CantMakeTempFile: string;
        static ERR_CantOpenFileWrite: string;
        static ERR_CantOpenIcon: string;
        static ERR_CantOpenWin32Manifest: string;
        static ERR_CantOpenWin32Res: string;
        static ERR_CantOverrideBogusMethod: string;
        static ERR_CantOverrideNonEvent: string;
        static ERR_CantOverrideNonFunction: string;
        static ERR_CantOverrideNonProperty: string;
        static ERR_CantOverrideNonVirtual: string;
        static ERR_CantOverrideSealed: string;
        static ERR_CantReadConfigFile: string;
        static ERR_CantReadResource: string;
        static ERR_CantReadRulesetFile: string;
        static ERR_CantRefResource: string;
        static ERR_CantReturnVoid: string;
        static ERR_CantSetWin32Manifest: string;
        static ERR_CantUseRequiredAttribute: string;
        static ERR_CheckedOverflow: string;
        static ERR_CircConstValue: string;
        static ERR_CircularBase: string;
        static ERR_CircularConstraint: string;
        static ERR_ClassBoundNotFirst: string;
        static ERR_ClassDoesntImplementInterface: string;
        static ERR_ClassTypeExpected: string;
        static ERR_CloseParenExpected: string;
        static ERR_CloseUnimplementedInterfaceMemberNotPublic: string;
        static ERR_CloseUnimplementedInterfaceMemberStatic: string;
        static ERR_CloseUnimplementedInterfaceMemberWrongReturnType: string;
        static ERR_CmdOptionConflictsSource: string;
        static ERR_ColColWithTypeAlias: string;
        static ERR_CollectionInitRequiresIEnumerable: string;
        static ERR_ComImportWithBase: string;
        static ERR_ComImportWithImpl: string;
        static ERR_ComImportWithInitializers: string;
        static ERR_ComImportWithoutUuidAttribute: string;
        static ERR_ComImportWithUserCtor: string;
        static ERR_CompileCancelled: string;
        static ERR_ComRefCallInExpressionTree: string;
        static ERR_ConcreteMissingBody: string;
        static ERR_ConditionalMustReturnVoid: string;
        static ERR_ConditionalOnInterfaceMethod: string;
        static ERR_ConditionalOnNonAttributeClass: string;
        static ERR_ConditionalOnOverride: string;
        static ERR_ConditionalOnSpecialMethod: string;
        static ERR_ConditionalWithOutParam: string;
        static ERR_ConflictAliasAndMember: string;
        static ERR_ConflictingAliasAndDefinition: string;
        static ERR_ConflictingMachineModule: string;
        static ERR_ConstantExpected: string;
        static ERR_ConstOutOfRange: string;
        static ERR_ConstOutOfRangeChecked: string;
        static ERR_ConstraintIsStaticClass: string;
        static ERR_ConstraintOnlyAllowedOnGenericDecl: string;
        static ERR_ConstructedDynamicTypeAsBound: string;
        static ERR_ConstructorInStaticClass: string;
        static ERR_ConstValueRequired: string;
        static ERR_ConversionNotInvolvingContainedType: string;
        static ERR_ConversionWithBase: string;
        static ERR_ConversionWithDerived: string;
        static ERR_ConversionWithInterface: string;
        static ERR_ConvertToStaticClass: string;
        static ERR_ConWithValCon: string;
        static ERR_CryptoHashFailed: string;
        static ERR_CStyleArray: string;
        static ERR_CycleInInterfaceInheritance: string;
        static ERR_CycleInTypeForwarder: string;
        static ERR_DecConstError: string;
        static ERR_DefaultMemberOnIndexedType: string;
        static ERR_DefaultValueBadValueType: string;
        static ERR_DefaultValueBeforeRequiredValue: string;
        static ERR_DefaultValueForExtensionParameter: string;
        static ERR_DefaultValueForParamsParameter: string;
        static ERR_DefaultValueMustBeConstant: string;
        static ERR_DefaultValueNotAllowed: string;
        static ERR_DefaultValueTypeMustMatch: string;
        static ERR_DefaultValueUsedWithAttributes: string;
        static ERR_DelegateOnConditional: string;
        static ERR_DelegateOnNullable: string;
        static ERR_DeprecatedCollectionInitAddStr: string;
        static ERR_DeprecatedSymbolStr: string;
        static ERR_DeriveFromConstructedDynamic: string;
        static ERR_DeriveFromDynamic: string;
        static ERR_DeriveFromEnumOrValueType: string;
        static ERR_DerivingFromATyVar: string;
        static ERR_DestructorInStaticClass: string;
        static ERR_DictionaryInitializerInExpressionTree: string;
        static ERR_DllImportOnGenericMethod: string;
        static ERR_DllImportOnInvalidMethod: string;
        static ERR_DoesntImplementAwaitInterface: string;
        static ERR_DoNotUseFixedBufferAttr: string;
        static ERR_DottedTypeNameNotFoundInAgg: string;
        static ERR_DottedTypeNameNotFoundInNS: string;
        static ERR_DottedTypeNameNotFoundInNSFwd: string;
        static ERR_DuplicateAccessor: string;
        static ERR_DuplicateAlias: string;
        static ERR_DuplicateAttribute: string;
        static ERR_DuplicateAttributeInNetModule: string;
        static ERR_DuplicateBound: string;
        static ERR_DuplicateCaseLabel: string;
        static ERR_DuplicateConstraintClause: string;
        static ERR_DuplicateConversionInClass: string;
        static ERR_DuplicateGeneratedName: string;
        static ERR_DuplicateImport: string;
        static ERR_DuplicateImportSimple: string;
        static ERR_DuplicateInterfaceInBaseList: string;
        static ERR_DuplicateLabel: string;
        static ERR_DuplicateModifier: string;
        static ERR_DuplicateNamedArgument: string;
        static ERR_DuplicateNamedAttributeArgument: string;
        static ERR_DuplicateNameInClass: string;
        static ERR_DuplicateNameInNS: string;
        static ERR_DuplicateParamName: string;
        static ERR_DuplicatePropertyAccessMods: string;
        static ERR_DuplicateTypeForwarder: string;
        static ERR_DuplicateTypeParameter: string;
        static ERR_DupParamMod: string;
        static ERR_DynamicAttributeMissing: string;
        static ERR_DynamicRequiredTypesMissing: string;
        static ERR_DynamicTypeAsBound: string;
        static ERR_EmptyCharConst: string;
        static ERR_EmptyElementInitializer: string;
        static ERR_EmptyFormatSpecifier: string;
        static ERR_EmptyYield: string;
        static ERR_EncNoDynamicOperation: string;
        static ERR_EncNoPIAReference: string;
        static ERR_EncodinglessSyntaxTree: string;
        static ERR_EncReferenceToAddedMember: string;
        static ERR_EndifDirectiveExpected: string;
        static ERR_EndOfPPLineExpected: string;
        static ERR_EndRegionDirectiveExpected: string;
        static ERR_EnumeratorOverflow: string;
        static ERR_EnumsCantContainDefaultConstructor: string;
        static ERR_EOFExpected: string;
        static ERR_ErrorBuildingWin32Resources: string;
        static ERR_ErrorDirective: string;
        static ERR_ErrorInReferencedAssembly: string;
        static ERR_EscapedCurly: string;
        static ERR_EventNeedsBothAccessors: string;
        static ERR_EventNotDelegate: string;
        static ERR_EventPropertyInInterface: string;
        static ERR_ExpectedContextualKeywordBy: string;
        static ERR_ExpectedContextualKeywordEquals: string;
        static ERR_ExpectedContextualKeywordOn: string;
        static ERR_ExpectedEndTry: string;
        static ERR_ExpectedPPFile: string;
        static ERR_ExpectedSelectOrGroup: string;
        static ERR_ExpectedVerbatimLiteral: string;
        static ERR_ExplicitDynamicAttr: string;
        static ERR_ExplicitEventFieldImpl: string;
        static ERR_ExplicitExtension: string;
        static ERR_ExplicitImplCollisionOnRefOut: string;
        static ERR_ExplicitImplParams: string;
        static ERR_ExplicitInterfaceImplementationInNonClassOrStruct: string;
        static ERR_ExplicitInterfaceImplementationNotInterface: string;
        static ERR_ExplicitLayoutAndAutoImplementedProperty: string;
        static ERR_ExplicitMethodImplAccessor: string;
        static ERR_ExplicitParamArray: string;
        static ERR_ExplicitPropertyAddingAccessor: string;
        static ERR_ExplicitPropertyMissingAccessor: string;
        static ERR_ExportedTypeConflictsWithDeclaration: string;
        static ERR_ExportedTypesConflict: string;
        static ERR_ExpressionExpected: string;
        static ERR_ExpressionHasNoName: string;
        static ERR_ExpressionTreeContainsAnonymousMethod: string;
        static ERR_ExpressionTreeContainsAssignment: string;
        static ERR_ExpressionTreeContainsBadCoalesce: string;
        static ERR_ExpressionTreeContainsBaseAccess: string;
        static ERR_ExpressionTreeContainsDynamicOperation: string;
        static ERR_ExpressionTreeContainsIndexedProperty: string;
        static ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer: string;
        static ERR_ExpressionTreeContainsNamedArgument: string;
        static ERR_ExpressionTreeContainsOptionalArgument: string;
        static ERR_ExpressionTreeContainsPointerOp: string;
        static ERR_ExpressionTreeMustHaveDelegate: string;
        static ERR_ExtensionAttrNotFound: string;
        static ERR_ExtensionMethodsDecl: string;
        static ERR_ExternAfterElements: string;
        static ERR_ExternAliasNotAllowed: string;
        static ERR_ExternHasBody: string;
        static ERR_FeatureIsExperimental: string;
        static ERR_FeatureNotAvailableInVersion1: string;
        static ERR_FeatureNotAvailableInVersion2: string;
        static ERR_FeatureNotAvailableInVersion3: string;
        static ERR_FeatureNotAvailableInVersion4: string;
        static ERR_FeatureNotAvailableInVersion5: string;
        static ERR_FeatureNotAvailableInVersion6: string;
        static ERR_FeatureNotValidInExpressionTree: string;
        static ERR_FieldCantBeRefAny: string;
        static ERR_FieldCantHaveVoidType: string;
        static ERR_FieldHasMultipleDistinctConstantValues: string;
        static ERR_FieldInitializerInStruct: string;
        static ERR_FieldInitRefNonstatic: string;
        static ERR_FileNotFound: string;
        static ERR_FixedBufferNotFixed: string;
        static ERR_FixedBufferTooManyDimensions: string;
        static ERR_FixedDimsRequired: string;
        static ERR_FixedLocalInLambda: string;
        static ERR_FixedMustInit: string;
        static ERR_FixedNeeded: string;
        static ERR_FixedNeedsLvalue: string;
        static ERR_FixedNotInStruct: string;
        static ERR_FixedNotNeeded: string;
        static ERR_FixedOverflow: string;
        static ERR_FloatOverflow: string;
        static ERR_ForEachMissingMember: string;
        static ERR_ForwardedTypeConflictsWithDeclaration: string;
        static ERR_ForwardedTypeConflictsWithExportedType: string;
        static ERR_ForwardedTypeInThisAssembly: string;
        static ERR_ForwardedTypeIsNested: string;
        static ERR_ForwardedTypesConflict: string;
        static ERR_FriendAssemblyBadArgs: string;
        static ERR_FriendAssemblySNReq: string;
        static ERR_FriendRefNotEqualToThis: string;
        static ERR_FriendRefSigningMismatch: string;
        static ERR_GenericArgIsStaticClass: string;
        static ERR_GenericConstraintNotSatisfiedNullableEnum: string;
        static ERR_GenericConstraintNotSatisfiedNullableInterface: string;
        static ERR_GenericConstraintNotSatisfiedRefType: string;
        static ERR_GenericConstraintNotSatisfiedTyVar: string;
        static ERR_GenericConstraintNotSatisfiedValType: string;
        static ERR_GenericDerivingFromAttribute: string;
        static ERR_GenericsUsedAcrossAssemblies: string;
        static ERR_GenericsUsedInNoPIAType: string;
        static ERR_GetOrSetExpected: string;
        static ERR_GlobalAttributesNotAllowed: string;
        static ERR_GlobalAttributesNotFirst: string;
        static ERR_GlobalDefinitionOrStatementExpected: string;
        static ERR_GlobalExternAlias: string;
        static ERR_GlobalSingleTypeNameNotFound: string;
        static ERR_GlobalSingleTypeNameNotFoundFwd: string;
        static ERR_GlobalStatement: string;
        static ERR_HasNoTypeVars: string;
        static ERR_HidingAbstractMethod: string;
        static ERR_IdentifierExpected: string;
        static ERR_IdentifierExpectedKW: string;
        static ERR_IdentityConversion: string;
        static ERR_IllegalArglist: string;
        static ERR_IllegalEscape: string;
        static ERR_IllegalFixedType: string;
        static ERR_IllegalInnerUnsafe: string;
        static ERR_IllegalParams: string;
        static ERR_IllegalRefParam: string;
        static ERR_IllegalStatement: string;
        static ERR_IllegalUnsafe: string;
        static ERR_IllegalVarArgs: string;
        static ERR_IllegalVarianceSyntax: string;
        static ERR_ImplBadConstraints: string;
        static ERR_ImplicitlyTypedArrayNoBestType: string;
        static ERR_ImplicitlyTypedLocalCannotBeFixed: string;
        static ERR_ImplicitlyTypedVariableAssignedArrayInitializer: string;
        static ERR_ImplicitlyTypedVariableAssignedBadValue: string;
        static ERR_ImplicitlyTypedVariableCannotBeConst: string;
        static ERR_ImplicitlyTypedVariableMultipleDeclarator: string;
        static ERR_ImplicitlyTypedVariableWithNoInitializer: string;
        static ERR_ImportedCircularBase: string;
        static ERR_ImportNonAssembly: string;
        static ERR_InaccessibleGetter: string;
        static ERR_InaccessibleSetter: string;
        static ERR_InAttrOnOutParam: string;
        static ERR_InconsistentIndexerNames: string;
        static ERR_InconsistentLambdaParameterUsage: string;
        static ERR_IncrementLvalueExpected: string;
        static ERR_IndexedPropertyMustHaveAllOptionalParams: string;
        static ERR_IndexedPropertyRequiresParams: string;
        static ERR_IndexerCantHaveVoidType: string;
        static ERR_IndexerInStaticClass: string;
        static ERR_IndexerNeedsParam: string;
        static ERR_InExpected: string;
        static ERR_InitializerAddHasParamModifiers: string;
        static ERR_InitializerAddHasWrongSignature: string;
        static ERR_InitializerInStructWithoutExplicitConstructor: string;
        static ERR_InitializerOnNonAutoProperty: string;
        static ERR_InstanceMemberInStaticClass: string;
        static ERR_InstantiatingStaticClass: string;
        static ERR_InsufficientStack: string;
        static ERR_IntDivByZero: string;
        static ERR_IntegralTypeExpected: string;
        static ERR_IntegralTypeValueExpected: string;
        static ERR_InterfaceEventInitializer: string;
        static ERR_InterfaceImplementedByConditional: string;
        static ERR_InterfaceMemberHasBody: string;
        static ERR_InterfaceMemberNotFound: string;
        static ERR_InterfacesCannotContainTypes: string;
        static ERR_InterfacesCantContainConstructors: string;
        static ERR_InterfacesCantContainFields: string;
        static ERR_InterfacesCantContainOperators: string;
        static ERR_InteropMethodWithBody: string;
        static ERR_InteropStructContainsMethods: string;
        static ERR_InteropTypeMissingAttribute: string;
        static ERR_InteropTypesWithSameNameAndGuid: string;
        static ERR_IntOverflow: string;
        static ERR_InvalidAddrOp: string;
        static ERR_InvalidAnonymousTypeMemberDeclarator: string;
        static ERR_InvalidArray: string;
        static ERR_InvalidAssemblyCulture: string;
        static ERR_InvalidAssemblyCultureForExe: string;
        static ERR_InvalidAssemblyName: string;
        static ERR_InvalidAttributeArgument: string;
        static ERR_InvalidConstantDeclarationType: string;
        static ERR_InvalidDebugInformationFormat: string;
        static ERR_InvalidDelegateType: string;
        static ERR_InvalidDynamicCondition: string;
        static ERR_InvalidExprTerm: string;
        static ERR_InvalidFileAlignment: string;
        static ERR_InvalidFixedArraySize: string;
        static ERR_InvalidFormatForGuidForOption: string;
        static ERR_InvalidFwdType: string;
        static ERR_InvalidGotoCase: string;
        static ERR_InvalidInitializerElementInitializer: string;
        static ERR_InvalidLineNumber: string;
        static ERR_InvalidMemberDecl: string;
        static ERR_InvalidNamedArgument: string;
        static ERR_InvalidNumber: string;
        static ERR_InvalidOutputName: string;
        static ERR_InvalidPreprocExpr: string;
        static ERR_InvalidPropertyAccessMod: string;
        static ERR_InvalidQM: string;
        static ERR_InvalidSignaturePublicKey: string;
        static ERR_InvalidSpecifier: string;
        static ERR_InvalidSubsystemVersion: string;
        static ERR_InvalidVersionFormat: string;
        static ERR_InvalidVersionFormat2: string;
        static ERR_IteratorInInteractive: string;
        static ERR_LabelNotFound: string;
        static ERR_LabelShadow: string;
        static ERR_LambdaInIsAs: string;
        static ERR_LbraceExpected: string;
        static ERR_LegacyObjectIdSyntax: string;
        static ERR_LibraryMethodNotFound: string;
        static ERR_LibraryMethodNotUnique: string;
        static ERR_LinkedNetmoduleMetadataMustProvideFullPEImage: string;
        static ERR_LiteralDoubleCast: string;
        static ERR_LocalCantBeFixedAndHoisted: string;
        static ERR_LocalDuplicate: string;
        static ERR_LocalIllegallyOverrides: string;
        static ERR_LocalSameNameAsTypeParam: string;
        static ERR_LocalTypeNameClash: string;
        static ERR_LockNeedsReference: string;
        static ERR_LookupInTypeVariable: string;
        static ERR_MainCantBeAsync: string;
        static ERR_MainClassIsImport: string;
        static ERR_MainClassNotClass: string;
        static ERR_MainClassNotFound: string;
        static ERR_ManagedAddr: string;
        static ERR_MarshalUnmanagedTypeNotValidForFields: string;
        static ERR_MarshalUnmanagedTypeOnlyValidForFields: string;
        static ERR_MemberAlreadyExists: string;
        static ERR_MemberAlreadyInitialized: string;
        static ERR_MemberCannotBeInitialized: string;
        static ERR_MemberNameSameAsType: string;
        static ERR_MemberNeedsType: string;
        static ERR_MemberReserved: string;
        static ERR_MemGroupInExpressionTree: string;
        static ERR_MetadataNameTooLong: string;
        static ERR_MetadataReferencesNotSupported: string;
        static ERR_MethDelegateMismatch: string;
        static ERR_MethGrpToNonDel: string;
        static ERR_MethodArgCantBeRefAny: string;
        static ERR_MethodImplementingAccessor: string;
        static ERR_MethodNameExpected: string;
        static ERR_MethodReturnCantBeRefAny: string;
        static ERR_MissingArgument: string;
        static ERR_MissingArraySize: string;
        static ERR_MissingCoClass: string;
        static ERR_MissingDebugSwitch: string;
        static ERR_MissingGuidForOption: string;
        static ERR_MissingMethodOnSourceInterface: string;
        static ERR_MissingNetModuleReference: string;
        static ERR_MissingPartial: string;
        static ERR_MissingPPFile: string;
        static ERR_MissingPredefinedMember: string;
        static ERR_MissingSourceInterface: string;
        static ERR_MissingStructOffset: string;
        static ERR_MissingTypeInAssembly: string;
        static ERR_MissingTypeInSource: string;
        static ERR_MixingWinRTEventWithRegular: string;
        static ERR_ModuleEmitFailure: string;
        static ERR_MultiParamMod: string;
        static ERR_MultipleEntryPoints: string;
        static ERR_MultipleIEnumOfT: string;
        static ERR_MultiTypeInDeclaration: string;
        static ERR_MustHaveOpTF: string;
        static ERR_NamedArgumentExpected: string;
        static ERR_NamedArgumentForArray: string;
        static ERR_NamedArgumentSpecificationBeforeFixedArgument: string;
        static ERR_NamedArgumentUsedInPositional: string;
        static ERR_NameNotInContext: string;
        static ERR_NameNotInContextPossibleMissingReference: string;
        static ERR_NameofMethodGroupWithTypeParameters: string;
        static ERR_NamespaceNotAllowedInScript: string;
        static ERR_NamespaceUnexpected: string;
        static ERR_NegativeArraySize: string;
        static ERR_NegativeStackAllocSize: string;
        static ERR_NetModuleNameMismatch: string;
        static ERR_NetModuleNameMustBeUnique: string;
        static ERR_NewBoundMustBeLast: string;
        static ERR_NewBoundWithVal: string;
        static ERR_NewCoClassOnLink: string;
        static ERR_NewConstraintNotSatisfied: string;
        static ERR_NewlineInConst: string;
        static ERR_NewTyvarWithArgs: string;
        static ERR_NewVirtualInSealed: string;
        static ERR_NoAliasHere: string;
        static ERR_NoBaseClass: string;
        static ERR_NoBreakOrCont: string;
        static ERR_NoCanonicalView: string;
        static ERR_NoConstructors: string;
        static ERR_NoConversionForCallerFilePathParam: string;
        static ERR_NoConversionForCallerLineNumberParam: string;
        static ERR_NoConversionForCallerMemberNameParam: string;
        static ERR_NoConversionForDefaultParam: string;
        static ERR_NoConversionForNubDefaultParam: string;
        static ERR_NoConvToIDisp: string;
        static ERR_NoCorrespondingArgument: string;
        static ERR_NoDynamicPhantomOnBase: string;
        static ERR_NoDynamicPhantomOnBaseCtor: string;
        static ERR_NoDynamicPhantomOnBaseIndexer: string;
        static ERR_NoEntryPoint: string;
        static ERR_NoExplicitBuiltinConv: string;
        static ERR_NoExplicitConv: string;
        static ERR_NoFileSpec: string;
        static ERR_NoGetToOverride: string;
        static ERR_NoImplicitConv: string;
        static ERR_NoImplicitConvCast: string;
        static ERR_NoMainInClass: string;
        static ERR_NoMainOnDLL: string;
        static ERR_NoMetadataFile: string;
        static ERR_NoModifiersOnAccessor: string;
        static ERR_NoMultipleInheritance: string;
        static ERR_NoNamespacePrivate: string;
        static ERR_NoNewAbstract: string;
        static ERR_NoNewTyvar: string;
        static ERR_NonInterfaceInInterfaceList: string;
        static ERR_NonInvocableMemberCalled: string;
        static ERR_NoPIAAssemblyMissingAttribute: string;
        static ERR_NoPIAAssemblyMissingAttributes: string;
        static ERR_NoPIANestedType: string;
        static ERR_NoScriptsSpecified: string;
        static ERR_NoSetToOverride: string;
        static ERR_NoSourceFile: string;
        static ERR_NoSuchMember: string;
        static ERR_NoSuchMemberOrExtension: string;
        static ERR_NoSuchMemberOrExtensionNeedUsing: string;
        static ERR_NotAnAttributeClass: string;
        static ERR_NotConstantExpression: string;
        static ERR_NotNullConstRefField: string;
        static ERR_NotNullRefDefaultParameter: string;
        static ERR_NotYetImplementedInRoslyn: string;
        static ERR_NoTypeDef: string;
        static ERR_NoTypeDefFromModule: string;
        static ERR_NoVoidHere: string;
        static ERR_NoVoidParameter: string;
        static ERR_NullNotValid: string;
        static ERR_NullPropagatingOpInExpressionTree: string;
        static ERR_ObjectCallingBaseConstructor: string;
        static ERR_ObjectCantHaveBases: string;
        static ERR_ObjectOrCollectionInitializerWithDelegateCreation: string;
        static ERR_ObjectProhibited: string;
        static ERR_ObjectRequired: string;
        static ERR_OneAliasPerReference: string;
        static ERR_OnlyClassesCanContainDestructors: string;
        static ERR_OpenEndedComment: string;
        static ERR_OpenResponseFile: string;
        static ERR_OperatorCantReturnVoid: string;
        static ERR_OperatorInStaticClass: string;
        static ERR_OperatorNeedsMatch: string;
        static ERR_OperatorsMustBeStatic: string;
        static ERR_OpTFRetType: string;
        static ERR_OutAttrOnRefParam: string;
        static ERR_OutputNeedsName: string;
        static ERR_OutputWriteFailed: string;
        static ERR_OverloadRefOut: string;
        static ERR_OverloadRefOutCtor: string;
        static ERR_OverrideFinalizeDeprecated: string;
        static ERR_OverrideNotExpected: string;
        static ERR_OverrideNotNew: string;
        static ERR_OverrideWithConstraints: string;
        static ERR_OvlBinaryOperatorExpected: string;
        static ERR_OvlOperatorExpected: string;
        static ERR_OvlUnaryOperatorExpected: string;
        static ERR_ParamDefaultValueDiffersFromAttribute: string;
        static ERR_ParameterIsStaticClass: string;
        static ERR_ParameterlessStructCtorsMustBePublic: string;
        static ERR_ParameterNotValidForType: string;
        static ERR_ParamsCantBeRefOut: string;
        static ERR_ParamsLast: string;
        static ERR_ParamsMustBeArray: string;
        static ERR_ParamUnassigned: string;
        static ERR_PartialMethodCannotHaveOutParameters: string;
        static ERR_PartialMethodExtensionDifference: string;
        static ERR_PartialMethodInconsistentConstraints: string;
        static ERR_PartialMethodInExpressionTree: string;
        static ERR_PartialMethodInvalidModifier: string;
        static ERR_PartialMethodMustHaveLatent: string;
        static ERR_PartialMethodMustReturnVoid: string;
        static ERR_PartialMethodNotExplicit: string;
        static ERR_PartialMethodOnlyInPartialClass: string;
        static ERR_PartialMethodOnlyMethods: string;
        static ERR_PartialMethodOnlyOneActual: string;
        static ERR_PartialMethodOnlyOneLatent: string;
        static ERR_PartialMethodParamsDifference: string;
        static ERR_PartialMethodStaticDifference: string;
        static ERR_PartialMethodToDelegate: string;
        static ERR_PartialMethodUnsafeDifference: string;
        static ERR_PartialMisplaced: string;
        static ERR_PartialModifierConflict: string;
        static ERR_PartialMultipleBases: string;
        static ERR_PartialTypeKindConflict: string;
        static ERR_PartialWrongConstraints: string;
        static ERR_PartialWrongTypeParams: string;
        static ERR_PartialWrongTypeParamsVariance: string;
        static ERR_PermissionSetAttributeFileReadError: string;
        static ERR_PermissionSetAttributeInvalidFile: string;
        static ERR_PointerInAsOrIs: string;
        static ERR_PPDefFollowsToken: string;
        static ERR_PPDirectiveExpected: string;
        static ERR_PPReferenceFollowsToken: string;
        static ERR_PredefinedTypeNotFound: string;
        static ERR_PrincipalPermissionInvalidAction: string;
        static ERR_PrivateAbstractAccessor: string;
        static ERR_PropertyAccessModInInterface: string;
        static ERR_PropertyCantHaveVoidType: string;
        static ERR_PropertyLacksGet: string;
        static ERR_PropertyWithNoAccessors: string;
        static ERR_ProtectedInStatic: string;
        static ERR_ProtectedInStruct: string;
        static ERR_PtrExpected: string;
        static ERR_PtrIndexSingle: string;
        static ERR_PublicKeyContainerFailure: string;
        static ERR_PublicKeyFileFailure: string;
        static ERR_QueryDuplicateRangeVariable: string;
        static ERR_QueryInnerKey: string;
        static ERR_QueryMultipleProviders: string;
        static ERR_QueryNoProvider: string;
        static ERR_QueryNoProviderCastable: string;
        static ERR_QueryNoProviderStandard: string;
        static ERR_QueryOuterKey: string;
        static ERR_QueryOutRefRangeVariable: string;
        static ERR_QueryRangeVariableAssignedBadValue: string;
        static ERR_QueryRangeVariableOverrides: string;
        static ERR_QueryRangeVariableReadOnly: string;
        static ERR_QueryRangeVariableSameAsTypeParam: string;
        static ERR_QueryTypeInferenceFailed: string;
        static ERR_QueryTypeInferenceFailedMulti: string;
        static ERR_QueryTypeInferenceFailedSelectMany: string;
        static ERR_RbraceExpected: string;
        static ERR_ReadonlyValueTypeInObjectInitializer: string;
        static ERR_RecursiveConstructorCall: string;
        static ERR_RecursivelyTypedVariable: string;
        static ERR_RefConstraintNotSatisfied: string;
        static ERR_ReferenceDirectiveOnlyAllowedInScripts: string;
        static ERR_RefLvalueExpected: string;
        static ERR_RefOutDefaultValue: string;
        static ERR_RefProperty: string;
        static ERR_RefReadonly: string;
        static ERR_RefReadonly2: string;
        static ERR_RefReadonlyLocal: string;
        static ERR_RefReadonlyLocal2Cause: string;
        static ERR_RefReadonlyLocalCause: string;
        static ERR_RefReadonlyStatic: string;
        static ERR_RefReadonlyStatic2: string;
        static ERR_RefValBoundMustBeFirst: string;
        static ERR_RefValBoundWithClass: string;
        static ERR_ReservedAssemblyName: string;
        static ERR_ReservedEnumerator: string;
        static ERR_ResourceFileNameNotUnique: string;
        static ERR_ResourceNotUnique: string;
        static ERR_RetNoObjectRequired: string;
        static ERR_RetNoObjectRequiredLambda: string;
        static ERR_RetObjectRequired: string;
        static ERR_ReturnExpected: string;
        static ERR_ReturnInIterator: string;
        static ERR_ReturnNotAllowedInScript: string;
        static ERR_ReturnNotLValue: string;
        static ERR_ReturnTypeIsStaticClass: string;
        static ERR_SameFullNameAggAgg: string;
        static ERR_SameFullNameNsAgg: string;
        static ERR_SameFullNameThisAggThisNs: string;
        static ERR_SealedNonOverride: string;
        static ERR_SealedStaticClass: string;
        static ERR_SecurityAttributeInvalidAction: string;
        static ERR_SecurityAttributeInvalidActionAssembly: string;
        static ERR_SecurityAttributeInvalidActionTypeOrMethod: string;
        static ERR_SecurityAttributeInvalidTarget: string;
        static ERR_SecurityAttributeMissingAction: string;
        static ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync: string;
        static ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct: string;
        static ERR_SemicolonExpected: string;
        static ERR_SemiOrLBraceExpected: string;
        static ERR_SignButNoPrivateKey: string;
        static ERR_SingleLineCommentInExpressionHole: string;
        static ERR_SingleTypeNameNotFound: string;
        static ERR_SingleTypeNameNotFoundFwd: string;
        static ERR_SizeofUnsafe: string;
        static ERR_SpecialByRefInLambda: string;
        static ERR_SpecialTypeAsBound: string;
        static ERR_StackallocInCatchFinally: string;
        static ERR_StatementLambdaToExpressionTree: string;
        static ERR_StaticBaseClass: string;
        static ERR_StaticClassInterfaceImpl: string;
        static ERR_StaticConstant: string;
        static ERR_StaticConstParam: string;
        static ERR_StaticConstructorWithAccessModifiers: string;
        static ERR_StaticConstructorWithExplicitConstructorCall: string;
        static ERR_StaticDerivedFromNonObject: string;
        static ERR_StaticInAsOrIs: string;
        static ERR_StaticMemberInObjectInitializer: string;
        static ERR_StaticNotVirtual: string;
        static ERR_StructLayoutCycle: string;
        static ERR_StructOffsetOnBadField: string;
        static ERR_StructOffsetOnBadStruct: string;
        static ERR_StructsCantContainDefaultConstructor: string;
        static ERR_StructWithBaseConstructorCall: string;
        static ERR_SubexpressionNotInNameof: string;
        static ERR_SwitchFallOut: string;
        static ERR_SwitchFallThrough: string;
        static ERR_SwitchGoverningTypeValueExpected: string;
        static ERR_SwitchNeedsNumber: string;
        static ERR_SwitchNeedsString: string;
        static ERR_SynchronizedAsyncMethod: string;
        static ERR_SyntaxError: string;
        static ERR_SystemVoid: string;
        static ERR_TaskRetNoObjectRequired: string;
        static ERR_TaskRetNoObjectRequiredLambda: string;
        static ERR_ThisInBadContext: string;
        static ERR_ThisInStaticMeth: string;
        static ERR_ThisOrBaseExpected: string;
        static ERR_ThisStructNotInAnonMeth: string;
        static ERR_TooManyCatches: string;
        static ERR_TooManyCharsInConst: string;
        static ERR_TooManyLocals: string;
        static ERR_TrailingWhitespaceInFormatSpecifier: string;
        static ERR_TypeArgsNotAllowed: string;
        static ERR_TypeExpected: string;
        static ERR_TypeParamMustBeIdentifier: string;
        static ERR_TypeVarCantBeNull: string;
        static ERR_TypeVariableSameAsParent: string;
        static ERR_TypeVarNotFound: string;
        static ERR_TypeVarNotFoundRangeVariable: string;
        static ERR_TyVarNotFoundInConstraint: string;
        static ERR_UnassignedThis: string;
        static ERR_UnassignedThisAutoProperty: string;
        static ERR_UnboxNotLValue: string;
        static ERR_UnclosedExpressionHole: string;
        static ERR_UnescapedCurly: string;
        static ERR_UnexpectedAliasedName: string;
        static ERR_UnexpectedBoundGenericName: string;
        static ERR_UnexpectedCharacter: string;
        static ERR_UnexpectedDirective: string;
        static ERR_UnexpectedGenericName: string;
        static ERR_UnexpectedSemicolon: string;
        static ERR_UnexpectedUnboundGenericName: string;
        static ERR_UnexpectedVariance: string;
        static ERR_UnifyingInterfaceInstantiations: string;
        static ERR_UnimplementedAbstractMethod: string;
        static ERR_UnimplementedInterfaceAccessor: string;
        static ERR_UnimplementedInterfaceMember: string;
        static ERR_UnreachableCatch: string;
        static ERR_UnsafeAsyncArgType: string;
        static ERR_UnsafeIteratorArgType: string;
        static ERR_UnsafeNeeded: string;
        static ERR_UnsafeTypeInObjectCreation: string;
        static ERR_UnsupportedTransparentIdentifierAccess: string;
        static ERR_UnterminatedStringLit: string;
        static ERR_UseDefViolation: string;
        static ERR_UseDefViolationField: string;
        static ERR_UseDefViolationOut: string;
        static ERR_UseDefViolationProperty: string;
        static ERR_UseDefViolationThis: string;
        static ERR_UsingAfterElements: string;
        static ERR_ValConstraintNotSatisfied: string;
        static ERR_ValueCantBeNull: string;
        static ERR_ValueExpected: string;
        static ERR_ValueTypeExtDelegate: string;
        static ERR_ValueTypePropertyInObjectInitializer: string;
        static ERR_VarargsAsync: string;
        static ERR_VarArgsInExpressionTree: string;
        static ERR_VarargsIterator: string;
        static ERR_VarargsLast: string;
        static ERR_VarDeclIsStaticClass: string;
        static ERR_VariableUsedBeforeDeclaration: string;
        static ERR_VariableUsedBeforeDeclarationAndHidesField: string;
        static ERR_VirtualPrivate: string;
        static ERR_VoidError: string;
        static ERR_VolatileAndReadonly: string;
        static ERR_VolatileStruct: string;
        static ERR_WinRtEventPassedByRef: string;
        static ERR_YieldInAnonMeth: string;
        static FTL_BadChecksumAlgorithm: string;
        static FTL_BadCodepage: string;
        static FTL_DebugEmitFailure: string;
        static FTL_InputFileNameTooLong: string;
        static FTL_InvalidTarget: string;
        static FTL_MetadataCantOpenFile: string;
        static FTL_OutputFileExists: string;
        static GenericParameterDefinition: string;
        static HDN_UnusedExternAlias: string;
        static HDN_UnusedUsingDirective: string;
        static IDS_AnonMethod: string;
        static IDS_Collection: string;
        static IDS_Contravariant: string;
        static IDS_Contravariantly: string;
        static IDS_Covariant: string;
        static IDS_Covariantly: string;
        static IDS_CSCHelp: string;
        static IDS_DirectoryDoesNotExist: string;
        static IDS_DirectoryHasInvalidPath: string;
        static IDS_FeatureAnonDelegates: string;
        static IDS_FeatureAnonymousTypes: string;
        static IDS_FeatureAsync: string;
        static IDS_FeatureAutoImplementedProperties: string;
        static IDS_FeatureAutoPropertyInitializer: string;
        static IDS_FeatureCollectionInitializer: string;
        static IDS_FeatureDeclarationExpression: string;
        static IDS_FeatureDefault: string;
        static IDS_FeatureDictionaryInitializer: string;
        static IDS_FeatureDynamic: string;
        static IDS_FeatureExceptionFilter: string;
        static IDS_FeatureExpressionBodiedIndexer: string;
        static IDS_FeatureExpressionBodiedMethod: string;
        static IDS_FeatureExpressionBodiedProperty: string;
        static IDS_FeatureExtensionMethod: string;
        static IDS_FeatureExternAlias: string;
        static IDS_FeatureFixedBuffer: string;
        static IDS_FeatureGenerics: string;
        static IDS_FeatureGlobalNamespace: string;
        static IDS_FeatureImplicitArray: string;
        static IDS_FeatureImplicitLocal: string;
        static IDS_FeatureInterpolatedStrings: string;
        static IDS_FeatureIterators: string;
        static IDS_FeatureLambda: string;
        static IDS_FeatureModuleAttrLoc: string;
        static IDS_FeatureNamedArgument: string;
        static IDS_FeatureNameof: string;
        static IDS_FeatureNullable: string;
        static IDS_FeatureNullPropagatingOperator: string;
        static IDS_FeatureObjectInitializer: string;
        static IDS_FeatureOptionalParameter: string;
        static IDS_FeaturePartialMethod: string;
        static IDS_FeaturePartialTypes: string;
        static IDS_FeaturePragma: string;
        static IDS_FeaturePropertyAccessorMods: string;
        static IDS_FeatureQueryExpression: string;
        static IDS_FeatureStaticClasses: string;
        static IDS_FeatureStructParameterlessConstructors: string;
        static IDS_FeatureSwitchOnBool: string;
        static IDS_FeatureTypeVariance: string;
        static IDS_FeatureUsingStatic: string;
        static IDS_FIXEDLOCAL: string;
        static IDS_FOREACHLOCAL: string;
        static IDS_GlobalNamespace: string;
        static IDS_Invariantly: string;
        static IDS_Lambda: string;
        static IDS_LIB_ENV: string;
        static IDS_LIB_OPTION: string;
        static IDS_LogoLine1: string;
        static IDS_LogoLine2: string;
        static IDS_MethodGroup: string;
        static IDS_Namespace1: string;
        static IDS_NULL: string;
        static IDS_PathList: string;
        static IDS_REFERENCEPATH_OPTION: string;
        static IDS_RELATEDERROR: string;
        static IDS_RELATEDWARNING: string;
        static IDS_SK_ALIAS: string;
        static IDS_SK_EVENT: string;
        static IDS_SK_EXTERNALIAS: string;
        static IDS_SK_FIELD: string;
        static IDS_SK_LABEL: string;
        static IDS_SK_METHOD: string;
        static IDS_SK_NAMESPACE: string;
        static IDS_SK_PROPERTY: string;
        static IDS_SK_TYPE: string;
        static IDS_SK_TYVAR: string;
        static IDS_SK_UNKNOWN: string;
        static IDS_SK_VARIABLE: string;
        static IDS_Text: string;
        static IDS_USINGLOCAL: string;
        static IDS_VersionExperimental: string;
        static IDS_XMLBADINCLUDE: string;
        static IDS_XMLFAILEDINCLUDE: string;
        static IDS_XMLIGNORED: string;
        static IDS_XMLIGNORED2: string;
        static IDS_XMLMISSINGINCLUDEFILE: string;
        static IDS_XMLMISSINGINCLUDEPATH: string;
        static IDS_XMLNOINCLUDE: string;
        static INF_UnableToLoadSomeTypesInAnalyzer: string;
        static InvalidGetDeclarationNameMultipleDeclarators: string;
        static ItemsMustBeNonEmpty: string;
        static LocationMustBeProvided: string;
        static LookupOptionsHasInvalidCombo: string;
        static MustCallSetMethodTestData: string;
        static NameConflictForName: string;
        static NoNoneSearchCriteria: string;
        static NotACSharpSymbol: string;
        static OperationCausedStackOverflow: string;
        static PositionIsNotWithinSyntax: string;
        static PositionNotWithinTree: string;
        static SeparatorIsExpected: string;
        static SpeculatedSyntaxNodeCannotBelongToCurrentCompilation: string;
        static SubmissionCanHaveAtMostOne: string;
        static SubmissionCanOnlyInclude: string;
        static SyntaxNodeIsNotWithinSynt: string;
        static SyntaxTreeAlreadyPresent: string;
        static SyntaxTreeNotFoundTo: string;
        static SyntaxTreeSemanticModelMust: string;
        static TheStreamCannotBeReadFrom: string;
        static TheStreamCannotBeWritten: string;
        static ThisCompilationNotInteractive: string;
        static ThisMethodCanOnlyBeUsedToCreateTokens: string;
        static TreeMustHaveARootNodeWith: string;
        static TreeNotPartOfCompilation: string;
        static Trees0: string;
        static TreesMustHaveRootNode: string;
        static TypeArgumentCannotBeNull: string;
        static UseLiteralForNumeric: string;
        static UseLiteralForTokens: string;
        static UseVerbatimIdentifier: string;
        static WRN_AlwaysNull: string;
        static WRN_AmbiguousXMLReference: string;
        static WRN_AnalyzerCannotBeCreated: string;
        static WRN_AssemblyAttributeFromModuleIsOverridden: string;
        static WRN_AssignmentToLockOrDispose: string;
        static WRN_AssignmentToSelf: string;
        static WRN_AsyncLacksAwaits: string;
        static WRN_AttributeLocationOnBadDeclaration: string;
        static WRN_BadRefCompareLeft: string;
        static WRN_BadRefCompareRight: string;
        static WRN_BadRestoreNumber: string;
        static WRN_BadUILang: string;
        static WRN_BadWarningNumber: string;
        static WRN_BadXMLRef: string;
        static WRN_BadXMLRefParamType: string;
        static WRN_BadXMLRefReturnType: string;
        static WRN_BadXMLRefSyntax: string;
        static WRN_BadXMLRefTypeVar: string;
        static WRN_BitwiseOrSignExtend: string;
        static WRN_ByRefNonAgileField: string;
        static WRN_CA2000_DisposeObjectsBeforeLosingScope1: string;
        static WRN_CA2000_DisposeObjectsBeforeLosingScope2: string;
        static WRN_CA2202_DoNotDisposeObjectsMultipleTimes: string;
        static WRN_CallerFilePathParamForUnconsumedLocation: string;
        static WRN_CallerFilePathPreferredOverCallerMemberName: string;
        static WRN_CallerLineNumberParamForUnconsumedLocation: string;
        static WRN_CallerLineNumberPreferredOverCallerFilePath: string;
        static WRN_CallerLineNumberPreferredOverCallerMemberName: string;
        static WRN_CallerMemberNameParamForUnconsumedLocation: string;
        static WRN_CallOnNonAgileField: string;
        static WRN_CantHaveManifestForModule: string;
        static WRN_CLS_ArrayArgumentToAttribute: string;
        static WRN_CLS_AssemblyNotCLS: string;
        static WRN_CLS_AssemblyNotCLS2: string;
        static WRN_CLS_BadArgType: string;
        static WRN_CLS_BadAttributeType: string;
        static WRN_CLS_BadBase: string;
        static WRN_CLS_BadFieldPropType: string;
        static WRN_CLS_BadIdentifier: string;
        static WRN_CLS_BadIdentifierCase: string;
        static WRN_CLS_BadInterface: string;
        static WRN_CLS_BadInterfaceMember: string;
        static WRN_CLS_BadReturnType: string;
        static WRN_CLS_BadTypeVar: string;
        static WRN_CLS_IllegalTrueInFalse: string;
        static WRN_CLS_MeaninglessOnParam: string;
        static WRN_CLS_MeaninglessOnPrivateType: string;
        static WRN_CLS_MeaninglessOnReturn: string;
        static WRN_CLS_ModuleMissingCLS: string;
        static WRN_CLS_NoAbstractMembers: string;
        static WRN_CLS_NotOnModules: string;
        static WRN_CLS_NotOnModules2: string;
        static WRN_CLS_NoVarArgs: string;
        static WRN_CLS_OverloadRefOut: string;
        static WRN_CLS_OverloadUnnamed: string;
        static WRN_CLS_VolatileField: string;
        static WRN_CmdOptionConflictsSource: string;
        static WRN_CmpAlwaysFalse: string;
        static WRN_CoClassWithoutComImport: string;
        static WRN_ComparisonToSelf: string;
        static WRN_ConflictingChecksum: string;
        static WRN_ConflictingMachineAssembly: string;
        static WRN_DebugFullNameTooLong: string;
        static WRN_DefaultValueForUnconsumedLocation: string;
        static WRN_DefineIdentifierRequired: string;
        static WRN_DelaySignButNoKey: string;
        static WRN_DeprecatedCollectionInitAdd: string;
        static WRN_DeprecatedCollectionInitAddStr: string;
        static WRN_DeprecatedSymbol: string;
        static WRN_DeprecatedSymbolStr: string;
        static WRN_DotOnDefault: string;
        static WRN_DuplicateParamTag: string;
        static WRN_DuplicateTypeParamTag: string;
        static WRN_DuplicateUsing: string;
        static WRN_DynamicDispatchToConditionalMethod: string;
        static WRN_EmptySwitch: string;
        static WRN_EndOfPPLineExpected: string;
        static WRN_EqualityOpWithoutEquals: string;
        static WRN_EqualityOpWithoutGetHashCode: string;
        static WRN_EqualsWithoutGetHashCode: string;
        static WRN_ErrorOverride: string;
        static WRN_ExplicitImplCollision: string;
        static WRN_ExternCtorNoImplementation: string;
        static WRN_ExternMethodNoImplementation: string;
        static WRN_FailedInclude: string;
        static WRN_FileAlreadyIncluded: string;
        static WRN_FileNameTooLong: string;
        static WRN_FilterIsConstant: string;
        static WRN_FinalizeMethod: string;
        static WRN_GlobalAliasDefn: string;
        static WRN_GotoCaseShouldConvert: string;
        static WRN_IdentifierOrNumericLiteralExpected: string;
        static WRN_IllegalPPChecksum: string;
        static WRN_IllegalPPWarning: string;
        static WRN_IllegalPragma: string;
        static WRN_IncorrectBooleanAssg: string;
        static WRN_InvalidAssemblyName: string;
        static WRN_InvalidAttributeLocation: string;
        static WRN_InvalidInclude: string;
        static WRN_InvalidMainSig: string;
        static WRN_InvalidNumber: string;
        static WRN_InvalidSearchPathDir: string;
        static WRN_InvalidVersionFormat: string;
        static WRN_IsAlwaysFalse: string;
        static WRN_IsAlwaysTrue: string;
        static WRN_IsDynamicIsConfusing: string;
        static WRN_LowercaseEllSuffix: string;
        static WRN_MainCantBeGeneric: string;
        static WRN_MainIgnored: string;
        static WRN_MissingParamTag: string;
        static WRN_MissingTypeParamTag: string;
        static WRN_MissingXMLComment: string;
        static WRN_MultiplePredefTypes: string;
        static WRN_MultipleRuntimeImplementationMatches: string;
        static WRN_MultipleRuntimeOverrideMatches: string;
        static WRN_NegativeArrayIndex: string;
        static WRN_NewNotRequired: string;
        static WRN_NewOrOverrideExpected: string;
        static WRN_NewRequired: string;
        static WRN_NoAnalyzerInAssembly: string;
        static WRN_NoConfigNotOnCommandLine: string;
        static WRN_NonECMAFeature: string;
        static WRN_NonObsoleteOverridingObsolete: string;
        static WRN_NoRuntimeMetadataVersion: string;
        static WRN_NoSources: string;
        static WRN_NubExprIsConstBool: string;
        static WRN_NubExprIsConstBool2: string;
        static WRN_ObsoleteOverridingNonObsolete: string;
        static WRN_PatternBadSignature: string;
        static WRN_PatternIsAmbiguous: string;
        static WRN_PatternStaticOrInaccessible: string;
        static WRN_PdbLocalNameTooLong: string;
        static WRN_PossibleMistakenNullStatement: string;
        static WRN_ProtectedInSealed: string;
        static WRN_RefCultureMismatch: string;
        static WRN_ReferencedAssemblyDoesNotHaveStrongName: string;
        static WRN_ReferencedAssemblyReferencesLinkedPIA: string;
        static WRN_SameFullNameThisAggAgg: string;
        static WRN_SameFullNameThisAggNs: string;
        static WRN_SameFullNameThisNsAgg: string;
        static WRN_SequentialOnPartialClass: string;
        static WRN_TooManyLinesForDebugger: string;
        static WRN_TypeParameterSameAsOuterTypeParameter: string;
        static WRN_UnableToLoadAnalyzer: string;
        static WRN_UnassignedInternalField: string;
        static WRN_UnifyReferenceBldRev: string;
        static WRN_UnifyReferenceMajMin: string;
        static WRN_UnimplementedCommandLineSwitch: string;
        static WRN_UnmatchedParamRefTag: string;
        static WRN_UnmatchedParamTag: string;
        static WRN_UnmatchedTypeParamRefTag: string;
        static WRN_UnmatchedTypeParamTag: string;
        static WRN_UnobservedAwaitableExpression: string;
        static WRN_UnprocessedXMLComment: string;
        static WRN_UnqualifiedNestedTypeInCref: string;
        static WRN_UnreachableCode: string;
        static WRN_UnreachableGeneralCatch: string;
        static WRN_UnreferencedEvent: string;
        static WRN_UnreferencedField: string;
        static WRN_UnreferencedFieldAssg: string;
        static WRN_UnreferencedLabel: string;
        static WRN_UnreferencedVar: string;
        static WRN_UnreferencedVarAssg: string;
        static WRN_VacuousIntegralComp: string;
        static WRN_VolatileByRef: string;
        static WRN_WarningDirective: string;
        static WRN_XMLParseError: string;
        static WRN_XMLParseIncludeError: string;
        static WrongNumberOfTypeArguments: string;
        static WrongSemanticModelType: string;
        static XML_CDataEndTagNotAllowed: string;
        static XML_DuplicateAttribute: string;
        static XML_ElementTypeMatch: string;
        static XML_EndTagExpected: string;
        static XML_EndTagNotExpected: string;
        static XML_ExpectedEndOfTag: string;
        static XML_ExpectedEndOfXml: string;
        static XML_ExpectedIdentifier: string;
        static XML_IncorrectComment: string;
        static XML_InvalidCharEntity: string;
        static XML_InvalidToken: string;
        static XML_InvalidUnicodeChar: string;
        static XML_InvalidWhitespace: string;
        static XML_LessThanInAttributeValue: string;
        static XML_MissingEqualsAttribute: string;
        static XML_RefUndefinedEntity_1: string;
        static XML_StringLiteralNoEndQuote: string;
        static XML_StringLiteralNonAsciiQuote: string;
        static XML_StringLiteralNoStartQuote: string;
        static XML_WhitespaceMissing: string;
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class CSDiagnostic extends DiagnosticWithInfo {
        ctor_1858(info: DiagnosticInfo, location: Location): CSDiagnostic;
        ToString(): string;
        WithLocation(location: Location): Diagnostic;
        WithSeverity(severity: DiagnosticSeverity): Diagnostic;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class CSharpDiagnosticFormatter extends DiagnosticFormatter {
        ctor_1898(): CSharpDiagnosticFormatter;
        static Instance: CSharpDiagnosticFormatter;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    enum ErrorCode {
        Void,
        Unknown,
        ERR_NoMetadataFile = 6,
        FTL_MetadataCantOpenFile = 9,
        ERR_NoTypeDef = 12,
        ERR_OutputWriteFailed = 16,
        ERR_MultipleEntryPoints = 17,
        ERR_BadBinaryOps = 19,
        ERR_IntDivByZero = 20,
        ERR_BadIndexLHS = 21,
        ERR_BadIndexCount = 22,
        ERR_BadUnaryOp = 23,
        ERR_ThisInStaticMeth = 26,
        ERR_ThisInBadContext = 27,
        WRN_InvalidMainSig = 28,
        ERR_NoImplicitConv = 29,
        ERR_NoExplicitConv = 30,
        ERR_ConstOutOfRange = 31,
        ERR_AmbigBinaryOps = 34,
        ERR_AmbigUnaryOp = 35,
        ERR_InAttrOnOutParam = 36,
        ERR_ValueCantBeNull = 37,
        ERR_NoExplicitBuiltinConv = 39,
        FTL_DebugEmitFailure = 41,
        ERR_BadVisReturnType = 50,
        ERR_BadVisParamType = 51,
        ERR_BadVisFieldType = 52,
        ERR_BadVisPropertyType = 53,
        ERR_BadVisIndexerReturn = 54,
        ERR_BadVisIndexerParam = 55,
        ERR_BadVisOpReturn = 56,
        ERR_BadVisOpParam = 57,
        ERR_BadVisDelegateReturn = 58,
        ERR_BadVisDelegateParam = 59,
        ERR_BadVisBaseClass = 60,
        ERR_BadVisBaseInterface = 61,
        ERR_EventNeedsBothAccessors = 65,
        ERR_EventNotDelegate = 66,
        WRN_UnreferencedEvent = 67,
        ERR_InterfaceEventInitializer = 68,
        ERR_EventPropertyInInterface = 69,
        ERR_BadEventUsage = 70,
        ERR_ExplicitEventFieldImpl = 71,
        ERR_CantOverrideNonEvent = 72,
        ERR_AddRemoveMustHaveBody = 73,
        ERR_AbstractEventInitializer = 74,
        ERR_ReservedEnumerator = 76,
        ERR_AsMustHaveReferenceType = 77,
        WRN_LowercaseEllSuffix = 78,
        ERR_BadEventUsageNoField = 79,
        ERR_ConstraintOnlyAllowedOnGenericDecl = 80,
        ERR_TypeParamMustBeIdentifier = 81,
        ERR_MemberReserved = 82,
        ERR_DuplicateParamName = 100,
        ERR_DuplicateNameInNS = 101,
        ERR_DuplicateNameInClass = 102,
        ERR_NameNotInContext = 103,
        ERR_AmbigContext = 104,
        WRN_DuplicateUsing = 105,
        ERR_BadMemberFlag = 106,
        ERR_BadMemberProtection = 107,
        WRN_NewRequired = 108,
        WRN_NewNotRequired = 109,
        ERR_CircConstValue = 110,
        ERR_MemberAlreadyExists = 111,
        ERR_StaticNotVirtual = 112,
        ERR_OverrideNotNew = 113,
        WRN_NewOrOverrideExpected = 114,
        ERR_OverrideNotExpected = 115,
        ERR_NamespaceUnexpected = 116,
        ERR_NoSuchMember = 117,
        ERR_BadSKknown = 118,
        ERR_BadSKunknown = 119,
        ERR_ObjectRequired = 120,
        ERR_AmbigCall = 121,
        ERR_BadAccess = 122,
        ERR_MethDelegateMismatch = 123,
        ERR_RetObjectRequired = 126,
        ERR_RetNoObjectRequired = 127,
        ERR_LocalDuplicate = 128,
        ERR_AssgLvalueExpected = 131,
        ERR_StaticConstParam = 132,
        ERR_NotConstantExpression = 133,
        ERR_NotNullConstRefField = 134,
        ERR_LocalIllegallyOverrides = 136,
        ERR_BadUsingNamespace = 138,
        ERR_NoBreakOrCont = 139,
        ERR_DuplicateLabel = 140,
        ERR_NoConstructors = 143,
        ERR_NoNewAbstract = 144,
        ERR_ConstValueRequired = 145,
        ERR_CircularBase = 146,
        ERR_BadDelegateConstructor = 148,
        ERR_MethodNameExpected = 149,
        ERR_ConstantExpected = 150,
        ERR_SwitchGoverningTypeValueExpected = 151,
        ERR_DuplicateCaseLabel = 152,
        ERR_InvalidGotoCase = 153,
        ERR_PropertyLacksGet = 154,
        ERR_BadExceptionType = 155,
        ERR_BadEmptyThrow = 156,
        ERR_BadFinallyLeave = 157,
        ERR_LabelShadow = 158,
        ERR_LabelNotFound = 159,
        ERR_UnreachableCatch = 160,
        ERR_ReturnExpected = 161,
        WRN_UnreachableCode = 162,
        ERR_SwitchFallThrough = 163,
        WRN_UnreferencedLabel = 164,
        ERR_UseDefViolation = 165,
        WRN_UnreferencedVar = 168,
        WRN_UnreferencedField = 169,
        ERR_UseDefViolationField = 170,
        ERR_UnassignedThis = 171,
        ERR_AmbigQM = 172,
        ERR_InvalidQM = 173,
        ERR_NoBaseClass = 174,
        ERR_BaseIllegal = 175,
        ERR_ObjectProhibited = 176,
        ERR_ParamUnassigned = 177,
        ERR_InvalidArray = 178,
        ERR_ExternHasBody = 179,
        ERR_AbstractAndExtern = 180,
        ERR_BadAttributeParamType = 181,
        ERR_BadAttributeArgument = 182,
        WRN_IsAlwaysTrue = 183,
        WRN_IsAlwaysFalse = 184,
        ERR_LockNeedsReference = 185,
        ERR_NullNotValid = 186,
        ERR_UseDefViolationThis = 188,
        ERR_ArgsInvalid = 190,
        ERR_AssgReadonly = 191,
        ERR_RefReadonly = 192,
        ERR_PtrExpected = 193,
        ERR_PtrIndexSingle = 196,
        WRN_ByRefNonAgileField = 197,
        ERR_AssgReadonlyStatic = 198,
        ERR_RefReadonlyStatic = 199,
        ERR_AssgReadonlyProp = 200,
        ERR_IllegalStatement = 201,
        ERR_BadGetEnumerator = 202,
        ERR_TooManyLocals = 204,
        ERR_AbstractBaseCall = 205,
        ERR_RefProperty = 206,
        WRN_OldWarning_UnsafeProp = 207,
        ERR_ManagedAddr = 208,
        ERR_BadFixedInitType = 209,
        ERR_FixedMustInit = 210,
        ERR_InvalidAddrOp = 211,
        ERR_FixedNeeded = 212,
        ERR_FixedNotNeeded = 213,
        ERR_UnsafeNeeded = 214,
        ERR_OpTFRetType = 215,
        ERR_OperatorNeedsMatch = 216,
        ERR_BadBoolOp = 217,
        ERR_MustHaveOpTF = 218,
        WRN_UnreferencedVarAssg = 219,
        ERR_CheckedOverflow = 220,
        ERR_ConstOutOfRangeChecked = 221,
        ERR_BadVarargs = 224,
        ERR_ParamsMustBeArray = 225,
        ERR_IllegalArglist = 226,
        ERR_IllegalUnsafe = 227,
        ERR_AmbigMember = 229,
        ERR_BadForeachDecl = 230,
        ERR_ParamsLast = 231,
        ERR_SizeofUnsafe = 233,
        ERR_DottedTypeNameNotFoundInNS = 234,
        ERR_FieldInitRefNonstatic = 236,
        ERR_SealedNonOverride = 238,
        ERR_CantOverrideSealed = 239,
        ERR_VoidError = 242,
        ERR_ConditionalOnOverride = 243,
        ERR_PointerInAsOrIs = 244,
        ERR_CallingFinalizeDeprecated = 245,
        ERR_SingleTypeNameNotFound = 246,
        ERR_NegativeStackAllocSize = 247,
        ERR_NegativeArraySize = 248,
        ERR_OverrideFinalizeDeprecated = 249,
        ERR_CallingBaseFinalizeDeprecated = 250,
        WRN_NegativeArrayIndex = 251,
        WRN_BadRefCompareLeft = 252,
        WRN_BadRefCompareRight = 253,
        ERR_BadCastInFixed = 254,
        ERR_StackallocInCatchFinally = 255,
        ERR_VarargsLast = 257,
        ERR_MissingPartial = 260,
        ERR_PartialTypeKindConflict = 261,
        ERR_PartialModifierConflict = 262,
        ERR_PartialMultipleBases = 263,
        ERR_PartialWrongTypeParams = 264,
        ERR_PartialWrongConstraints = 265,
        ERR_NoImplicitConvCast = 266,
        ERR_PartialMisplaced = 267,
        ERR_ImportedCircularBase = 268,
        ERR_UseDefViolationOut = 269,
        ERR_ArraySizeInDeclaration = 270,
        ERR_InaccessibleGetter = 271,
        ERR_InaccessibleSetter = 272,
        ERR_InvalidPropertyAccessMod = 273,
        ERR_DuplicatePropertyAccessMods = 274,
        ERR_PropertyAccessModInInterface = 275,
        ERR_AccessModMissingAccessor = 276,
        ERR_UnimplementedInterfaceAccessor = 277,
        WRN_PatternIsAmbiguous = 278,
        WRN_PatternStaticOrInaccessible = 279,
        WRN_PatternBadSignature = 280,
        ERR_FriendRefNotEqualToThis = 281,
        WRN_SequentialOnPartialClass = 282,
        ERR_BadConstType = 283,
        ERR_NoNewTyvar = 304,
        ERR_BadArity = 305,
        ERR_BadTypeArgument = 306,
        ERR_TypeArgsNotAllowed = 307,
        ERR_HasNoTypeVars = 308,
        ERR_NewConstraintNotSatisfied = 310,
        ERR_GenericConstraintNotSatisfiedRefType = 311,
        ERR_GenericConstraintNotSatisfiedNullableEnum = 312,
        ERR_GenericConstraintNotSatisfiedNullableInterface = 313,
        ERR_GenericConstraintNotSatisfiedTyVar = 314,
        ERR_GenericConstraintNotSatisfiedValType = 315,
        ERR_DuplicateGeneratedName = 316,
        ERR_GlobalSingleTypeNameNotFound = 400,
        ERR_NewBoundMustBeLast = 401,
        WRN_MainCantBeGeneric = 402,
        ERR_TypeVarCantBeNull = 403,
        ERR_AttributeCantBeGeneric = 404,
        ERR_DuplicateBound = 405,
        ERR_ClassBoundNotFirst = 406,
        ERR_BadRetType = 407,
        ERR_DuplicateConstraintClause = 409,
        ERR_CantInferMethTypeArgs = 411,
        ERR_LocalSameNameAsTypeParam = 412,
        ERR_AsWithTypeVar = 413,
        WRN_UnreferencedFieldAssg = 414,
        ERR_BadIndexerNameAttr = 415,
        ERR_AttrArgWithTypeVars = 416,
        ERR_NewTyvarWithArgs = 417,
        ERR_AbstractSealedStatic = 418,
        WRN_AmbiguousXMLReference = 419,
        WRN_VolatileByRef = 420,
        WRN_IncrSwitchObsolete = 422,
        ERR_ComImportWithImpl = 423,
        ERR_ComImportWithBase = 424,
        ERR_ImplBadConstraints = 425,
        ERR_DottedTypeNameNotFoundInAgg = 426,
        ERR_MethGrpToNonDel = 428,
        WRN_UnreachableExpr = 429,
        ERR_BadExternAlias = 430,
        ERR_ColColWithTypeAlias = 431,
        ERR_AliasNotFound = 432,
        ERR_SameFullNameAggAgg = 433,
        ERR_SameFullNameNsAgg = 434,
        WRN_SameFullNameThisNsAgg = 435,
        WRN_SameFullNameThisAggAgg = 436,
        WRN_SameFullNameThisAggNs = 437,
        ERR_SameFullNameThisAggThisNs = 438,
        ERR_ExternAfterElements = 439,
        WRN_GlobalAliasDefn = 440,
        ERR_SealedStaticClass = 441,
        ERR_PrivateAbstractAccessor = 442,
        ERR_ValueExpected = 443,
        WRN_UnexpectedPredefTypeLoc = 444,
        ERR_UnboxNotLValue = 445,
        ERR_AnonMethGrpInForEach = 446,
        ERR_BadIncDecRetType = 448,
        ERR_RefValBoundMustBeFirst = 449,
        ERR_RefValBoundWithClass = 450,
        ERR_NewBoundWithVal = 451,
        ERR_RefConstraintNotSatisfied = 452,
        ERR_ValConstraintNotSatisfied = 453,
        ERR_CircularConstraint = 454,
        ERR_BaseConstraintConflict = 455,
        ERR_ConWithValCon = 456,
        ERR_AmbigUDConv = 457,
        WRN_AlwaysNull = 458,
        ERR_AddrOnReadOnlyLocal = 459,
        ERR_OverrideWithConstraints = 460,
        ERR_AmbigOverride = 462,
        ERR_DecConstError = 463,
        WRN_CmpAlwaysFalse = 464,
        WRN_FinalizeMethod = 465,
        ERR_ExplicitImplParams = 466,
        WRN_AmbigLookupMeth = 467,
        WRN_GotoCaseShouldConvert = 469,
        ERR_MethodImplementingAccessor = 470,
        WRN_NubExprIsConstBool = 472,
        WRN_ExplicitImplCollision = 473,
        ERR_AbstractHasBody = 500,
        ERR_ConcreteMissingBody = 501,
        ERR_AbstractAndSealed = 502,
        ERR_AbstractNotVirtual = 503,
        ERR_StaticConstant = 504,
        ERR_CantOverrideNonFunction = 505,
        ERR_CantOverrideNonVirtual = 506,
        ERR_CantChangeAccessOnOverride = 507,
        ERR_CantChangeReturnTypeOnOverride = 508,
        ERR_CantDeriveFromSealedType = 509,
        ERR_AbstractInConcreteClass = 513,
        ERR_StaticConstructorWithExplicitConstructorCall = 514,
        ERR_StaticConstructorWithAccessModifiers = 515,
        ERR_RecursiveConstructorCall = 516,
        ERR_ObjectCallingBaseConstructor = 517,
        ERR_PredefinedTypeNotFound = 518,
        ERR_StructWithBaseConstructorCall = 522,
        ERR_StructLayoutCycle = 523,
        ERR_InterfacesCannotContainTypes = 524,
        ERR_InterfacesCantContainFields = 525,
        ERR_InterfacesCantContainConstructors = 526,
        ERR_NonInterfaceInInterfaceList = 527,
        ERR_DuplicateInterfaceInBaseList = 528,
        ERR_CycleInInterfaceInheritance = 529,
        ERR_InterfaceMemberHasBody = 531,
        ERR_HidingAbstractMethod = 533,
        ERR_UnimplementedAbstractMethod = 534,
        ERR_UnimplementedInterfaceMember = 535,
        ERR_ObjectCantHaveBases = 537,
        ERR_ExplicitInterfaceImplementationNotInterface = 538,
        ERR_InterfaceMemberNotFound = 539,
        ERR_ClassDoesntImplementInterface = 540,
        ERR_ExplicitInterfaceImplementationInNonClassOrStruct = 541,
        ERR_MemberNameSameAsType = 542,
        ERR_EnumeratorOverflow = 543,
        ERR_CantOverrideNonProperty = 544,
        ERR_NoGetToOverride = 545,
        ERR_NoSetToOverride = 546,
        ERR_PropertyCantHaveVoidType = 547,
        ERR_PropertyWithNoAccessors = 548,
        ERR_NewVirtualInSealed = 549,
        ERR_ExplicitPropertyAddingAccessor = 550,
        ERR_ExplicitPropertyMissingAccessor = 551,
        ERR_ConversionWithInterface = 552,
        ERR_ConversionWithBase = 553,
        ERR_ConversionWithDerived = 554,
        ERR_IdentityConversion = 555,
        ERR_ConversionNotInvolvingContainedType = 556,
        ERR_DuplicateConversionInClass = 557,
        ERR_OperatorsMustBeStatic = 558,
        ERR_BadIncDecSignature = 559,
        ERR_BadUnaryOperatorSignature = 562,
        ERR_BadBinaryOperatorSignature = 563,
        ERR_BadShiftOperatorSignature = 564,
        ERR_InterfacesCantContainOperators = 567,
        ERR_StructsCantContainDefaultConstructor = 568,
        ERR_CantOverrideBogusMethod = 569,
        ERR_BindToBogus = 570,
        ERR_CantCallSpecialMethod = 571,
        ERR_BadTypeReference = 572,
        ERR_FieldInitializerInStruct = 573,
        ERR_BadDestructorName = 574,
        ERR_OnlyClassesCanContainDestructors = 575,
        ERR_ConflictAliasAndMember = 576,
        ERR_ConditionalOnSpecialMethod = 577,
        ERR_ConditionalMustReturnVoid = 578,
        ERR_DuplicateAttribute = 579,
        ERR_ConditionalOnInterfaceMethod = 582,
        ERR_OperatorCantReturnVoid = 590,
        ERR_InvalidAttributeArgument = 591,
        ERR_AttributeOnBadSymbolType = 592,
        ERR_FloatOverflow = 594,
        ERR_ComImportWithoutUuidAttribute = 596,
        ERR_InvalidNamedArgument = 599,
        ERR_DllImportOnInvalidMethod = 601,
        WRN_FeatureDeprecated = 602,
        ERR_FieldCantBeRefAny = 610,
        ERR_ArrayElementCantBeRefAny = 611,
        WRN_DeprecatedSymbol = 612,
        ERR_NotAnAttributeClass = 616,
        ERR_BadNamedAttributeArgument = 617,
        WRN_DeprecatedSymbolStr = 618,
        ERR_DeprecatedSymbolStr = 619,
        ERR_IndexerCantHaveVoidType = 620,
        ERR_VirtualPrivate = 621,
        ERR_ArrayInitToNonArrayType = 622,
        ERR_ArrayInitInBadPlace = 623,
        ERR_MissingStructOffset = 625,
        WRN_ExternMethodNoImplementation = 626,
        WRN_ProtectedInSealed = 628,
        ERR_InterfaceImplementedByConditional = 629,
        ERR_IllegalRefParam = 631,
        ERR_BadArgumentToAttribute = 633,
        ERR_StructOffsetOnBadStruct = 636,
        ERR_StructOffsetOnBadField = 637,
        ERR_AttributeUsageOnNonAttributeClass = 641,
        WRN_PossibleMistakenNullStatement = 642,
        ERR_DuplicateNamedAttributeArgument = 643,
        ERR_DeriveFromEnumOrValueType = 644,
        ERR_DefaultMemberOnIndexedType = 646,
        ERR_BogusType = 648,
        WRN_UnassignedInternalField = 649,
        ERR_CStyleArray = 650,
        WRN_VacuousIntegralComp = 652,
        ERR_AbstractAttributeClass = 653,
        ERR_BadNamedAttributeArgumentType = 655,
        ERR_MissingPredefinedMember = 656,
        WRN_AttributeLocationOnBadDeclaration = 657,
        WRN_InvalidAttributeLocation = 658,
        WRN_EqualsWithoutGetHashCode = 659,
        WRN_EqualityOpWithoutEquals = 660,
        WRN_EqualityOpWithoutGetHashCode = 661,
        ERR_OutAttrOnRefParam = 662,
        ERR_OverloadRefOut = 663,
        ERR_LiteralDoubleCast = 664,
        WRN_IncorrectBooleanAssg = 665,
        ERR_ProtectedInStruct = 666,
        ERR_InconsistentIndexerNames = 668,
        ERR_ComImportWithUserCtor = 669,
        ERR_FieldCantHaveVoidType = 670,
        WRN_NonObsoleteOverridingObsolete = 672,
        ERR_SystemVoid = 673,
        ERR_ExplicitParamArray = 674,
        WRN_BitwiseOrSignExtend = 675,
        ERR_VolatileStruct = 677,
        ERR_VolatileAndReadonly = 678,
        WRN_OldWarning_ProtectedInternal = 679,
        WRN_OldWarning_AccessibleReadonly = 680,
        ERR_AbstractField = 681,
        ERR_BogusExplicitImpl = 682,
        ERR_ExplicitMethodImplAccessor = 683,
        WRN_CoClassWithoutComImport = 684,
        ERR_ConditionalWithOutParam = 685,
        ERR_AccessorImplementingMethod = 686,
        ERR_AliasQualAsExpression = 687,
        ERR_DerivingFromATyVar = 689,
        ERR_DuplicateTypeParameter = 692,
        WRN_TypeParameterSameAsOuterTypeParameter = 693,
        ERR_TypeVariableSameAsParent = 694,
        ERR_UnifyingInterfaceInstantiations = 695,
        ERR_GenericDerivingFromAttribute = 698,
        ERR_TyVarNotFoundInConstraint = 699,
        ERR_BadBoundType = 701,
        ERR_SpecialTypeAsBound = 702,
        ERR_BadVisBound = 703,
        ERR_LookupInTypeVariable = 704,
        ERR_BadConstraintType = 706,
        ERR_InstanceMemberInStaticClass = 708,
        ERR_StaticBaseClass = 709,
        ERR_ConstructorInStaticClass = 710,
        ERR_DestructorInStaticClass = 711,
        ERR_InstantiatingStaticClass = 712,
        ERR_StaticDerivedFromNonObject = 713,
        ERR_StaticClassInterfaceImpl = 714,
        ERR_OperatorInStaticClass = 715,
        ERR_ConvertToStaticClass = 716,
        ERR_ConstraintIsStaticClass = 717,
        ERR_GenericArgIsStaticClass = 718,
        ERR_ArrayOfStaticClass = 719,
        ERR_IndexerInStaticClass = 720,
        ERR_ParameterIsStaticClass = 721,
        ERR_ReturnTypeIsStaticClass = 722,
        ERR_VarDeclIsStaticClass = 723,
        ERR_BadEmptyThrowInFinally = 724,
        ERR_InvalidSpecifier = 726,
        WRN_AssignmentToLockOrDispose = 728,
        ERR_ForwardedTypeInThisAssembly = 729,
        ERR_ForwardedTypeIsNested = 730,
        ERR_CycleInTypeForwarder = 731,
        ERR_AssemblyNameOnNonModule = 734,
        ERR_InvalidFwdType = 735,
        ERR_CloseUnimplementedInterfaceMemberStatic = 736,
        ERR_CloseUnimplementedInterfaceMemberNotPublic = 737,
        ERR_CloseUnimplementedInterfaceMemberWrongReturnType = 738,
        ERR_DuplicateTypeForwarder = 739,
        ERR_ExpectedSelectOrGroup = 742,
        ERR_ExpectedContextualKeywordOn = 743,
        ERR_ExpectedContextualKeywordEquals = 744,
        ERR_ExpectedContextualKeywordBy = 745,
        ERR_InvalidAnonymousTypeMemberDeclarator = 746,
        ERR_InvalidInitializerElementInitializer = 747,
        ERR_InconsistentLambdaParameterUsage = 748,
        ERR_PartialMethodInvalidModifier = 750,
        ERR_PartialMethodOnlyInPartialClass = 751,
        ERR_PartialMethodCannotHaveOutParameters = 752,
        ERR_PartialMethodOnlyMethods = 753,
        ERR_PartialMethodNotExplicit = 754,
        ERR_PartialMethodExtensionDifference = 755,
        ERR_PartialMethodOnlyOneLatent = 756,
        ERR_PartialMethodOnlyOneActual = 757,
        ERR_PartialMethodParamsDifference = 758,
        ERR_PartialMethodMustHaveLatent = 759,
        ERR_PartialMethodInconsistentConstraints = 761,
        ERR_PartialMethodToDelegate = 762,
        ERR_PartialMethodStaticDifference = 763,
        ERR_PartialMethodUnsafeDifference = 764,
        ERR_PartialMethodInExpressionTree = 765,
        ERR_PartialMethodMustReturnVoid = 766,
        ERR_ExplicitImplCollisionOnRefOut = 767,
        WRN_ObsoleteOverridingNonObsolete = 809,
        WRN_DebugFullNameTooLong = 811,
        ERR_ImplicitlyTypedVariableAssignedBadValue = 815,
        ERR_ImplicitlyTypedVariableWithNoInitializer = 818,
        ERR_ImplicitlyTypedVariableMultipleDeclarator = 819,
        ERR_ImplicitlyTypedVariableAssignedArrayInitializer = 820,
        ERR_ImplicitlyTypedLocalCannotBeFixed = 821,
        ERR_ImplicitlyTypedVariableCannotBeConst = 822,
        WRN_ExternCtorNoImplementation = 824,
        ERR_TypeVarNotFound = 825,
        ERR_ImplicitlyTypedArrayNoBestType = 826,
        ERR_AnonymousTypePropertyAssignedBadValue = 828,
        ERR_ExpressionTreeContainsBaseAccess = 831,
        ERR_ExpressionTreeContainsAssignment = 832,
        ERR_AnonymousTypeDuplicatePropertyName = 833,
        ERR_StatementLambdaToExpressionTree = 834,
        ERR_ExpressionTreeMustHaveDelegate = 835,
        ERR_AnonymousTypeNotAvailable = 836,
        ERR_LambdaInIsAs = 837,
        ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer = 838,
        ERR_MissingArgument = 839,
        ERR_VariableUsedBeforeDeclaration = 841,
        ERR_ExplicitLayoutAndAutoImplementedProperty = 842,
        ERR_UnassignedThisAutoProperty = 843,
        ERR_VariableUsedBeforeDeclarationAndHidesField = 844,
        ERR_ExpressionTreeContainsBadCoalesce = 845,
        ERR_ArrayInitializerExpected = 846,
        ERR_ArrayInitializerIncorrectLength = 847,
        ERR_OverloadRefOutCtor = 851,
        ERR_ExpressionTreeContainsNamedArgument = 853,
        ERR_ExpressionTreeContainsOptionalArgument = 854,
        ERR_ExpressionTreeContainsIndexedProperty = 855,
        ERR_IndexedPropertyRequiresParams = 856,
        ERR_IndexedPropertyMustHaveAllOptionalParams = 857,
        ERR_IdentifierExpected = 1001,
        ERR_SemicolonExpected = 1002,
        ERR_SyntaxError = 1003,
        ERR_DuplicateModifier = 1004,
        ERR_DuplicateAccessor = 1007,
        ERR_IntegralTypeExpected = 1008,
        ERR_IllegalEscape = 1009,
        ERR_NewlineInConst = 1010,
        ERR_EmptyCharConst = 1011,
        ERR_TooManyCharsInConst = 1012,
        ERR_InvalidNumber = 1013,
        ERR_GetOrSetExpected = 1014,
        ERR_ClassTypeExpected = 1015,
        ERR_NamedArgumentExpected = 1016,
        ERR_TooManyCatches = 1017,
        ERR_ThisOrBaseExpected = 1018,
        ERR_OvlUnaryOperatorExpected = 1019,
        ERR_OvlBinaryOperatorExpected = 1020,
        ERR_IntOverflow = 1021,
        ERR_EOFExpected = 1022,
        ERR_BadEmbeddedStmt = 1023,
        ERR_PPDirectiveExpected = 1024,
        ERR_EndOfPPLineExpected = 1025,
        ERR_CloseParenExpected = 1026,
        ERR_EndifDirectiveExpected = 1027,
        ERR_UnexpectedDirective = 1028,
        ERR_ErrorDirective = 1029,
        WRN_WarningDirective = 1030,
        ERR_TypeExpected = 1031,
        ERR_PPDefFollowsToken = 1032,
        ERR_OpenEndedComment = 1035,
        ERR_OvlOperatorExpected = 1037,
        ERR_EndRegionDirectiveExpected = 1038,
        ERR_UnterminatedStringLit = 1039,
        ERR_BadDirectivePlacement = 1040,
        ERR_IdentifierExpectedKW = 1041,
        ERR_SemiOrLBraceExpected = 1043,
        ERR_MultiTypeInDeclaration = 1044,
        ERR_AddOrRemoveExpected = 1055,
        ERR_UnexpectedCharacter = 1056,
        ERR_ProtectedInStatic = 1057,
        WRN_UnreachableGeneralCatch = 1058,
        ERR_IncrementLvalueExpected = 1059,
        WRN_UninitializedField = 1060,
        ERR_NoSuchMemberOrExtension = 1061,
        WRN_DeprecatedCollectionInitAddStr = 1062,
        ERR_DeprecatedCollectionInitAddStr = 1063,
        WRN_DeprecatedCollectionInitAdd = 1064,
        ERR_DefaultValueNotAllowed = 1065,
        WRN_DefaultValueForUnconsumedLocation = 1066,
        ERR_PartialWrongTypeParamsVariance = 1067,
        ERR_GlobalSingleTypeNameNotFoundFwd = 1068,
        ERR_DottedTypeNameNotFoundInNSFwd = 1069,
        ERR_SingleTypeNameNotFoundFwd = 1070,
        WRN_IdentifierOrNumericLiteralExpected = 1072,
        ERR_BadThisParam = 1100,
        ERR_BadRefWithThis = 1101,
        ERR_BadOutWithThis = 1102,
        ERR_BadTypeforThis = 1103,
        ERR_BadParamModThis = 1104,
        ERR_BadExtensionMeth = 1105,
        ERR_BadExtensionAgg = 1106,
        ERR_DupParamMod = 1107,
        ERR_MultiParamMod = 1108,
        ERR_ExtensionMethodsDecl = 1109,
        ERR_ExtensionAttrNotFound = 1110,
        ERR_ExplicitExtension = 1112,
        ERR_ValueTypeExtDelegate = 1113,
        WRN_FeatureDeprecated2 = 1200,
        WRN_FeatureDeprecated3 = 1201,
        WRN_FeatureDeprecated4 = 1202,
        WRN_FeatureDeprecated5 = 1203,
        WRN_OldWarning_FeatureDefaultDeprecated = 1204,
        ERR_BadArgCount = 1501,
        ERR_BadArgType = 1503,
        ERR_NoSourceFile = 1504,
        ERR_CantRefResource = 1507,
        ERR_ResourceNotUnique = 1508,
        ERR_ImportNonAssembly = 1509,
        ERR_RefLvalueExpected = 1510,
        ERR_BaseInStaticMeth = 1511,
        ERR_BaseInBadContext = 1512,
        ERR_RbraceExpected = 1513,
        ERR_LbraceExpected = 1514,
        ERR_InExpected = 1515,
        ERR_InvalidPreprocExpr = 1517,
        ERR_InvalidMemberDecl = 1519,
        ERR_MemberNeedsType = 1520,
        ERR_BadBaseType = 1521,
        WRN_EmptySwitch = 1522,
        ERR_ExpectedEndTry = 1524,
        ERR_InvalidExprTerm = 1525,
        ERR_BadNewExpr = 1526,
        ERR_NoNamespacePrivate = 1527,
        ERR_BadVarDecl = 1528,
        ERR_UsingAfterElements = 1529,
        ERR_BadBinOpArgs = 1534,
        ERR_BadUnOpArgs = 1535,
        ERR_NoVoidParameter = 1536,
        ERR_DuplicateAlias = 1537,
        ERR_BadProtectedAccess = 1540,
        ERR_AddModuleAssembly = 1542,
        ERR_BindToBogusProp2 = 1545,
        ERR_BindToBogusProp1 = 1546,
        ERR_NoVoidHere = 1547,
        ERR_IndexerNeedsParam = 1551,
        ERR_BadArraySyntax = 1552,
        ERR_BadOperatorSyntax = 1553,
        ERR_MainClassNotFound = 1555,
        ERR_MainClassNotClass = 1556,
        ERR_NoMainInClass = 1558,
        ERR_OutputNeedsName = 1562,
        ERR_CantHaveWin32ResAndManifest = 1564,
        ERR_CantHaveWin32ResAndIcon = 1565,
        ERR_CantReadResource = 1566,
        WRN_XMLParseError = 1570,
        WRN_DuplicateParamTag = 1571,
        WRN_UnmatchedParamTag = 1572,
        WRN_MissingParamTag = 1573,
        WRN_BadXMLRef = 1574,
        ERR_BadStackAllocExpr = 1575,
        ERR_InvalidLineNumber = 1576,
        ERR_MissingPPFile = 1578,
        ERR_ForEachMissingMember = 1579,
        WRN_BadXMLRefParamType = 1580,
        WRN_BadXMLRefReturnType = 1581,
        ERR_BadWin32Res = 1583,
        WRN_BadXMLRefSyntax = 1584,
        ERR_BadModifierLocation = 1585,
        ERR_MissingArraySize = 1586,
        WRN_UnprocessedXMLComment = 1587,
        WRN_FailedInclude = 1589,
        WRN_InvalidInclude = 1590,
        WRN_MissingXMLComment = 1591,
        WRN_XMLParseIncludeError = 1592,
        ERR_BadDelArgCount = 1593,
        WRN_OldWarning_MultipleTypeDefs = 1595,
        WRN_OldWarning_DocFileGenAndIncr = 1596,
        ERR_UnexpectedSemicolon = 1597,
        WRN_XMLParserNotFound = 1598,
        ERR_MethodReturnCantBeRefAny = 1599,
        ERR_CompileCancelled = 1600,
        ERR_MethodArgCantBeRefAny = 1601,
        ERR_AssgReadonlyLocal = 1604,
        ERR_RefReadonlyLocal = 1605,
        WRN_ALinkWarn = 1607,
        ERR_CantUseRequiredAttribute = 1608,
        ERR_NoModifiersOnAccessor = 1609,
        WRN_DeleteAutoResFailed = 1610,
        ERR_ParamsCantBeRefOut = 1611,
        ERR_ReturnNotLValue = 1612,
        ERR_MissingCoClass = 1613,
        ERR_AmbigousAttribute = 1614,
        ERR_BadArgExtraRef = 1615,
        WRN_CmdOptionConflictsSource = 1616,
        ERR_BadCompatMode = 1617,
        ERR_DelegateOnConditional = 1618,
        ERR_CantMakeTempFile = 1619,
        ERR_BadArgRef = 1620,
        ERR_YieldInAnonMeth = 1621,
        ERR_ReturnInIterator = 1622,
        ERR_BadIteratorArgType = 1623,
        ERR_BadIteratorReturn = 1624,
        ERR_BadYieldInFinally = 1625,
        ERR_BadYieldInTryOfCatch = 1626,
        ERR_EmptyYield = 1627,
        ERR_AnonDelegateCantUse = 1628,
        ERR_IllegalInnerUnsafe = 1629,
        ERR_BadYieldInCatch = 1631,
        ERR_BadDelegateLeave = 1632,
        WRN_IllegalPragma = 1633,
        WRN_IllegalPPWarning = 1634,
        WRN_BadRestoreNumber = 1635,
        ERR_VarargsIterator = 1636,
        ERR_UnsafeIteratorArgType = 1637,
        ERR_BadCoClassSig = 1639,
        ERR_MultipleIEnumOfT = 1640,
        ERR_FixedDimsRequired = 1641,
        ERR_FixedNotInStruct = 1642,
        ERR_AnonymousReturnExpected = 1643,
        WRN_NonECMAFeature = 1645,
        ERR_ExpectedVerbatimLiteral = 1646,
        ERR_AssgReadonly2 = 1648,
        ERR_RefReadonly2 = 1649,
        ERR_AssgReadonlyStatic2 = 1650,
        ERR_RefReadonlyStatic2 = 1651,
        ERR_AssgReadonlyLocal2Cause = 1654,
        ERR_RefReadonlyLocal2Cause = 1655,
        ERR_AssgReadonlyLocalCause = 1656,
        ERR_RefReadonlyLocalCause = 1657,
        WRN_ErrorOverride = 1658,
        WRN_OldWarning_ReservedIdentifier = 1659,
        ERR_AnonMethToNonDel = 1660,
        ERR_CantConvAnonMethParams = 1661,
        ERR_CantConvAnonMethReturns = 1662,
        ERR_IllegalFixedType = 1663,
        ERR_FixedOverflow = 1664,
        ERR_InvalidFixedArraySize = 1665,
        ERR_FixedBufferNotFixed = 1666,
        ERR_AttributeNotOnAccessor = 1667,
        WRN_InvalidSearchPathDir = 1668,
        ERR_IllegalVarArgs = 1669,
        ERR_IllegalParams = 1670,
        ERR_BadModifiersOnNamespace = 1671,
        ERR_BadPlatformType = 1672,
        ERR_ThisStructNotInAnonMeth = 1673,
        ERR_NoConvToIDisp = 1674,
        ERR_BadParamRef = 1676,
        ERR_BadParamExtraRef = 1677,
        ERR_BadParamType = 1678,
        ERR_BadExternIdentifier = 1679,
        ERR_AliasMissingFile = 1680,
        ERR_GlobalExternAlias = 1681,
        WRN_MissingTypeNested = 1682,
        WRN_MissingTypeInSource = 1683,
        WRN_MissingTypeInAssembly = 1684,
        WRN_MultiplePredefTypes = 1685,
        ERR_LocalCantBeFixedAndHoisted = 1686,
        WRN_TooManyLinesForDebugger = 1687,
        ERR_CantConvAnonMethNoParams = 1688,
        ERR_ConditionalOnNonAttributeClass = 1689,
        WRN_CallOnNonAgileField = 1690,
        WRN_BadWarningNumber = 1691,
        WRN_InvalidNumber = 1692,
        WRN_FileNameTooLong = 1694,
        WRN_IllegalPPChecksum = 1695,
        WRN_EndOfPPLineExpected = 1696,
        WRN_ConflictingChecksum = 1697,
        WRN_AssumedMatchThis = 1698,
        WRN_UseSwitchInsteadOfAttribute = 1699,
        WRN_InvalidAssemblyName = 1700,
        WRN_UnifyReferenceMajMin = 1701,
        WRN_UnifyReferenceBldRev = 1702,
        ERR_DuplicateImport = 1703,
        ERR_DuplicateImportSimple = 1704,
        ERR_AssemblyMatchBadVersion = 1705,
        WRN_DelegateNewMethBind = 1707,
        ERR_FixedNeedsLvalue = 1708,
        WRN_EmptyFileName = 1709,
        WRN_DuplicateTypeParamTag = 1710,
        WRN_UnmatchedTypeParamTag = 1711,
        WRN_MissingTypeParamTag = 1712,
        ERR_CantChangeTypeOnOverride = 1715,
        ERR_DoNotUseFixedBufferAttr = 1716,
        WRN_AssignmentToSelf = 1717,
        WRN_ComparisonToSelf = 1718,
        ERR_CantOpenWin32Res = 1719,
        WRN_DotOnDefault = 1720,
        ERR_NoMultipleInheritance = 1721,
        ERR_BaseClassMustBeFirst = 1722,
        WRN_BadXMLRefTypeVar = 1723,
        ERR_FriendAssemblyBadArgs = 1725,
        ERR_FriendAssemblySNReq = 1726,
        ERR_DelegateOnNullable = 1728,
        ERR_BadCtorArgCount = 1729,
        ERR_GlobalAttributesNotFirst = 1730,
        ERR_ExpressionExpected = 1733,
        WRN_UnmatchedParamRefTag = 1734,
        WRN_UnmatchedTypeParamRefTag = 1735,
        ERR_DefaultValueMustBeConstant = 1736,
        ERR_DefaultValueBeforeRequiredValue = 1737,
        ERR_NamedArgumentSpecificationBeforeFixedArgument = 1738,
        ERR_BadNamedArgument = 1739,
        ERR_DuplicateNamedArgument = 1740,
        ERR_RefOutDefaultValue = 1741,
        ERR_NamedArgumentForArray = 1742,
        ERR_DefaultValueForExtensionParameter = 1743,
        ERR_NamedArgumentUsedInPositional = 1744,
        ERR_DefaultValueUsedWithAttributes = 1745,
        ERR_BadNamedArgumentForDelegateInvoke = 1746,
        ERR_NoPIAAssemblyMissingAttribute = 1747,
        ERR_NoCanonicalView = 1748,
        ERR_NoConversionForDefaultParam = 1750,
        ERR_DefaultValueForParamsParameter = 1751,
        ERR_NewCoClassOnLink = 1752,
        ERR_NoPIANestedType = 1754,
        ERR_InteropTypeMissingAttribute = 1756,
        ERR_InteropStructContainsMethods = 1757,
        ERR_InteropTypesWithSameNameAndGuid = 1758,
        ERR_NoPIAAssemblyMissingAttributes = 1759,
        ERR_AssemblySpecifiedForLinkAndRef = 1760,
        ERR_LocalTypeNameClash = 1761,
        WRN_ReferencedAssemblyReferencesLinkedPIA = 1762,
        ERR_NotNullRefDefaultParameter = 1763,
        ERR_FixedLocalInLambda = 1764,
        WRN_TypeNotFoundForNoPIAWarning = 1765,
        ERR_MissingMethodOnSourceInterface = 1766,
        ERR_MissingSourceInterface = 1767,
        ERR_GenericsUsedInNoPIAType = 1768,
        ERR_GenericsUsedAcrossAssemblies = 1769,
        ERR_NoConversionForNubDefaultParam = 1770,
        ERR_InvalidSubsystemVersion = 1773,
        ERR_InteropMethodWithBody = 1774,
        ERR_BadWarningLevel = 1900,
        ERR_BadDebugType = 1902,
        ERR_BadResourceVis = 1906,
        ERR_DefaultValueTypeMustMatch = 1908,
        ERR_DefaultValueBadValueType = 1910,
        ERR_MemberAlreadyInitialized = 1912,
        ERR_MemberCannotBeInitialized = 1913,
        ERR_StaticMemberInObjectInitializer = 1914,
        ERR_ReadonlyValueTypeInObjectInitializer = 1917,
        ERR_ValueTypePropertyInObjectInitializer = 1918,
        ERR_UnsafeTypeInObjectCreation = 1919,
        ERR_EmptyElementInitializer = 1920,
        ERR_InitializerAddHasWrongSignature = 1921,
        ERR_CollectionInitRequiresIEnumerable = 1922,
        ERR_CantOpenWin32Manifest = 1926,
        WRN_CantHaveManifestForModule = 1927,
        ERR_BadExtensionArgTypes = 1928,
        ERR_BadInstanceArgType = 1929,
        ERR_QueryDuplicateRangeVariable = 1930,
        ERR_QueryRangeVariableOverrides = 1931,
        ERR_QueryRangeVariableAssignedBadValue = 1932,
        ERR_QueryNoProviderCastable = 1934,
        ERR_QueryNoProviderStandard = 1935,
        ERR_QueryNoProvider = 1936,
        ERR_QueryOuterKey = 1937,
        ERR_QueryInnerKey = 1938,
        ERR_QueryOutRefRangeVariable = 1939,
        ERR_QueryMultipleProviders = 1940,
        ERR_QueryTypeInferenceFailedMulti = 1941,
        ERR_QueryTypeInferenceFailed = 1942,
        ERR_QueryTypeInferenceFailedSelectMany = 1943,
        ERR_ExpressionTreeContainsPointerOp = 1944,
        ERR_ExpressionTreeContainsAnonymousMethod = 1945,
        ERR_AnonymousMethodToExpressionTree = 1946,
        ERR_QueryRangeVariableReadOnly = 1947,
        ERR_QueryRangeVariableSameAsTypeParam = 1948,
        ERR_TypeVarNotFoundRangeVariable = 1949,
        ERR_BadArgTypesForCollectionAdd = 1950,
        ERR_ByRefParameterInExpressionTree = 1951,
        ERR_VarArgsInExpressionTree = 1952,
        ERR_InitializerAddHasParamModifiers = 1954,
        ERR_NonInvocableMemberCalled = 1955,
        WRN_MultipleRuntimeImplementationMatches = 1956,
        WRN_MultipleRuntimeOverrideMatches = 1957,
        ERR_ObjectOrCollectionInitializerWithDelegateCreation = 1958,
        ERR_InvalidConstantDeclarationType = 1959,
        ERR_IllegalVarianceSyntax = 1960,
        ERR_UnexpectedVariance = 1961,
        ERR_BadDynamicTypeof = 1962,
        ERR_ExpressionTreeContainsDynamicOperation = 1963,
        ERR_BadDynamicConversion = 1964,
        ERR_DeriveFromDynamic = 1965,
        ERR_DeriveFromConstructedDynamic = 1966,
        ERR_DynamicTypeAsBound = 1967,
        ERR_ConstructedDynamicTypeAsBound = 1968,
        ERR_DynamicRequiredTypesMissing = 1969,
        ERR_ExplicitDynamicAttr = 1970,
        ERR_NoDynamicPhantomOnBase = 1971,
        ERR_NoDynamicPhantomOnBaseIndexer = 1972,
        ERR_BadArgTypeDynamicExtension = 1973,
        WRN_DynamicDispatchToConditionalMethod = 1974,
        ERR_NoDynamicPhantomOnBaseCtor = 1975,
        ERR_BadDynamicMethodArgMemgrp = 1976,
        ERR_BadDynamicMethodArgLambda = 1977,
        ERR_BadDynamicMethodArg = 1978,
        ERR_BadDynamicQuery = 1979,
        ERR_DynamicAttributeMissing = 1980,
        WRN_IsDynamicIsConfusing = 1981,
        ERR_DynamicNotAllowedInAttribute = 1982,
        ERR_BadAsyncReturn = 1983,
        ERR_BadAwaitInFinally = 1984,
        ERR_BadAwaitInCatch = 1985,
        ERR_BadAwaitArg = 1986,
        ERR_BadAsyncArgType = 1988,
        ERR_BadAsyncExpressionTree = 1989,
        ERR_WindowsRuntimeTypesMissing = 1990,
        ERR_MixingWinRTEventWithRegular = 1991,
        ERR_BadAwaitWithoutAsync = 1992,
        ERR_MissingAsyncTypes = 1993,
        ERR_BadAsyncLacksBody = 1994,
        ERR_BadAwaitInQuery = 1995,
        ERR_BadAwaitInLock = 1996,
        ERR_TaskRetNoObjectRequired = 1997,
        WRN_AsyncLacksAwaits = 1998,
        ERR_FileNotFound = 2001,
        WRN_FileAlreadyIncluded = 2002,
        ERR_NoFileSpec = 2005,
        ERR_SwitchNeedsString = 2006,
        ERR_BadSwitch = 2007,
        WRN_NoSources = 2008,
        ERR_OpenResponseFile = 2011,
        ERR_CantOpenFileWrite = 2012,
        ERR_BadBaseNumber = 2013,
        WRN_UseNewSwitch = 2014,
        ERR_BinaryFile = 2015,
        FTL_BadCodepage = 2016,
        ERR_NoMainOnDLL = 2017,
        FTL_InvalidTarget = 2019,
        FTL_InputFileNameTooLong = 2021,
        WRN_NoConfigNotOnCommandLine = 2023,
        ERR_InvalidFileAlignment = 2024,
        WRN_DefineIdentifierRequired = 2029,
        FTL_OutputFileExists = 2033,
        ERR_OneAliasPerReference = 2034,
        ERR_SwitchNeedsNumber = 2035,
        ERR_MissingDebugSwitch = 2036,
        ERR_ComRefCallInExpressionTree = 2037,
        WRN_BadUILang = 2038,
        ERR_InvalidFormatForGuidForOption = 2039,
        ERR_MissingGuidForOption = 2040,
        ERR_InvalidOutputName = 2041,
        ERR_InvalidDebugInformationFormat = 2042,
        ERR_LegacyObjectIdSyntax = 2043,
        WRN_CLS_NoVarArgs = 3000,
        WRN_CLS_BadArgType = 3001,
        WRN_CLS_BadReturnType = 3002,
        WRN_CLS_BadFieldPropType = 3003,
        WRN_CLS_BadUnicode = 3004,
        WRN_CLS_BadIdentifierCase = 3005,
        WRN_CLS_OverloadRefOut = 3006,
        WRN_CLS_OverloadUnnamed = 3007,
        WRN_CLS_BadIdentifier = 3008,
        WRN_CLS_BadBase = 3009,
        WRN_CLS_BadInterfaceMember = 3010,
        WRN_CLS_NoAbstractMembers = 3011,
        WRN_CLS_NotOnModules = 3012,
        WRN_CLS_ModuleMissingCLS = 3013,
        WRN_CLS_AssemblyNotCLS = 3014,
        WRN_CLS_BadAttributeType = 3015,
        WRN_CLS_ArrayArgumentToAttribute = 3016,
        WRN_CLS_NotOnModules2 = 3017,
        WRN_CLS_IllegalTrueInFalse = 3018,
        WRN_CLS_MeaninglessOnPrivateType = 3019,
        WRN_CLS_AssemblyNotCLS2 = 3021,
        WRN_CLS_MeaninglessOnParam = 3022,
        WRN_CLS_MeaninglessOnReturn = 3023,
        WRN_CLS_BadTypeVar = 3024,
        WRN_CLS_VolatileField = 3026,
        WRN_CLS_BadInterface = 3027,
        FTL_BadChecksumAlgorithm = 3028,
        ERR_BadAwaitArgIntrinsic = 4001,
        ERR_BadAwaitAsIdentifier = 4003,
        ERR_AwaitInUnsafeContext = 4004,
        ERR_UnsafeAsyncArgType = 4005,
        ERR_VarargsAsync = 4006,
        ERR_ByRefTypeAndAwait = 4007,
        ERR_BadAwaitArgVoidCall = 4008,
        ERR_MainCantBeAsync = 4009,
        ERR_CantConvAsyncAnonFuncReturns = 4010,
        ERR_BadAwaiterPattern = 4011,
        ERR_BadSpecialByRefLocal = 4012,
        ERR_SpecialByRefInLambda = 4013,
        WRN_UnobservedAwaitableExpression = 4014,
        ERR_SynchronizedAsyncMethod = 4015,
        ERR_BadAsyncReturnExpression = 4016,
        ERR_NoConversionForCallerLineNumberParam = 4017,
        ERR_NoConversionForCallerFilePathParam = 4018,
        ERR_NoConversionForCallerMemberNameParam = 4019,
        ERR_BadCallerLineNumberParamWithoutDefaultValue = 4020,
        ERR_BadCallerFilePathParamWithoutDefaultValue = 4021,
        ERR_BadCallerMemberNameParamWithoutDefaultValue = 4022,
        ERR_BadPrefer32OnLib = 4023,
        WRN_CallerLineNumberParamForUnconsumedLocation = 4024,
        WRN_CallerFilePathParamForUnconsumedLocation = 4025,
        WRN_CallerMemberNameParamForUnconsumedLocation = 4026,
        ERR_DoesntImplementAwaitInterface = 4027,
        ERR_BadAwaitArg_NeedSystem = 4028,
        ERR_CantReturnVoid = 4029,
        ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync = 4030,
        ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct = 4031,
        ERR_BadAwaitWithoutAsyncMethod = 4032,
        ERR_BadAwaitWithoutVoidAsyncMethod = 4033,
        ERR_BadAwaitWithoutAsyncLambda = 4034,
        ERR_NoSuchMemberOrExtensionNeedUsing = 4036,
        ERR_NoEntryPoint = 5001,
        ERR_UnexpectedAliasedName = 7000,
        ERR_UnexpectedGenericName = 7002,
        ERR_UnexpectedUnboundGenericName = 7003,
        ERR_GlobalStatement = 7006,
        ERR_BadUsingType = 7007,
        ERR_ReservedAssemblyName = 7008,
        ERR_PPReferenceFollowsToken = 7009,
        ERR_ExpectedPPFile = 7010,
        ERR_ReferenceDirectiveOnlyAllowedInScripts = 7011,
        ERR_NameNotInContextPossibleMissingReference = 7012,
        ERR_MetadataNameTooLong = 7013,
        ERR_AttributesNotAllowed = 7014,
        ERR_ExternAliasNotAllowed = 7015,
        ERR_ConflictingAliasAndDefinition = 7016,
        ERR_GlobalDefinitionOrStatementExpected = 7017,
        ERR_NoScriptsSpecified = 7018,
        ERR_RecursivelyTypedVariable = 7019,
        ERR_ReturnNotAllowedInScript = 7020,
        ERR_NamespaceNotAllowedInScript = 7021,
        WRN_MainIgnored = 7022,
        ERR_StaticInAsOrIs = 7023,
        ERR_InvalidDelegateType = 7024,
        ERR_BadVisEventType = 7025,
        ERR_GlobalAttributesNotAllowed = 7026,
        ERR_PublicKeyFileFailure = 7027,
        ERR_PublicKeyContainerFailure = 7028,
        ERR_FriendRefSigningMismatch = 7029,
        ERR_CannotPassNullForFriendAssembly = 7030,
        ERR_SignButNoPrivateKey = 7032,
        WRN_DelaySignButNoKey = 7033,
        ERR_InvalidVersionFormat = 7034,
        WRN_InvalidVersionFormat = 7035,
        ERR_NoCorrespondingArgument = 7036,
        ERR_ModuleEmitFailure = 7038,
        ERR_ResourceFileNameNotUnique = 7041,
        ERR_DllImportOnGenericMethod = 7042,
        ERR_LibraryMethodNotFound = 7043,
        ERR_LibraryMethodNotUnique = 7044,
        ERR_ParameterNotValidForType = 7045,
        ERR_AttributeParameterRequired1 = 7046,
        ERR_AttributeParameterRequired2 = 7047,
        ERR_SecurityAttributeMissingAction = 7048,
        ERR_SecurityAttributeInvalidAction = 7049,
        ERR_SecurityAttributeInvalidActionAssembly = 7050,
        ERR_SecurityAttributeInvalidActionTypeOrMethod = 7051,
        ERR_PrincipalPermissionInvalidAction = 7052,
        ERR_FeatureNotValidInExpressionTree = 7053,
        ERR_MarshalUnmanagedTypeNotValidForFields = 7054,
        ERR_MarshalUnmanagedTypeOnlyValidForFields = 7055,
        ERR_PermissionSetAttributeInvalidFile = 7056,
        ERR_PermissionSetAttributeFileReadError = 7057,
        ERR_InvalidVersionFormat2 = 7058,
        ERR_InvalidAssemblyCultureForExe = 7059,
        ERR_DuplicateAttributeInNetModule = 7061,
        ERR_CantOpenIcon = 7064,
        ERR_ErrorBuildingWin32Resources = 7065,
        ERR_IteratorInInteractive = 7066,
        ERR_BadAttributeParamDefaultArgument = 7067,
        ERR_MissingTypeInSource = 7068,
        ERR_MissingTypeInAssembly = 7069,
        ERR_SecurityAttributeInvalidTarget = 7070,
        ERR_InvalidAssemblyName = 7071,
        ERR_NoTypeDefFromModule = 7079,
        WRN_CallerFilePathPreferredOverCallerMemberName = 7080,
        WRN_CallerLineNumberPreferredOverCallerMemberName = 7081,
        WRN_CallerLineNumberPreferredOverCallerFilePath = 7082,
        ERR_InvalidDynamicCondition = 7083,
        ERR_WinRtEventPassedByRef = 7084,
        ERR_ByRefReturnUnsupported = 7085,
        ERR_NetModuleNameMismatch = 7086,
        ERR_BadCompilationOption = 7087,
        ERR_BadCompilationOptionValue = 7088,
        ERR_BadAppConfigPath = 7089,
        WRN_AssemblyAttributeFromModuleIsOverridden = 7090,
        ERR_CmdOptionConflictsSource = 7091,
        ERR_FixedBufferTooManyDimensions = 7092,
        ERR_CantReadConfigFile = 7093,
        ERR_BadAwaitInCatchFilter = 7094,
        WRN_FilterIsConstant = 7095,
        ERR_EncNoPIAReference = 7096,
        ERR_EncNoDynamicOperation = 7097,
        ERR_LinkedNetmoduleMetadataMustProvideFullPEImage = 7098,
        ERR_MetadataReferencesNotSupported = 7099,
        ERR_InvalidAssemblyCulture = 7100,
        ERR_EncReferenceToAddedMember = 7101,
        WRN_UnimplementedCommandLineSwitch = 8001,
        WRN_ReferencedAssemblyDoesNotHaveStrongName = 8002,
        ERR_InvalidSignaturePublicKey = 8003,
        ERR_ExportedTypeConflictsWithDeclaration = 8004,
        ERR_ExportedTypesConflict = 8005,
        ERR_ForwardedTypeConflictsWithDeclaration = 8006,
        ERR_ForwardedTypesConflict = 8007,
        ERR_ForwardedTypeConflictsWithExportedType = 8008,
        WRN_RefCultureMismatch = 8009,
        ERR_AgnosticToMachineModule = 8010,
        ERR_ConflictingMachineModule = 8011,
        WRN_ConflictingMachineAssembly = 8012,
        ERR_CryptoHashFailed = 8013,
        ERR_MissingNetModuleReference = 8014,
        ERR_NetModuleNameMustBeUnique = 8015,
        ERR_UnsupportedTransparentIdentifierAccess = 8016,
        ERR_ParamDefaultValueDiffersFromAttribute = 8017,
        WRN_UnqualifiedNestedTypeInCref = 8018,
        HDN_UnusedUsingDirective = 8019,
        HDN_UnusedExternAlias = 8020,
        WRN_NoRuntimeMetadataVersion = 8021,
        ERR_FeatureNotAvailableInVersion1 = 8022,
        ERR_FeatureNotAvailableInVersion2 = 8023,
        ERR_FeatureNotAvailableInVersion3 = 8024,
        ERR_FeatureNotAvailableInVersion4 = 8025,
        ERR_FeatureNotAvailableInVersion5 = 8026,
        ERR_FieldHasMultipleDistinctConstantValues = 8027,
        ERR_ComImportWithInitializers = 8028,
        WRN_PdbLocalNameTooLong = 8029,
        ERR_RetNoObjectRequiredLambda = 8030,
        ERR_TaskRetNoObjectRequiredLambda = 8031,
        WRN_AnalyzerCannotBeCreated = 8032,
        WRN_NoAnalyzerInAssembly = 8033,
        WRN_UnableToLoadAnalyzer = 8034,
        ERR_CantReadRulesetFile = 8035,
        INF_UnableToLoadSomeTypesInAnalyzer = 8040,
        ERR_InitializerOnNonAutoProperty = 8050,
        ERR_AutoPropertyMustHaveGetAccessor = 8051,
        ERR_AutoPropertyInitializerInInterface = 8052,
        ERR_EnumsCantContainDefaultConstructor = 8054,
        ERR_EncodinglessSyntaxTree = 8055,
        ERR_AccessorListAndExpressionBody = 8056,
        ERR_BlockBodyAndExpressionBody = 8057,
        ERR_FeatureNotAvailableInVersion6 = 8059,
        ERR_SwitchFallOut = 8070,
        ERR_NullPropagatingOpInExpressionTree = 8072,
        WRN_NubExprIsConstBool2 = 8073,
        ERR_DictionaryInitializerInExpressionTree = 8074,
        ERR_ParameterlessStructCtorsMustBePublic = 8075,
        ERR_UnclosedExpressionHole = 8076,
        ERR_SingleLineCommentInExpressionHole = 8077,
        ERR_InsufficientStack = 8078,
        ERR_UseDefViolationProperty = 8079,
        ERR_AutoPropertyMustOverrideSet = 8080,
        ERR_ExpressionHasNoName = 8081,
        ERR_SubexpressionNotInNameof = 8082,
        ERR_AliasQualifiedNameNotAnExpression = 8083,
        ERR_NameofMethodGroupWithTypeParameters = 8084,
        ERR_NoAliasHere = 8085,
        ERR_UnescapedCurly = 8086,
        ERR_EscapedCurly = 8087,
        ERR_TrailingWhitespaceInFormatSpecifier = 8088,
        ERR_EmptyFormatSpecifier = 8089,
        ERR_ErrorInReferencedAssembly = 8090,
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class ErrorFacts {
        private static TitleSuffix;
        private static DescriptionSuffix;
        private static helpLinksMap;
        private static categoriesMap;
        private static CreateHelpLinks();
        private static CreateCategoriesMap();
        static GetSeverity(code: ErrorCode): DiagnosticSeverity;
        static GetMessage_1340(code: MessageID, culture: System.Globalization.CultureInfo): string;
        static GetMessage_1431(code: ErrorCode, culture: System.Globalization.CultureInfo): string;
        static GetMessageFormat(code: ErrorCode): LocalizableResourceString;
        static GetTitle(code: ErrorCode): LocalizableResourceString;
        static GetDescription(code: ErrorCode): LocalizableResourceString;
        static GetHelpLink(code: ErrorCode): string;
        static GetCategory(code: ErrorCode): string;
        static GetMessage_1609(id: XmlParseErrorCode, culture: System.Globalization.CultureInfo): string;
        private static resourceManager;
        private static ResourceManager;
        static GetWarningLevel(code: ErrorCode): number;
        static PreventsSuccessfulDelegateConversion_1298(code: ErrorCode): boolean;
        static PreventsSuccessfulDelegateConversion_1946(diagnostics: DiagnosticBag): boolean;
        static PreventsSuccessfulDelegateConversion_1840(diagnostics: System.Collections.Immutable.ImmutableArray<Diagnostic>): boolean;
        static IsWarning(code: ErrorCode): boolean;
        static IsFatal(code: ErrorCode): boolean;
        static IsInfo(code: ErrorCode): boolean;
        static IsHidden(code: ErrorCode): boolean;
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    enum MessageID {
        MessageBase = 1200,
        IDS_SK_METHOD,
        IDS_SK_TYPE,
        IDS_SK_NAMESPACE,
        IDS_SK_FIELD,
        IDS_SK_PROPERTY,
        IDS_SK_UNKNOWN,
        IDS_SK_VARIABLE,
        IDS_SK_EVENT,
        IDS_SK_TYVAR,
        IDS_SK_ALIAS,
        IDS_SK_LABEL,
        IDS_NULL,
        IDS_XMLIGNORED,
        IDS_XMLIGNORED2,
        IDS_XMLFAILEDINCLUDE,
        IDS_XMLBADINCLUDE,
        IDS_XMLNOINCLUDE,
        IDS_XMLMISSINGINCLUDEFILE,
        IDS_XMLMISSINGINCLUDEPATH,
        IDS_GlobalNamespace,
        IDS_FeatureGenerics,
        IDS_FeatureAnonDelegates,
        IDS_FeatureModuleAttrLoc,
        IDS_FeatureGlobalNamespace,
        IDS_FeatureFixedBuffer,
        IDS_FeaturePragma,
        IDS_FOREACHLOCAL,
        IDS_USINGLOCAL,
        IDS_FIXEDLOCAL,
        IDS_FeatureStaticClasses,
        IDS_FeaturePartialTypes,
        IDS_MethodGroup,
        IDS_AnonMethod,
        IDS_FeatureSwitchOnBool,
        IDS_Collection,
        IDS_FeaturePropertyAccessorMods,
        IDS_FeatureExternAlias,
        IDS_FeatureIterators,
        IDS_FeatureDefault,
        IDS_FeatureNullable,
        IDS_Lambda,
        IDS_FeatureImplicitArray,
        IDS_FeatureImplicitLocal,
        IDS_FeatureAnonymousTypes,
        IDS_FeatureAutoImplementedProperties,
        IDS_FeatureObjectInitializer,
        IDS_FeatureCollectionInitializer,
        IDS_FeatureLambda,
        IDS_FeatureQueryExpression,
        IDS_FeatureExtensionMethod,
        IDS_FeaturePartialMethod,
        IDS_FeatureDynamic,
        IDS_FeatureTypeVariance,
        IDS_FeatureNamedArgument,
        IDS_FeatureOptionalParameter,
        IDS_FeatureExceptionFilter,
        IDS_FeatureAutoPropertyInitializer,
        IDS_SK_TYPE_OR_NAMESPACE,
        IDS_Contravariant,
        IDS_Contravariantly,
        IDS_Covariant,
        IDS_Covariantly,
        IDS_Invariantly,
        IDS_FeatureAsync,
        IDS_LIB_ENV,
        IDS_LIB_OPTION,
        IDS_REFERENCEPATH_OPTION,
        IDS_DirectoryDoesNotExist,
        IDS_DirectoryHasInvalidPath,
        IDS_Namespace1,
        IDS_PathList,
        IDS_Text,
        IDS_FeatureNullPropagatingOperator,
        IDS_FeatureExpressionBodiedMethod,
        IDS_FeatureExpressionBodiedProperty,
        IDS_FeatureExpressionBodiedIndexer,
        IDS_FeatureNameof,
        IDS_FeatureDictionaryInitializer,
        IDS_FeatureStructParameterlessConstructors,
        IDS_LogoLine1,
        IDS_LogoLine2,
        IDS_CSCHelp,
        IDS_FeatureUsingStatic,
        IDS_FeatureInterpolatedStrings,
    }
    class LocalizableErrorArgument implements System.IFormattable, IMessageSerializable, IStruct, Object {
        private id;
        ctor_5202(id: MessageID): LocalizableErrorArgument;
        ToString(format?: string, formatProvider?: System.IFormatProvider): string;
        constructor();
    }
    class MessageIDExtensions {
        static Localize(id: MessageID): LocalizableErrorArgument;
        static RequiredVersion(feature: MessageID): LanguageVersion;
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class MessageProvider extends CommonMessageProvider implements Roslyn.Utilities.IObjectWritable, Roslyn.Utilities.IObjectReadable {
        static Instance: MessageProvider;
        ctor_2080(): MessageProvider;
        WriteTo(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
        GetSeverity(code: number): DiagnosticSeverity;
        LoadMessage(code: number, language: System.Globalization.CultureInfo): string;
        GetMessageFormat(code: number): LocalizableString;
        GetDescription(code: number): LocalizableString;
        GetTitle(code: number): LocalizableString;
        GetHelpLink(code: number): string;
        GetCategory(code: number): string;
        CodePrefix: string;
        GetMessagePrefix(id: string, severity: DiagnosticSeverity, isWarningAsError: boolean, culture: System.Globalization.CultureInfo): string;
        GetWarningLevel(code: number): number;
        ErrorCodeType: System.Type;
        ERR_FailedToCreateTempFile: number;
        ERR_NoScriptsSpecified: number;
        ERR_OpenResponseFile: number;
        FTL_InputFileNameTooLong: number;
        ERR_FileNotFound: number;
        ERR_NoSourceFile: number;
        ERR_CantOpenFileWrite: number;
        ERR_OutputWriteFailed: number;
        WRN_NoConfigNotOnCommandLine: number;
        ERR_BinaryFile: number;
        WRN_AnalyzerCannotBeCreated: number;
        WRN_NoAnalyzerInAssembly: number;
        WRN_UnableToLoadAnalyzer: number;
        INF_UnableToLoadSomeTypesInAnalyzer: number;
        ERR_CantReadRulesetFile: number;
        ERR_InvalidDebugInformationFormat: number;
        ERR_InvalidOutputName: number;
        ERR_InvalidFileAlignment: number;
        ERR_InvalidSubsystemVersion: number;
        ERR_MetadataFileNotAssembly: number;
        ERR_MetadataFileNotModule: number;
        ERR_InvalidAssemblyMetadata: number;
        ERR_InvalidModuleMetadata: number;
        ERR_ErrorOpeningAssemblyFile: number;
        ERR_ErrorOpeningModuleFile: number;
        ERR_MetadataFileNotFound: number;
        ERR_MetadataReferencesNotSupported: number;
        ERR_LinkedNetmoduleMetadataMustProvideFullPEImage: number;
        ERR_PublicKeyFileFailure: number;
        ERR_PublicKeyContainerFailure: number;
        ERR_CantReadResource: number;
        ERR_CantOpenWin32Resource: number;
        ERR_CantOpenWin32Manifest: number;
        ERR_CantOpenWin32Icon: number;
        ERR_ErrorBuildingWin32Resource: number;
        ERR_BadWin32Resource: number;
        ERR_ResourceFileNameNotUnique: number;
        ERR_ResourceNotUnique: number;
        ERR_ResourceInModule: number;
        ERR_PermissionSetAttributeFileReadError: number;
        WRN_PdbUsingNameTooLong: number;
        WRN_PdbLocalNameTooLong: number;
        ERR_PdbWritingFailed: number;
        ERR_MetadataNameTooLong: number;
        ERR_EncReferenceToAddedMember: number;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class SyntaxDiagnosticInfo extends DiagnosticInfo {
        Offset: number;
        Width: number;
        ctor_7359(offset: number, width: number, code: ErrorCode, ...args: Object[]): SyntaxDiagnosticInfo;
        ctor_1813(offset: number, width: number, code: ErrorCode): SyntaxDiagnosticInfo;
        ctor_1447(code: ErrorCode, ...args: Object[]): SyntaxDiagnosticInfo;
        ctor_2518(code: ErrorCode): SyntaxDiagnosticInfo;
        WithOffset(offset: number): SyntaxDiagnosticInfo;
        WriteTo(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
        ctor_3320(reader: Roslyn.Utilities.ObjectReader): SyntaxDiagnosticInfo;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    enum XmlParseErrorCode {
        XML_RefUndefinedEntity_1 = 0,
        XML_InvalidCharEntity = 1,
        XML_InvalidUnicodeChar = 2,
        XML_InvalidWhitespace = 3,
        XML_MissingEqualsAttribute = 4,
        XML_StringLiteralNoStartQuote = 5,
        XML_StringLiteralNoEndQuote = 6,
        XML_StringLiteralNonAsciiQuote = 7,
        XML_LessThanInAttributeValue = 8,
        XML_IncorrectComment = 9,
        XML_ElementTypeMatch = 10,
        XML_DuplicateAttribute = 11,
        XML_WhitespaceMissing = 12,
        XML_EndTagNotExpected = 13,
        XML_CDataEndTagNotAllowed = 14,
        XML_EndTagExpected = 15,
        XML_ExpectedIdentifier = 16,
        XML_ExpectedEndOfTag = 17,
        XML_InvalidToken = 18,
        XML_ExpectedEndOfXml = 19,
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class XmlSyntaxDiagnosticInfo extends SyntaxDiagnosticInfo {
        private xmlErrorCode;
        ctor_5460(code: XmlParseErrorCode, ...args: Object[]): XmlSyntaxDiagnosticInfo;
        ctor_8171(offset: number, width: number, code: XmlParseErrorCode, ...args: Object[]): XmlSyntaxDiagnosticInfo;
        WriteTo(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
        ctor_1269(reader: Roslyn.Utilities.ObjectReader): XmlSyntaxDiagnosticInfo;
        GetMessage(formatProvider?: System.IFormatProvider): string;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class GreenStats {
        static NoteGreen(node: GreenNode): void;
        static ItemAdded(): void;
        static ItemCacheable(): void;
        static CacheHit(): void;
        constructor();
    }
    class SyntaxNodeCache {
        private static CacheSizeBits;
        static CacheSize: number;
        private static CacheMask;
        static cache: SyntaxNodeCache.Entry[];
        static AddNode(node: GreenNode, hash: number): void;
        private static CanBeCached_1810(child1);
        private static CanBeCached_1252(child1, child2);
        private static CanBeCached_3507(child1, child2, child3);
        private static ChildInCache(child);
        private static AllChildrenInCache(node);
        static TryGetNode_5499(kind: number, child1: GreenNode, hash: {
            refObj: number;
        }): GreenNode;
        static TryGetNode_1444(kind: number, child1: GreenNode, context: SyntaxFactoryContext, hash: {
            refObj: number;
        }): GreenNode;
        private static TryGetNode_8916(kind, child1, flags, hash);
        static TryGetNode_1376(kind: number, child1: GreenNode, child2: GreenNode, hash: {
            refObj: number;
        }): GreenNode;
        static TryGetNode_2745(kind: number, child1: GreenNode, child2: GreenNode, context: SyntaxFactoryContext, hash: {
            refObj: number;
        }): GreenNode;
        private static TryGetNode_2028(kind, child1, child2, flags, hash);
        static TryGetNode_1765(kind: number, child1: GreenNode, child2: GreenNode, child3: GreenNode, hash: {
            refObj: number;
        }): GreenNode;
        static TryGetNode_1394(kind: number, child1: GreenNode, child2: GreenNode, child3: GreenNode, context: SyntaxFactoryContext, hash: {
            refObj: number;
        }): GreenNode;
        private static TryGetNode_1996(kind, child1, child2, child3, flags, hash);
        private static GetFlags_1397();
        private static GetFlags_1410(context);
        private static GetCacheHash_1225(kind, flags, child1);
        private static GetCacheHash_6622(kind, flags, child1, child2);
        private static GetCacheHash_3104(kind, flags, child1, child2, child3);
        constructor();
    }
    module SyntaxNodeCache {
        class Entry implements IStruct {
            hash: number;
            node: GreenNode;
            ctor_1165(hash: number, node: GreenNode): Entry;
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class CSharpSyntaxNode extends GreenNode {
        private myHash;
        ctor_1907(kind: SyntaxKind): CSharpSyntaxNode;
        ctor_2126(kind: SyntaxKind, fullWidth: number): CSharpSyntaxNode;
        ctor_1475(kind: SyntaxKind, diagnostics: DiagnosticInfo[]): CSharpSyntaxNode;
        ctor_4463(kind: SyntaxKind, diagnostics: DiagnosticInfo[], fullWidth: number): CSharpSyntaxNode;
        ctor_1757(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CSharpSyntaxNode;
        ctor_1733(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[], fullWidth: number): CSharpSyntaxNode;
        ctor_4942(reader: Roslyn.Utilities.ObjectReader): CSharpSyntaxNode;
        Language: string;
        Kind: SyntaxKind;
        KindText: string;
        RawContextualKind: number;
        IsStructuredTrivia: boolean;
        IsDirective: boolean;
        GetHashCode(): number;
        GetSlotOffset(index: number): number;
        ChildNodesAndTokens(): ChildSyntaxList;
        EnumerateNodes(): System.Collections.Generic.IEnumerable<GreenNode>;
        GetFirstToken(): SyntaxToken;
        GetLastToken(): SyntaxToken;
        GetLastNonmissingToken(): SyntaxToken;
        GetLeadingTrivia(): CSharpSyntaxNode;
        GetLeadingTriviaCore(): GreenNode;
        GetTrailingTrivia(): CSharpSyntaxNode;
        GetTrailingTriviaCore(): GreenNode;
        ToString(): string;
        ToFullString(): string;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        ApplyDirectives(stack: DirectiveStack): DirectiveStack;
        GetDirectives_1135(): System.Collections.Generic.IList<DirectiveTriviaSyntax>;
        private static GetDirectives_2035(node, directives);
        protected SetFactoryContext_9638(context: SyntaxFactoryContext): void;
        static SetFactoryContext_4391(flags: GreenNode.NodeFlags, context: SyntaxFactoryContext): GreenNode.NodeFlags;
        Navigator: AbstractSyntaxNavigator;
        CreateList(nodes: System.Collections.Generic.IEnumerable<GreenNode>, alwaysCreateListNode: boolean): GreenNode;
        CreateSeparator<TNode>(element: SyntaxNode): Microsoft.CodeAnalysis.SyntaxToken;
        IsTriviaWithEndOfLine(): boolean;
        private static structuresTable;
        GetStructure(trivia: Microsoft.CodeAnalysis.SyntaxTrivia): SyntaxNode;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class StructuredTriviaSyntax extends CSharpSyntaxNode {
        ctor_1999(kind: SyntaxKind, diagnostics?: DiagnosticInfo[], annotations?: SyntaxAnnotation[]): StructuredTriviaSyntax;
        ctor_1484(reader: Roslyn.Utilities.ObjectReader): StructuredTriviaSyntax;
        private Initialize();
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class DirectiveTriviaSyntax extends StructuredTriviaSyntax {
        ApplyDirectives(stack: DirectiveStack): DirectiveStack;
        ctor_9467(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DirectiveTriviaSyntax;
        ctor_1539(kind: SyntaxKind): DirectiveTriviaSyntax;
        ctor_1258(reader: Roslyn.Utilities.ObjectReader): DirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class ExpressionSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1005(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ExpressionSyntax;
        ctor_7190(kind: SyntaxKind): ExpressionSyntax;
        ctor_1102(reader: Roslyn.Utilities.ObjectReader): ExpressionSyntax;
    }
    class TypeSyntax extends ExpressionSyntax {
        constructor();
        ctor_1049(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeSyntax;
        ctor_2121(kind: SyntaxKind): TypeSyntax;
        ctor_6805(reader: Roslyn.Utilities.ObjectReader): TypeSyntax;
    }
    class MemberDeclarationSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1870(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MemberDeclarationSyntax;
        ctor_9655(kind: SyntaxKind): MemberDeclarationSyntax;
        ctor_3031(reader: Roslyn.Utilities.ObjectReader): MemberDeclarationSyntax;
    }
    class NameSyntax extends TypeSyntax {
        constructor();
        ctor_3444(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NameSyntax;
        ctor_1783(kind: SyntaxKind): NameSyntax;
        ctor_1133(reader: Roslyn.Utilities.ObjectReader): NameSyntax;
    }
    class SimpleNameSyntax extends NameSyntax {
        constructor();
        ctor_1424(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SimpleNameSyntax;
        ctor_3429(kind: SyntaxKind): SimpleNameSyntax;
        ctor_1404(reader: Roslyn.Utilities.ObjectReader): SimpleNameSyntax;
        Identifier: SyntaxToken;
    }
    class IdentifierNameSyntax extends SimpleNameSyntax {
        identifier: SyntaxToken;
        constructor();
        ctor_1875(kind: SyntaxKind, identifier: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IdentifierNameSyntax;
        ctor_3802(kind: SyntaxKind, identifier: SyntaxToken, context: SyntaxFactoryContext): IdentifierNameSyntax;
        ctor_1665(kind: SyntaxKind, identifier: SyntaxToken): IdentifierNameSyntax;
        Identifier: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(identifier: SyntaxToken): IdentifierNameSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2134(reader: Roslyn.Utilities.ObjectReader): IdentifierNameSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class QualifiedNameSyntax extends NameSyntax {
        left: NameSyntax;
        dotToken: SyntaxToken;
        right: SimpleNameSyntax;
        constructor();
        ctor_1516(kind: SyntaxKind, left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QualifiedNameSyntax;
        ctor_7156(kind: SyntaxKind, left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax, context: SyntaxFactoryContext): QualifiedNameSyntax;
        ctor_9191(kind: SyntaxKind, left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax): QualifiedNameSyntax;
        Left: NameSyntax;
        DotToken: SyntaxToken;
        Right: SimpleNameSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax): QualifiedNameSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2446(reader: Roslyn.Utilities.ObjectReader): QualifiedNameSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class GenericNameSyntax extends SimpleNameSyntax {
        identifier: SyntaxToken;
        typeArgumentList: TypeArgumentListSyntax;
        constructor();
        ctor_9310(kind: SyntaxKind, identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): GenericNameSyntax;
        ctor_1555(kind: SyntaxKind, identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax, context: SyntaxFactoryContext): GenericNameSyntax;
        ctor_9369(kind: SyntaxKind, identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax): GenericNameSyntax;
        Identifier: SyntaxToken;
        TypeArgumentList: TypeArgumentListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax): GenericNameSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1546(reader: Roslyn.Utilities.ObjectReader): GenericNameSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class TypeArgumentListSyntax extends CSharpSyntaxNode {
        lessThanToken: SyntaxToken;
        arguments: CSharpSyntaxNode;
        greaterThanToken: SyntaxToken;
        constructor();
        ctor_1878(kind: SyntaxKind, lessThanToken: SyntaxToken, arguments: CSharpSyntaxNode, greaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeArgumentListSyntax;
        ctor_1481(kind: SyntaxKind, lessThanToken: SyntaxToken, arguments: CSharpSyntaxNode, greaterThanToken: SyntaxToken, context: SyntaxFactoryContext): TypeArgumentListSyntax;
        ctor_1421(kind: SyntaxKind, lessThanToken: SyntaxToken, arguments: CSharpSyntaxNode, greaterThanToken: SyntaxToken): TypeArgumentListSyntax;
        LessThanToken: SyntaxToken;
        Arguments: SeparatedSyntaxList<TypeSyntax>;
        GreaterThanToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanToken: SyntaxToken, arguments: SeparatedSyntaxList<TypeSyntax>, greaterThanToken: SyntaxToken): TypeArgumentListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8074(reader: Roslyn.Utilities.ObjectReader): TypeArgumentListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AliasQualifiedNameSyntax extends NameSyntax {
        alias: IdentifierNameSyntax;
        colonColonToken: SyntaxToken;
        name: SimpleNameSyntax;
        constructor();
        ctor_2811(kind: SyntaxKind, alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AliasQualifiedNameSyntax;
        ctor_6279(kind: SyntaxKind, alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax, context: SyntaxFactoryContext): AliasQualifiedNameSyntax;
        ctor_1992(kind: SyntaxKind, alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax): AliasQualifiedNameSyntax;
        Alias: IdentifierNameSyntax;
        ColonColonToken: SyntaxToken;
        Name: SimpleNameSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax): AliasQualifiedNameSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2052(reader: Roslyn.Utilities.ObjectReader): AliasQualifiedNameSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class PredefinedTypeSyntax extends TypeSyntax {
        keyword: SyntaxToken;
        constructor();
        ctor_7418(kind: SyntaxKind, keyword: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PredefinedTypeSyntax;
        ctor_6017(kind: SyntaxKind, keyword: SyntaxToken, context: SyntaxFactoryContext): PredefinedTypeSyntax;
        ctor_4867(kind: SyntaxKind, keyword: SyntaxToken): PredefinedTypeSyntax;
        Keyword: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken): PredefinedTypeSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_7075(reader: Roslyn.Utilities.ObjectReader): PredefinedTypeSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ArrayTypeSyntax extends TypeSyntax {
        elementType: TypeSyntax;
        rankSpecifiers: CSharpSyntaxNode;
        constructor();
        ctor_1849(kind: SyntaxKind, elementType: TypeSyntax, rankSpecifiers: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArrayTypeSyntax;
        ctor_9992(kind: SyntaxKind, elementType: TypeSyntax, rankSpecifiers: CSharpSyntaxNode, context: SyntaxFactoryContext): ArrayTypeSyntax;
        ctor_3609(kind: SyntaxKind, elementType: TypeSyntax, rankSpecifiers: CSharpSyntaxNode): ArrayTypeSyntax;
        ElementType: TypeSyntax;
        RankSpecifiers: SyntaxList<ArrayRankSpecifierSyntax>;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(elementType: TypeSyntax, rankSpecifiers: SyntaxList<ArrayRankSpecifierSyntax>): ArrayTypeSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1768(reader: Roslyn.Utilities.ObjectReader): ArrayTypeSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ArrayRankSpecifierSyntax extends CSharpSyntaxNode {
        openBracketToken: SyntaxToken;
        sizes: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;
        constructor();
        ctor_1933(kind: SyntaxKind, openBracketToken: SyntaxToken, sizes: CSharpSyntaxNode, closeBracketToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArrayRankSpecifierSyntax;
        ctor_1202(kind: SyntaxKind, openBracketToken: SyntaxToken, sizes: CSharpSyntaxNode, closeBracketToken: SyntaxToken, context: SyntaxFactoryContext): ArrayRankSpecifierSyntax;
        ctor_5670(kind: SyntaxKind, openBracketToken: SyntaxToken, sizes: CSharpSyntaxNode, closeBracketToken: SyntaxToken): ArrayRankSpecifierSyntax;
        OpenBracketToken: SyntaxToken;
        Sizes: SeparatedSyntaxList<ExpressionSyntax>;
        CloseBracketToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBracketToken: SyntaxToken, sizes: SeparatedSyntaxList<ExpressionSyntax>, closeBracketToken: SyntaxToken): ArrayRankSpecifierSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_6695(reader: Roslyn.Utilities.ObjectReader): ArrayRankSpecifierSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class PointerTypeSyntax extends TypeSyntax {
        elementType: TypeSyntax;
        asteriskToken: SyntaxToken;
        constructor();
        ctor_7651(kind: SyntaxKind, elementType: TypeSyntax, asteriskToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PointerTypeSyntax;
        ctor_2731(kind: SyntaxKind, elementType: TypeSyntax, asteriskToken: SyntaxToken, context: SyntaxFactoryContext): PointerTypeSyntax;
        ctor_1332(kind: SyntaxKind, elementType: TypeSyntax, asteriskToken: SyntaxToken): PointerTypeSyntax;
        ElementType: TypeSyntax;
        AsteriskToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(elementType: TypeSyntax, asteriskToken: SyntaxToken): PointerTypeSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_5210(reader: Roslyn.Utilities.ObjectReader): PointerTypeSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class NullableTypeSyntax extends TypeSyntax {
        elementType: TypeSyntax;
        questionToken: SyntaxToken;
        constructor();
        ctor_8251(kind: SyntaxKind, elementType: TypeSyntax, questionToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NullableTypeSyntax;
        ctor_1091(kind: SyntaxKind, elementType: TypeSyntax, questionToken: SyntaxToken, context: SyntaxFactoryContext): NullableTypeSyntax;
        ctor_1751(kind: SyntaxKind, elementType: TypeSyntax, questionToken: SyntaxToken): NullableTypeSyntax;
        ElementType: TypeSyntax;
        QuestionToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(elementType: TypeSyntax, questionToken: SyntaxToken): NullableTypeSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1772(reader: Roslyn.Utilities.ObjectReader): NullableTypeSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class OmittedTypeArgumentSyntax extends TypeSyntax {
        omittedTypeArgumentToken: SyntaxToken;
        constructor();
        ctor_1834(kind: SyntaxKind, omittedTypeArgumentToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OmittedTypeArgumentSyntax;
        ctor_1437(kind: SyntaxKind, omittedTypeArgumentToken: SyntaxToken, context: SyntaxFactoryContext): OmittedTypeArgumentSyntax;
        ctor_4471(kind: SyntaxKind, omittedTypeArgumentToken: SyntaxToken): OmittedTypeArgumentSyntax;
        OmittedTypeArgumentToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(omittedTypeArgumentToken: SyntaxToken): OmittedTypeArgumentSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1044(reader: Roslyn.Utilities.ObjectReader): OmittedTypeArgumentSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ParenthesizedExpressionSyntax extends ExpressionSyntax {
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_1550(kind: SyntaxKind, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ParenthesizedExpressionSyntax;
        ctor_6142(kind: SyntaxKind, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): ParenthesizedExpressionSyntax;
        ctor_1449(kind: SyntaxKind, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): ParenthesizedExpressionSyntax;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): ParenthesizedExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8426(reader: Roslyn.Utilities.ObjectReader): ParenthesizedExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class PrefixUnaryExpressionSyntax extends ExpressionSyntax {
        operatorToken: SyntaxToken;
        operand: ExpressionSyntax;
        constructor();
        ctor_1992(kind: SyntaxKind, operatorToken: SyntaxToken, operand: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PrefixUnaryExpressionSyntax;
        ctor_1024(kind: SyntaxKind, operatorToken: SyntaxToken, operand: ExpressionSyntax, context: SyntaxFactoryContext): PrefixUnaryExpressionSyntax;
        ctor_5025(kind: SyntaxKind, operatorToken: SyntaxToken, operand: ExpressionSyntax): PrefixUnaryExpressionSyntax;
        OperatorToken: SyntaxToken;
        Operand: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(operatorToken: SyntaxToken, operand: ExpressionSyntax): PrefixUnaryExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2004(reader: Roslyn.Utilities.ObjectReader): PrefixUnaryExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AwaitExpressionSyntax extends ExpressionSyntax {
        awaitKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        constructor();
        ctor_1657(kind: SyntaxKind, awaitKeyword: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AwaitExpressionSyntax;
        ctor_1535(kind: SyntaxKind, awaitKeyword: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): AwaitExpressionSyntax;
        ctor_1403(kind: SyntaxKind, awaitKeyword: SyntaxToken, expression: ExpressionSyntax): AwaitExpressionSyntax;
        AwaitKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(awaitKeyword: SyntaxToken, expression: ExpressionSyntax): AwaitExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1726(reader: Roslyn.Utilities.ObjectReader): AwaitExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class PostfixUnaryExpressionSyntax extends ExpressionSyntax {
        operand: ExpressionSyntax;
        operatorToken: SyntaxToken;
        constructor();
        ctor_1408(kind: SyntaxKind, operand: ExpressionSyntax, operatorToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PostfixUnaryExpressionSyntax;
        ctor_5196(kind: SyntaxKind, operand: ExpressionSyntax, operatorToken: SyntaxToken, context: SyntaxFactoryContext): PostfixUnaryExpressionSyntax;
        ctor_1442(kind: SyntaxKind, operand: ExpressionSyntax, operatorToken: SyntaxToken): PostfixUnaryExpressionSyntax;
        Operand: ExpressionSyntax;
        OperatorToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(operand: ExpressionSyntax, operatorToken: SyntaxToken): PostfixUnaryExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1944(reader: Roslyn.Utilities.ObjectReader): PostfixUnaryExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class MemberAccessExpressionSyntax extends ExpressionSyntax {
        expression: ExpressionSyntax;
        operatorToken: SyntaxToken;
        name: SimpleNameSyntax;
        constructor();
        ctor_3040(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MemberAccessExpressionSyntax;
        ctor_9206(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax, context: SyntaxFactoryContext): MemberAccessExpressionSyntax;
        ctor_6416(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberAccessExpressionSyntax;
        Expression: ExpressionSyntax;
        OperatorToken: SyntaxToken;
        Name: SimpleNameSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberAccessExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_3517(reader: Roslyn.Utilities.ObjectReader): MemberAccessExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ConditionalAccessExpressionSyntax extends ExpressionSyntax {
        expression: ExpressionSyntax;
        operatorToken: SyntaxToken;
        whenNotNull: ExpressionSyntax;
        constructor();
        ctor_1354(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConditionalAccessExpressionSyntax;
        ctor_8619(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax, context: SyntaxFactoryContext): ConditionalAccessExpressionSyntax;
        ctor_1887(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax): ConditionalAccessExpressionSyntax;
        Expression: ExpressionSyntax;
        OperatorToken: SyntaxToken;
        WhenNotNull: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax): ConditionalAccessExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8522(reader: Roslyn.Utilities.ObjectReader): ConditionalAccessExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class MemberBindingExpressionSyntax extends ExpressionSyntax {
        operatorToken: SyntaxToken;
        name: SimpleNameSyntax;
        constructor();
        ctor_1186(kind: SyntaxKind, operatorToken: SyntaxToken, name: SimpleNameSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MemberBindingExpressionSyntax;
        ctor_1227(kind: SyntaxKind, operatorToken: SyntaxToken, name: SimpleNameSyntax, context: SyntaxFactoryContext): MemberBindingExpressionSyntax;
        ctor_4500(kind: SyntaxKind, operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberBindingExpressionSyntax;
        OperatorToken: SyntaxToken;
        Name: SimpleNameSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberBindingExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1247(reader: Roslyn.Utilities.ObjectReader): MemberBindingExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ElementBindingExpressionSyntax extends ExpressionSyntax {
        argumentList: BracketedArgumentListSyntax;
        constructor();
        ctor_1888(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ElementBindingExpressionSyntax;
        ctor_9693(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax, context: SyntaxFactoryContext): ElementBindingExpressionSyntax;
        ctor_2574(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax): ElementBindingExpressionSyntax;
        ArgumentList: BracketedArgumentListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(argumentList: BracketedArgumentListSyntax): ElementBindingExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_7162(reader: Roslyn.Utilities.ObjectReader): ElementBindingExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ImplicitElementAccessSyntax extends ExpressionSyntax {
        argumentList: BracketedArgumentListSyntax;
        constructor();
        ctor_1984(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ImplicitElementAccessSyntax;
        ctor_2625(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax, context: SyntaxFactoryContext): ImplicitElementAccessSyntax;
        ctor_1156(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax): ImplicitElementAccessSyntax;
        ArgumentList: BracketedArgumentListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(argumentList: BracketedArgumentListSyntax): ImplicitElementAccessSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_4986(reader: Roslyn.Utilities.ObjectReader): ImplicitElementAccessSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BinaryExpressionSyntax extends ExpressionSyntax {
        left: ExpressionSyntax;
        operatorToken: SyntaxToken;
        right: ExpressionSyntax;
        constructor();
        ctor_1255(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BinaryExpressionSyntax;
        ctor_8809(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax, context: SyntaxFactoryContext): BinaryExpressionSyntax;
        ctor_3463(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): BinaryExpressionSyntax;
        Left: ExpressionSyntax;
        OperatorToken: SyntaxToken;
        Right: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): BinaryExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1537(reader: Roslyn.Utilities.ObjectReader): BinaryExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AssignmentExpressionSyntax extends ExpressionSyntax {
        left: ExpressionSyntax;
        operatorToken: SyntaxToken;
        right: ExpressionSyntax;
        constructor();
        ctor_1574(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AssignmentExpressionSyntax;
        ctor_9550(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax, context: SyntaxFactoryContext): AssignmentExpressionSyntax;
        ctor_2044(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): AssignmentExpressionSyntax;
        Left: ExpressionSyntax;
        OperatorToken: SyntaxToken;
        Right: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): AssignmentExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_5472(reader: Roslyn.Utilities.ObjectReader): AssignmentExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ConditionalExpressionSyntax extends ExpressionSyntax {
        condition: ExpressionSyntax;
        questionToken: SyntaxToken;
        whenTrue: ExpressionSyntax;
        colonToken: SyntaxToken;
        whenFalse: ExpressionSyntax;
        constructor();
        ctor_8788(kind: SyntaxKind, condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConditionalExpressionSyntax;
        ctor_3635(kind: SyntaxKind, condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax, context: SyntaxFactoryContext): ConditionalExpressionSyntax;
        ctor_1059(kind: SyntaxKind, condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax): ConditionalExpressionSyntax;
        Condition: ExpressionSyntax;
        QuestionToken: SyntaxToken;
        WhenTrue: ExpressionSyntax;
        ColonToken: SyntaxToken;
        WhenFalse: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax): ConditionalExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_9050(reader: Roslyn.Utilities.ObjectReader): ConditionalExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class InstanceExpressionSyntax extends ExpressionSyntax {
        constructor();
        ctor_1786(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InstanceExpressionSyntax;
        ctor_1876(kind: SyntaxKind): InstanceExpressionSyntax;
        ctor_2457(reader: Roslyn.Utilities.ObjectReader): InstanceExpressionSyntax;
    }
    class ThisExpressionSyntax extends InstanceExpressionSyntax {
        token: SyntaxToken;
        constructor();
        ctor_1800(kind: SyntaxKind, token: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ThisExpressionSyntax;
        ctor_1182(kind: SyntaxKind, token: SyntaxToken, context: SyntaxFactoryContext): ThisExpressionSyntax;
        ctor_1863(kind: SyntaxKind, token: SyntaxToken): ThisExpressionSyntax;
        Token: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(token: SyntaxToken): ThisExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1014(reader: Roslyn.Utilities.ObjectReader): ThisExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BaseExpressionSyntax extends InstanceExpressionSyntax {
        token: SyntaxToken;
        constructor();
        ctor_6977(kind: SyntaxKind, token: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseExpressionSyntax;
        ctor_1808(kind: SyntaxKind, token: SyntaxToken, context: SyntaxFactoryContext): BaseExpressionSyntax;
        ctor_1616(kind: SyntaxKind, token: SyntaxToken): BaseExpressionSyntax;
        Token: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(token: SyntaxToken): BaseExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_6025(reader: Roslyn.Utilities.ObjectReader): BaseExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class LiteralExpressionSyntax extends ExpressionSyntax {
        token: SyntaxToken;
        constructor();
        ctor_1257(kind: SyntaxKind, token: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LiteralExpressionSyntax;
        ctor_2020(kind: SyntaxKind, token: SyntaxToken, context: SyntaxFactoryContext): LiteralExpressionSyntax;
        ctor_1875(kind: SyntaxKind, token: SyntaxToken): LiteralExpressionSyntax;
        Token: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(token: SyntaxToken): LiteralExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_5223(reader: Roslyn.Utilities.ObjectReader): LiteralExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class MakeRefExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_1416(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MakeRefExpressionSyntax;
        ctor_7027(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): MakeRefExpressionSyntax;
        ctor_2439(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): MakeRefExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): MakeRefExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_3915(reader: Roslyn.Utilities.ObjectReader): MakeRefExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class RefTypeExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_7310(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): RefTypeExpressionSyntax;
        ctor_1373(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): RefTypeExpressionSyntax;
        ctor_2137(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): RefTypeExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): RefTypeExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1821(reader: Roslyn.Utilities.ObjectReader): RefTypeExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class RefValueExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        comma: SyntaxToken;
        type: TypeSyntax;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_9480(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): RefValueExpressionSyntax;
        ctor_2244(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): RefValueExpressionSyntax;
        ctor_7980(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): RefValueExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        Comma: SyntaxToken;
        Type: TypeSyntax;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): RefValueExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_9232(reader: Roslyn.Utilities.ObjectReader): RefValueExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class CheckedExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_1085(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CheckedExpressionSyntax;
        ctor_1641(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): CheckedExpressionSyntax;
        ctor_1447(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): CheckedExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): CheckedExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8960(reader: Roslyn.Utilities.ObjectReader): CheckedExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class DefaultExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_1965(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DefaultExpressionSyntax;
        ctor_4943(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): DefaultExpressionSyntax;
        ctor_1190(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): DefaultExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): DefaultExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1731(reader: Roslyn.Utilities.ObjectReader): DefaultExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class TypeOfExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_1350(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeOfExpressionSyntax;
        ctor_1868(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): TypeOfExpressionSyntax;
        ctor_2174(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): TypeOfExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): TypeOfExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1334(reader: Roslyn.Utilities.ObjectReader): TypeOfExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class SizeOfExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_1452(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SizeOfExpressionSyntax;
        ctor_1117(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): SizeOfExpressionSyntax;
        ctor_4244(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): SizeOfExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): SizeOfExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_4010(reader: Roslyn.Utilities.ObjectReader): SizeOfExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class InvocationExpressionSyntax extends ExpressionSyntax {
        expression: ExpressionSyntax;
        argumentList: ArgumentListSyntax;
        constructor();
        ctor_7344(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: ArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InvocationExpressionSyntax;
        ctor_1045(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: ArgumentListSyntax, context: SyntaxFactoryContext): InvocationExpressionSyntax;
        ctor_1650(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax;
        Expression: ExpressionSyntax;
        ArgumentList: ArgumentListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1278(reader: Roslyn.Utilities.ObjectReader): InvocationExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ElementAccessExpressionSyntax extends ExpressionSyntax {
        expression: ExpressionSyntax;
        argumentList: BracketedArgumentListSyntax;
        constructor();
        ctor_1433(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ElementAccessExpressionSyntax;
        ctor_1566(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax, context: SyntaxFactoryContext): ElementAccessExpressionSyntax;
        ctor_1465(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax): ElementAccessExpressionSyntax;
        Expression: ExpressionSyntax;
        ArgumentList: BracketedArgumentListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax): ElementAccessExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1646(reader: Roslyn.Utilities.ObjectReader): ElementAccessExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BaseArgumentListSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1600(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseArgumentListSyntax;
        ctor_1379(kind: SyntaxKind): BaseArgumentListSyntax;
        ctor_2083(reader: Roslyn.Utilities.ObjectReader): BaseArgumentListSyntax;
        Arguments: SeparatedSyntaxList<ArgumentSyntax>;
    }
    class ArgumentListSyntax extends BaseArgumentListSyntax {
        openParenToken: SyntaxToken;
        arguments: CSharpSyntaxNode;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_5553(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArgumentListSyntax;
        ctor_2059(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): ArgumentListSyntax;
        ctor_1509(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken): ArgumentListSyntax;
        OpenParenToken: SyntaxToken;
        Arguments: SeparatedSyntaxList<ArgumentSyntax>;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, arguments: SeparatedSyntaxList<ArgumentSyntax>, closeParenToken: SyntaxToken): ArgumentListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_4325(reader: Roslyn.Utilities.ObjectReader): ArgumentListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BracketedArgumentListSyntax extends BaseArgumentListSyntax {
        openBracketToken: SyntaxToken;
        arguments: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;
        constructor();
        ctor_1038(kind: SyntaxKind, openBracketToken: SyntaxToken, arguments: CSharpSyntaxNode, closeBracketToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BracketedArgumentListSyntax;
        ctor_3403(kind: SyntaxKind, openBracketToken: SyntaxToken, arguments: CSharpSyntaxNode, closeBracketToken: SyntaxToken, context: SyntaxFactoryContext): BracketedArgumentListSyntax;
        ctor_2475(kind: SyntaxKind, openBracketToken: SyntaxToken, arguments: CSharpSyntaxNode, closeBracketToken: SyntaxToken): BracketedArgumentListSyntax;
        OpenBracketToken: SyntaxToken;
        Arguments: SeparatedSyntaxList<ArgumentSyntax>;
        CloseBracketToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBracketToken: SyntaxToken, arguments: SeparatedSyntaxList<ArgumentSyntax>, closeBracketToken: SyntaxToken): BracketedArgumentListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1834(reader: Roslyn.Utilities.ObjectReader): BracketedArgumentListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ArgumentSyntax extends CSharpSyntaxNode {
        nameColon: NameColonSyntax;
        refOrOutKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        constructor();
        ctor_1209(kind: SyntaxKind, nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArgumentSyntax;
        ctor_7053(kind: SyntaxKind, nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): ArgumentSyntax;
        ctor_1629(kind: SyntaxKind, nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax): ArgumentSyntax;
        NameColon: NameColonSyntax;
        RefOrOutKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax): ArgumentSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_6384(reader: Roslyn.Utilities.ObjectReader): ArgumentSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class NameColonSyntax extends CSharpSyntaxNode {
        name: IdentifierNameSyntax;
        colonToken: SyntaxToken;
        constructor();
        ctor_1158(kind: SyntaxKind, name: IdentifierNameSyntax, colonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NameColonSyntax;
        ctor_2966(kind: SyntaxKind, name: IdentifierNameSyntax, colonToken: SyntaxToken, context: SyntaxFactoryContext): NameColonSyntax;
        ctor_5628(kind: SyntaxKind, name: IdentifierNameSyntax, colonToken: SyntaxToken): NameColonSyntax;
        Name: IdentifierNameSyntax;
        ColonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: IdentifierNameSyntax, colonToken: SyntaxToken): NameColonSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1197(reader: Roslyn.Utilities.ObjectReader): NameColonSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class CastExpressionSyntax extends ExpressionSyntax {
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        closeParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        constructor();
        ctor_5677(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CastExpressionSyntax;
        ctor_1718(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): CastExpressionSyntax;
        ctor_1715(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax): CastExpressionSyntax;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        CloseParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax): CastExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8776(reader: Roslyn.Utilities.ObjectReader): CastExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AnonymousMethodExpressionSyntax extends ExpressionSyntax {
        asyncKeyword: SyntaxToken;
        delegateKeyword: SyntaxToken;
        parameterList: ParameterListSyntax;
        block: BlockSyntax;
        constructor();
        ctor_2080(kind: SyntaxKind, asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AnonymousMethodExpressionSyntax;
        ctor_5936(kind: SyntaxKind, asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, context: SyntaxFactoryContext): AnonymousMethodExpressionSyntax;
        ctor_1422(kind: SyntaxKind, asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): AnonymousMethodExpressionSyntax;
        AsyncKeyword: SyntaxToken;
        DelegateKeyword: SyntaxToken;
        ParameterList: ParameterListSyntax;
        Block: BlockSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): AnonymousMethodExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_6799(reader: Roslyn.Utilities.ObjectReader): AnonymousMethodExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class SimpleLambdaExpressionSyntax extends ExpressionSyntax {
        asyncKeyword: SyntaxToken;
        parameter: ParameterSyntax;
        arrowToken: SyntaxToken;
        body: CSharpSyntaxNode;
        constructor();
        ctor_3608(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SimpleLambdaExpressionSyntax;
        ctor_4208(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode, context: SyntaxFactoryContext): SimpleLambdaExpressionSyntax;
        ctor_6581(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): SimpleLambdaExpressionSyntax;
        AsyncKeyword: SyntaxToken;
        Parameter: ParameterSyntax;
        ArrowToken: SyntaxToken;
        Body: CSharpSyntaxNode;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): SimpleLambdaExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_5210(reader: Roslyn.Utilities.ObjectReader): SimpleLambdaExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ParenthesizedLambdaExpressionSyntax extends ExpressionSyntax {
        asyncKeyword: SyntaxToken;
        parameterList: ParameterListSyntax;
        arrowToken: SyntaxToken;
        body: CSharpSyntaxNode;
        constructor();
        ctor_6894(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ParenthesizedLambdaExpressionSyntax;
        ctor_1719(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode, context: SyntaxFactoryContext): ParenthesizedLambdaExpressionSyntax;
        ctor_1888(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): ParenthesizedLambdaExpressionSyntax;
        AsyncKeyword: SyntaxToken;
        ParameterList: ParameterListSyntax;
        ArrowToken: SyntaxToken;
        Body: CSharpSyntaxNode;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): ParenthesizedLambdaExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1193(reader: Roslyn.Utilities.ObjectReader): ParenthesizedLambdaExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class InitializerExpressionSyntax extends ExpressionSyntax {
        openBraceToken: SyntaxToken;
        expressions: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        constructor();
        ctor_1022(kind: SyntaxKind, openBraceToken: SyntaxToken, expressions: CSharpSyntaxNode, closeBraceToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InitializerExpressionSyntax;
        ctor_1546(kind: SyntaxKind, openBraceToken: SyntaxToken, expressions: CSharpSyntaxNode, closeBraceToken: SyntaxToken, context: SyntaxFactoryContext): InitializerExpressionSyntax;
        ctor_8197(kind: SyntaxKind, openBraceToken: SyntaxToken, expressions: CSharpSyntaxNode, closeBraceToken: SyntaxToken): InitializerExpressionSyntax;
        OpenBraceToken: SyntaxToken;
        Expressions: SeparatedSyntaxList<ExpressionSyntax>;
        CloseBraceToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBraceToken: SyntaxToken, expressions: SeparatedSyntaxList<ExpressionSyntax>, closeBraceToken: SyntaxToken): InitializerExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1325(reader: Roslyn.Utilities.ObjectReader): InitializerExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ObjectCreationExpressionSyntax extends ExpressionSyntax {
        newKeyword: SyntaxToken;
        type: TypeSyntax;
        argumentList: ArgumentListSyntax;
        initializer: InitializerExpressionSyntax;
        constructor();
        ctor_1691(kind: SyntaxKind, newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ObjectCreationExpressionSyntax;
        ctor_6392(kind: SyntaxKind, newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax, context: SyntaxFactoryContext): ObjectCreationExpressionSyntax;
        ctor_9625(kind: SyntaxKind, newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax): ObjectCreationExpressionSyntax;
        NewKeyword: SyntaxToken;
        Type: TypeSyntax;
        ArgumentList: ArgumentListSyntax;
        Initializer: InitializerExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax): ObjectCreationExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1028(reader: Roslyn.Utilities.ObjectReader): ObjectCreationExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AnonymousObjectMemberDeclaratorSyntax extends CSharpSyntaxNode {
        nameEquals: NameEqualsSyntax;
        expression: ExpressionSyntax;
        constructor();
        ctor_6386(kind: SyntaxKind, nameEquals: NameEqualsSyntax, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AnonymousObjectMemberDeclaratorSyntax;
        ctor_8617(kind: SyntaxKind, nameEquals: NameEqualsSyntax, expression: ExpressionSyntax, context: SyntaxFactoryContext): AnonymousObjectMemberDeclaratorSyntax;
        ctor_5919(kind: SyntaxKind, nameEquals: NameEqualsSyntax, expression: ExpressionSyntax): AnonymousObjectMemberDeclaratorSyntax;
        NameEquals: NameEqualsSyntax;
        Expression: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(nameEquals: NameEqualsSyntax, expression: ExpressionSyntax): AnonymousObjectMemberDeclaratorSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_5169(reader: Roslyn.Utilities.ObjectReader): AnonymousObjectMemberDeclaratorSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AnonymousObjectCreationExpressionSyntax extends ExpressionSyntax {
        newKeyword: SyntaxToken;
        openBraceToken: SyntaxToken;
        initializers: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        constructor();
        ctor_9039(kind: SyntaxKind, newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: CSharpSyntaxNode, closeBraceToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AnonymousObjectCreationExpressionSyntax;
        ctor_8489(kind: SyntaxKind, newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: CSharpSyntaxNode, closeBraceToken: SyntaxToken, context: SyntaxFactoryContext): AnonymousObjectCreationExpressionSyntax;
        ctor_1877(kind: SyntaxKind, newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: CSharpSyntaxNode, closeBraceToken: SyntaxToken): AnonymousObjectCreationExpressionSyntax;
        NewKeyword: SyntaxToken;
        OpenBraceToken: SyntaxToken;
        Initializers: SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>;
        CloseBraceToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>, closeBraceToken: SyntaxToken): AnonymousObjectCreationExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2376(reader: Roslyn.Utilities.ObjectReader): AnonymousObjectCreationExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ArrayCreationExpressionSyntax extends ExpressionSyntax {
        newKeyword: SyntaxToken;
        type: ArrayTypeSyntax;
        initializer: InitializerExpressionSyntax;
        constructor();
        ctor_9880(kind: SyntaxKind, newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArrayCreationExpressionSyntax;
        ctor_8413(kind: SyntaxKind, newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax, context: SyntaxFactoryContext): ArrayCreationExpressionSyntax;
        ctor_1874(kind: SyntaxKind, newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax): ArrayCreationExpressionSyntax;
        NewKeyword: SyntaxToken;
        Type: ArrayTypeSyntax;
        Initializer: InitializerExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax): ArrayCreationExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1440(reader: Roslyn.Utilities.ObjectReader): ArrayCreationExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ImplicitArrayCreationExpressionSyntax extends ExpressionSyntax {
        newKeyword: SyntaxToken;
        openBracketToken: SyntaxToken;
        commas: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;
        initializer: InitializerExpressionSyntax;
        constructor();
        ctor_4848(kind: SyntaxKind, newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: CSharpSyntaxNode, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ImplicitArrayCreationExpressionSyntax;
        ctor_2068(kind: SyntaxKind, newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: CSharpSyntaxNode, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax, context: SyntaxFactoryContext): ImplicitArrayCreationExpressionSyntax;
        ctor_1986(kind: SyntaxKind, newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: CSharpSyntaxNode, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax): ImplicitArrayCreationExpressionSyntax;
        NewKeyword: SyntaxToken;
        OpenBracketToken: SyntaxToken;
        Commas: SyntaxList<SyntaxToken>;
        CloseBracketToken: SyntaxToken;
        Initializer: InitializerExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: SyntaxList<SyntaxToken>, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax): ImplicitArrayCreationExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_9483(reader: Roslyn.Utilities.ObjectReader): ImplicitArrayCreationExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class StackAllocArrayCreationExpressionSyntax extends ExpressionSyntax {
        stackAllocKeyword: SyntaxToken;
        type: TypeSyntax;
        constructor();
        ctor_3935(kind: SyntaxKind, stackAllocKeyword: SyntaxToken, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): StackAllocArrayCreationExpressionSyntax;
        ctor_7608(kind: SyntaxKind, stackAllocKeyword: SyntaxToken, type: TypeSyntax, context: SyntaxFactoryContext): StackAllocArrayCreationExpressionSyntax;
        ctor_4738(kind: SyntaxKind, stackAllocKeyword: SyntaxToken, type: TypeSyntax): StackAllocArrayCreationExpressionSyntax;
        StackAllocKeyword: SyntaxToken;
        Type: TypeSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(stackAllocKeyword: SyntaxToken, type: TypeSyntax): StackAllocArrayCreationExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1294(reader: Roslyn.Utilities.ObjectReader): StackAllocArrayCreationExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class QueryClauseSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1932(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QueryClauseSyntax;
        ctor_1564(kind: SyntaxKind): QueryClauseSyntax;
        ctor_1866(reader: Roslyn.Utilities.ObjectReader): QueryClauseSyntax;
    }
    class SelectOrGroupClauseSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_7482(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SelectOrGroupClauseSyntax;
        ctor_1930(kind: SyntaxKind): SelectOrGroupClauseSyntax;
        ctor_3529(reader: Roslyn.Utilities.ObjectReader): SelectOrGroupClauseSyntax;
    }
    class QueryExpressionSyntax extends ExpressionSyntax {
        fromClause: FromClauseSyntax;
        body: QueryBodySyntax;
        constructor();
        ctor_3053(kind: SyntaxKind, fromClause: FromClauseSyntax, body: QueryBodySyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QueryExpressionSyntax;
        ctor_5301(kind: SyntaxKind, fromClause: FromClauseSyntax, body: QueryBodySyntax, context: SyntaxFactoryContext): QueryExpressionSyntax;
        ctor_2030(kind: SyntaxKind, fromClause: FromClauseSyntax, body: QueryBodySyntax): QueryExpressionSyntax;
        FromClause: FromClauseSyntax;
        Body: QueryBodySyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(fromClause: FromClauseSyntax, body: QueryBodySyntax): QueryExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_3825(reader: Roslyn.Utilities.ObjectReader): QueryExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class QueryBodySyntax extends CSharpSyntaxNode {
        clauses: CSharpSyntaxNode;
        selectOrGroup: SelectOrGroupClauseSyntax;
        continuation: QueryContinuationSyntax;
        constructor();
        ctor_7438(kind: SyntaxKind, clauses: CSharpSyntaxNode, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QueryBodySyntax;
        ctor_7581(kind: SyntaxKind, clauses: CSharpSyntaxNode, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax, context: SyntaxFactoryContext): QueryBodySyntax;
        ctor_1652(kind: SyntaxKind, clauses: CSharpSyntaxNode, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax): QueryBodySyntax;
        Clauses: SyntaxList<QueryClauseSyntax>;
        SelectOrGroup: SelectOrGroupClauseSyntax;
        Continuation: QueryContinuationSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(clauses: SyntaxList<QueryClauseSyntax>, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax): QueryBodySyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2679(reader: Roslyn.Utilities.ObjectReader): QueryBodySyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class FromClauseSyntax extends QueryClauseSyntax {
        fromKeyword: SyntaxToken;
        type: TypeSyntax;
        identifier: SyntaxToken;
        inKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        constructor();
        ctor_3554(kind: SyntaxKind, fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): FromClauseSyntax;
        ctor_1976(kind: SyntaxKind, fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): FromClauseSyntax;
        ctor_1051(kind: SyntaxKind, fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax): FromClauseSyntax;
        FromKeyword: SyntaxToken;
        Type: TypeSyntax;
        Identifier: SyntaxToken;
        InKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax): FromClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1931(reader: Roslyn.Utilities.ObjectReader): FromClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class LetClauseSyntax extends QueryClauseSyntax {
        letKeyword: SyntaxToken;
        identifier: SyntaxToken;
        equalsToken: SyntaxToken;
        expression: ExpressionSyntax;
        constructor();
        ctor_1276(kind: SyntaxKind, letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LetClauseSyntax;
        ctor_2126_C(kind: SyntaxKind, letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): LetClauseSyntax;
        ctor_1414(kind: SyntaxKind, letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax): LetClauseSyntax;
        LetKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        EqualsToken: SyntaxToken;
        Expression: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax): LetClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_9915(reader: Roslyn.Utilities.ObjectReader): LetClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class JoinClauseSyntax extends QueryClauseSyntax {
        joinKeyword: SyntaxToken;
        type: TypeSyntax;
        identifier: SyntaxToken;
        inKeyword: SyntaxToken;
        inExpression: ExpressionSyntax;
        onKeyword: SyntaxToken;
        leftExpression: ExpressionSyntax;
        equalsKeyword: SyntaxToken;
        rightExpression: ExpressionSyntax;
        into: JoinIntoClauseSyntax;
        constructor();
        ctor_8701(kind: SyntaxKind, joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): JoinClauseSyntax;
        ctor_1488(kind: SyntaxKind, joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax, context: SyntaxFactoryContext): JoinClauseSyntax;
        ctor_8909(kind: SyntaxKind, joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax): JoinClauseSyntax;
        JoinKeyword: SyntaxToken;
        Type: TypeSyntax;
        Identifier: SyntaxToken;
        InKeyword: SyntaxToken;
        InExpression: ExpressionSyntax;
        OnKeyword: SyntaxToken;
        LeftExpression: ExpressionSyntax;
        EqualsKeyword: SyntaxToken;
        RightExpression: ExpressionSyntax;
        Into: JoinIntoClauseSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax): JoinClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1603(reader: Roslyn.Utilities.ObjectReader): JoinClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class JoinIntoClauseSyntax extends CSharpSyntaxNode {
        intoKeyword: SyntaxToken;
        identifier: SyntaxToken;
        constructor();
        ctor_1709(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): JoinIntoClauseSyntax;
        ctor_1921(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken, context: SyntaxFactoryContext): JoinIntoClauseSyntax;
        ctor_7536(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken): JoinIntoClauseSyntax;
        IntoKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(intoKeyword: SyntaxToken, identifier: SyntaxToken): JoinIntoClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8645(reader: Roslyn.Utilities.ObjectReader): JoinIntoClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class WhereClauseSyntax extends QueryClauseSyntax {
        whereKeyword: SyntaxToken;
        condition: ExpressionSyntax;
        constructor();
        ctor_6935(kind: SyntaxKind, whereKeyword: SyntaxToken, condition: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): WhereClauseSyntax;
        ctor_9416(kind: SyntaxKind, whereKeyword: SyntaxToken, condition: ExpressionSyntax, context: SyntaxFactoryContext): WhereClauseSyntax;
        ctor_4278(kind: SyntaxKind, whereKeyword: SyntaxToken, condition: ExpressionSyntax): WhereClauseSyntax;
        WhereKeyword: SyntaxToken;
        Condition: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(whereKeyword: SyntaxToken, condition: ExpressionSyntax): WhereClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1570(reader: Roslyn.Utilities.ObjectReader): WhereClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class OrderByClauseSyntax extends QueryClauseSyntax {
        orderByKeyword: SyntaxToken;
        orderings: CSharpSyntaxNode;
        constructor();
        ctor_1884(kind: SyntaxKind, orderByKeyword: SyntaxToken, orderings: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OrderByClauseSyntax;
        ctor_6779(kind: SyntaxKind, orderByKeyword: SyntaxToken, orderings: CSharpSyntaxNode, context: SyntaxFactoryContext): OrderByClauseSyntax;
        ctor_1533(kind: SyntaxKind, orderByKeyword: SyntaxToken, orderings: CSharpSyntaxNode): OrderByClauseSyntax;
        OrderByKeyword: SyntaxToken;
        Orderings: SeparatedSyntaxList<OrderingSyntax>;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(orderByKeyword: SyntaxToken, orderings: SeparatedSyntaxList<OrderingSyntax>): OrderByClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1045(reader: Roslyn.Utilities.ObjectReader): OrderByClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class OrderingSyntax extends CSharpSyntaxNode {
        expression: ExpressionSyntax;
        ascendingOrDescendingKeyword: SyntaxToken;
        constructor();
        ctor_6381(kind: SyntaxKind, expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OrderingSyntax;
        ctor_7726(kind: SyntaxKind, expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken, context: SyntaxFactoryContext): OrderingSyntax;
        ctor_1862(kind: SyntaxKind, expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken): OrderingSyntax;
        Expression: ExpressionSyntax;
        AscendingOrDescendingKeyword: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken): OrderingSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2023(reader: Roslyn.Utilities.ObjectReader): OrderingSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class SelectClauseSyntax extends SelectOrGroupClauseSyntax {
        selectKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        constructor();
        ctor_2623(kind: SyntaxKind, selectKeyword: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SelectClauseSyntax;
        ctor_1469(kind: SyntaxKind, selectKeyword: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): SelectClauseSyntax;
        ctor_3738(kind: SyntaxKind, selectKeyword: SyntaxToken, expression: ExpressionSyntax): SelectClauseSyntax;
        SelectKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(selectKeyword: SyntaxToken, expression: ExpressionSyntax): SelectClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_6921(reader: Roslyn.Utilities.ObjectReader): SelectClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class GroupClauseSyntax extends SelectOrGroupClauseSyntax {
        groupKeyword: SyntaxToken;
        groupExpression: ExpressionSyntax;
        byKeyword: SyntaxToken;
        byExpression: ExpressionSyntax;
        constructor();
        ctor_3590(kind: SyntaxKind, groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): GroupClauseSyntax;
        ctor_9376(kind: SyntaxKind, groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax, context: SyntaxFactoryContext): GroupClauseSyntax;
        ctor_7027(kind: SyntaxKind, groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax): GroupClauseSyntax;
        GroupKeyword: SyntaxToken;
        GroupExpression: ExpressionSyntax;
        ByKeyword: SyntaxToken;
        ByExpression: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax): GroupClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_6249(reader: Roslyn.Utilities.ObjectReader): GroupClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class QueryContinuationSyntax extends CSharpSyntaxNode {
        intoKeyword: SyntaxToken;
        identifier: SyntaxToken;
        body: QueryBodySyntax;
        constructor();
        ctor_1957(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QueryContinuationSyntax;
        ctor_5032(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax, context: SyntaxFactoryContext): QueryContinuationSyntax;
        ctor_1004(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax): QueryContinuationSyntax;
        IntoKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        Body: QueryBodySyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax): QueryContinuationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1980(reader: Roslyn.Utilities.ObjectReader): QueryContinuationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class OmittedArraySizeExpressionSyntax extends ExpressionSyntax {
        omittedArraySizeExpressionToken: SyntaxToken;
        constructor();
        ctor_6606(kind: SyntaxKind, omittedArraySizeExpressionToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OmittedArraySizeExpressionSyntax;
        ctor_1827(kind: SyntaxKind, omittedArraySizeExpressionToken: SyntaxToken, context: SyntaxFactoryContext): OmittedArraySizeExpressionSyntax;
        ctor_7988(kind: SyntaxKind, omittedArraySizeExpressionToken: SyntaxToken): OmittedArraySizeExpressionSyntax;
        OmittedArraySizeExpressionToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(omittedArraySizeExpressionToken: SyntaxToken): OmittedArraySizeExpressionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2118(reader: Roslyn.Utilities.ObjectReader): OmittedArraySizeExpressionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class GlobalStatementSyntax extends MemberDeclarationSyntax {
        statement: StatementSyntax;
        constructor();
        ctor_2457(kind: SyntaxKind, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): GlobalStatementSyntax;
        ctor_1585(kind: SyntaxKind, statement: StatementSyntax, context: SyntaxFactoryContext): GlobalStatementSyntax;
        ctor_1329(kind: SyntaxKind, statement: StatementSyntax): GlobalStatementSyntax;
        Statement: StatementSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(statement: StatementSyntax): GlobalStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1383(reader: Roslyn.Utilities.ObjectReader): GlobalStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class StatementSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1815(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): StatementSyntax;
        ctor_9228(kind: SyntaxKind): StatementSyntax;
        ctor_1667(reader: Roslyn.Utilities.ObjectReader): StatementSyntax;
    }
    class BlockSyntax extends StatementSyntax {
        openBraceToken: SyntaxToken;
        statements: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        constructor();
        ctor_1043(kind: SyntaxKind, openBraceToken: SyntaxToken, statements: CSharpSyntaxNode, closeBraceToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BlockSyntax;
        ctor_2029(kind: SyntaxKind, openBraceToken: SyntaxToken, statements: CSharpSyntaxNode, closeBraceToken: SyntaxToken, context: SyntaxFactoryContext): BlockSyntax;
        ctor_6549(kind: SyntaxKind, openBraceToken: SyntaxToken, statements: CSharpSyntaxNode, closeBraceToken: SyntaxToken): BlockSyntax;
        OpenBraceToken: SyntaxToken;
        Statements: SyntaxList<StatementSyntax>;
        CloseBraceToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBraceToken: SyntaxToken, statements: SyntaxList<StatementSyntax>, closeBraceToken: SyntaxToken): BlockSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_4813(reader: Roslyn.Utilities.ObjectReader): BlockSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class LocalDeclarationStatementSyntax extends StatementSyntax {
        modifiers: CSharpSyntaxNode;
        declaration: VariableDeclarationSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1925(kind: SyntaxKind, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LocalDeclarationStatementSyntax;
        ctor_4906(kind: SyntaxKind, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): LocalDeclarationStatementSyntax;
        ctor_1978(kind: SyntaxKind, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): LocalDeclarationStatementSyntax;
        Modifiers: SyntaxList<SyntaxToken>;
        Declaration: VariableDeclarationSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(modifiers: SyntaxList<SyntaxToken>, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): LocalDeclarationStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1933(reader: Roslyn.Utilities.ObjectReader): LocalDeclarationStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class VariableDeclarationSyntax extends CSharpSyntaxNode {
        type: TypeSyntax;
        variables: CSharpSyntaxNode;
        constructor();
        ctor_5501(kind: SyntaxKind, type: TypeSyntax, variables: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): VariableDeclarationSyntax;
        ctor_1234(kind: SyntaxKind, type: TypeSyntax, variables: CSharpSyntaxNode, context: SyntaxFactoryContext): VariableDeclarationSyntax;
        ctor_1870(kind: SyntaxKind, type: TypeSyntax, variables: CSharpSyntaxNode): VariableDeclarationSyntax;
        Type: TypeSyntax;
        Variables: SeparatedSyntaxList<VariableDeclaratorSyntax>;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(type: TypeSyntax, variables: SeparatedSyntaxList<VariableDeclaratorSyntax>): VariableDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1709(reader: Roslyn.Utilities.ObjectReader): VariableDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class VariableDeclaratorSyntax extends CSharpSyntaxNode {
        identifier: SyntaxToken;
        argumentList: BracketedArgumentListSyntax;
        initializer: EqualsValueClauseSyntax;
        constructor();
        ctor_1671(kind: SyntaxKind, identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): VariableDeclaratorSyntax;
        ctor_3449(kind: SyntaxKind, identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax, context: SyntaxFactoryContext): VariableDeclaratorSyntax;
        ctor_4771(kind: SyntaxKind, identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax): VariableDeclaratorSyntax;
        Identifier: SyntaxToken;
        ArgumentList: BracketedArgumentListSyntax;
        Initializer: EqualsValueClauseSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax): VariableDeclaratorSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2045(reader: Roslyn.Utilities.ObjectReader): VariableDeclaratorSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class EqualsValueClauseSyntax extends CSharpSyntaxNode {
        equalsToken: SyntaxToken;
        value: ExpressionSyntax;
        constructor();
        ctor_1858(kind: SyntaxKind, equalsToken: SyntaxToken, value: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EqualsValueClauseSyntax;
        ctor_1366(kind: SyntaxKind, equalsToken: SyntaxToken, value: ExpressionSyntax, context: SyntaxFactoryContext): EqualsValueClauseSyntax;
        ctor_3240(kind: SyntaxKind, equalsToken: SyntaxToken, value: ExpressionSyntax): EqualsValueClauseSyntax;
        EqualsToken: SyntaxToken;
        Value: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(equalsToken: SyntaxToken, value: ExpressionSyntax): EqualsValueClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_7287(reader: Roslyn.Utilities.ObjectReader): EqualsValueClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ExpressionStatementSyntax extends StatementSyntax {
        expression: ExpressionSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1452(kind: SyntaxKind, expression: ExpressionSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ExpressionStatementSyntax;
        ctor_5488(kind: SyntaxKind, expression: ExpressionSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ExpressionStatementSyntax;
        ctor_9739(kind: SyntaxKind, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ExpressionStatementSyntax;
        Expression: ExpressionSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, semicolonToken: SyntaxToken): ExpressionStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1639(reader: Roslyn.Utilities.ObjectReader): ExpressionStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class EmptyStatementSyntax extends StatementSyntax {
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1946(kind: SyntaxKind, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EmptyStatementSyntax;
        ctor_1710(kind: SyntaxKind, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): EmptyStatementSyntax;
        ctor_7923(kind: SyntaxKind, semicolonToken: SyntaxToken): EmptyStatementSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(semicolonToken: SyntaxToken): EmptyStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_5031(reader: Roslyn.Utilities.ObjectReader): EmptyStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class LabeledStatementSyntax extends StatementSyntax {
        identifier: SyntaxToken;
        colonToken: SyntaxToken;
        statement: StatementSyntax;
        constructor();
        ctor_6047(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LabeledStatementSyntax;
        ctor_1249(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): LabeledStatementSyntax;
        ctor_7158(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax): LabeledStatementSyntax;
        Identifier: SyntaxToken;
        ColonToken: SyntaxToken;
        Statement: StatementSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax): LabeledStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1985(reader: Roslyn.Utilities.ObjectReader): LabeledStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class GotoStatementSyntax extends StatementSyntax {
        gotoKeyword: SyntaxToken;
        caseOrDefaultKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1242(kind: SyntaxKind, gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): GotoStatementSyntax;
        ctor_1495(kind: SyntaxKind, gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): GotoStatementSyntax;
        ctor_1284(kind: SyntaxKind, gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): GotoStatementSyntax;
        GotoKeyword: SyntaxToken;
        CaseOrDefaultKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): GotoStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2036(reader: Roslyn.Utilities.ObjectReader): GotoStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BreakStatementSyntax extends StatementSyntax {
        breakKeyword: SyntaxToken;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_4806(kind: SyntaxKind, breakKeyword: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BreakStatementSyntax;
        ctor_2038(kind: SyntaxKind, breakKeyword: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): BreakStatementSyntax;
        ctor_1032(kind: SyntaxKind, breakKeyword: SyntaxToken, semicolonToken: SyntaxToken): BreakStatementSyntax;
        BreakKeyword: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(breakKeyword: SyntaxToken, semicolonToken: SyntaxToken): BreakStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1195(reader: Roslyn.Utilities.ObjectReader): BreakStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ContinueStatementSyntax extends StatementSyntax {
        continueKeyword: SyntaxToken;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1786(kind: SyntaxKind, continueKeyword: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ContinueStatementSyntax;
        ctor_1201(kind: SyntaxKind, continueKeyword: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ContinueStatementSyntax;
        ctor_1547(kind: SyntaxKind, continueKeyword: SyntaxToken, semicolonToken: SyntaxToken): ContinueStatementSyntax;
        ContinueKeyword: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(continueKeyword: SyntaxToken, semicolonToken: SyntaxToken): ContinueStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2051(reader: Roslyn.Utilities.ObjectReader): ContinueStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ReturnStatementSyntax extends StatementSyntax {
        returnKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_4085(kind: SyntaxKind, returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ReturnStatementSyntax;
        ctor_1404(kind: SyntaxKind, returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ReturnStatementSyntax;
        ctor_1068(kind: SyntaxKind, returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ReturnStatementSyntax;
        ReturnKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ReturnStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1602(reader: Roslyn.Utilities.ObjectReader): ReturnStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ThrowStatementSyntax extends StatementSyntax {
        throwKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1664(kind: SyntaxKind, throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ThrowStatementSyntax;
        ctor_1183(kind: SyntaxKind, throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ThrowStatementSyntax;
        ctor_5581(kind: SyntaxKind, throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ThrowStatementSyntax;
        ThrowKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ThrowStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_9419(reader: Roslyn.Utilities.ObjectReader): ThrowStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class YieldStatementSyntax extends StatementSyntax {
        yieldKeyword: SyntaxToken;
        returnOrBreakKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1739(kind: SyntaxKind, yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): YieldStatementSyntax;
        ctor_1922(kind: SyntaxKind, yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): YieldStatementSyntax;
        ctor_1318(kind: SyntaxKind, yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): YieldStatementSyntax;
        YieldKeyword: SyntaxToken;
        ReturnOrBreakKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): YieldStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1256(reader: Roslyn.Utilities.ObjectReader): YieldStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class WhileStatementSyntax extends StatementSyntax {
        whileKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        condition: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;
        constructor();
        ctor_3033(kind: SyntaxKind, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): WhileStatementSyntax;
        ctor_1212(kind: SyntaxKind, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): WhileStatementSyntax;
        ctor_1272(kind: SyntaxKind, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): WhileStatementSyntax;
        WhileKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Condition: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): WhileStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1465(reader: Roslyn.Utilities.ObjectReader): WhileStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class DoStatementSyntax extends StatementSyntax {
        doKeyword: SyntaxToken;
        statement: StatementSyntax;
        whileKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        condition: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1104(kind: SyntaxKind, doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DoStatementSyntax;
        ctor_1155(kind: SyntaxKind, doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): DoStatementSyntax;
        ctor_2075(kind: SyntaxKind, doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken): DoStatementSyntax;
        DoKeyword: SyntaxToken;
        Statement: StatementSyntax;
        WhileKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Condition: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken): DoStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1737(reader: Roslyn.Utilities.ObjectReader): DoStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ForStatementSyntax extends StatementSyntax {
        forKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        declaration: VariableDeclarationSyntax;
        initializers: CSharpSyntaxNode;
        firstSemicolonToken: SyntaxToken;
        condition: ExpressionSyntax;
        secondSemicolonToken: SyntaxToken;
        incrementors: CSharpSyntaxNode;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;
        constructor();
        ctor_1010(kind: SyntaxKind, forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: CSharpSyntaxNode, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: CSharpSyntaxNode, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ForStatementSyntax;
        ctor_2928(kind: SyntaxKind, forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: CSharpSyntaxNode, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: CSharpSyntaxNode, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): ForStatementSyntax;
        ctor_2049(kind: SyntaxKind, forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: CSharpSyntaxNode, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: CSharpSyntaxNode, closeParenToken: SyntaxToken, statement: StatementSyntax): ForStatementSyntax;
        ForKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Declaration: VariableDeclarationSyntax;
        Initializers: SeparatedSyntaxList<ExpressionSyntax>;
        FirstSemicolonToken: SyntaxToken;
        Condition: ExpressionSyntax;
        SecondSemicolonToken: SyntaxToken;
        Incrementors: SeparatedSyntaxList<ExpressionSyntax>;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: SeparatedSyntaxList<ExpressionSyntax>, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: SeparatedSyntaxList<ExpressionSyntax>, closeParenToken: SyntaxToken, statement: StatementSyntax): ForStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_9007(reader: Roslyn.Utilities.ObjectReader): ForStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ForEachStatementSyntax extends StatementSyntax {
        forEachKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        identifier: SyntaxToken;
        inKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;
        constructor();
        ctor_3546(kind: SyntaxKind, forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ForEachStatementSyntax;
        ctor_2084(kind: SyntaxKind, forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): ForEachStatementSyntax;
        ctor_1622(kind: SyntaxKind, forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): ForEachStatementSyntax;
        ForEachKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        Identifier: SyntaxToken;
        InKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): ForEachStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1857(reader: Roslyn.Utilities.ObjectReader): ForEachStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class UsingStatementSyntax extends StatementSyntax {
        usingKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        declaration: VariableDeclarationSyntax;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;
        constructor();
        ctor_6137(kind: SyntaxKind, usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): UsingStatementSyntax;
        ctor_1513(kind: SyntaxKind, usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): UsingStatementSyntax;
        ctor_1678(kind: SyntaxKind, usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): UsingStatementSyntax;
        UsingKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Declaration: VariableDeclarationSyntax;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): UsingStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1016(reader: Roslyn.Utilities.ObjectReader): UsingStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class FixedStatementSyntax extends StatementSyntax {
        fixedKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        declaration: VariableDeclarationSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;
        constructor();
        ctor_1013(kind: SyntaxKind, fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): FixedStatementSyntax;
        ctor_7903(kind: SyntaxKind, fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): FixedStatementSyntax;
        ctor_5060(kind: SyntaxKind, fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): FixedStatementSyntax;
        FixedKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Declaration: VariableDeclarationSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): FixedStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1457(reader: Roslyn.Utilities.ObjectReader): FixedStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class CheckedStatementSyntax extends StatementSyntax {
        keyword: SyntaxToken;
        block: BlockSyntax;
        constructor();
        ctor_9794(kind: SyntaxKind, keyword: SyntaxToken, block: BlockSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CheckedStatementSyntax;
        ctor_9134(kind: SyntaxKind, keyword: SyntaxToken, block: BlockSyntax, context: SyntaxFactoryContext): CheckedStatementSyntax;
        ctor_4162(kind: SyntaxKind, keyword: SyntaxToken, block: BlockSyntax): CheckedStatementSyntax;
        Keyword: SyntaxToken;
        Block: BlockSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, block: BlockSyntax): CheckedStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1120(reader: Roslyn.Utilities.ObjectReader): CheckedStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class UnsafeStatementSyntax extends StatementSyntax {
        unsafeKeyword: SyntaxToken;
        block: BlockSyntax;
        constructor();
        ctor_1702(kind: SyntaxKind, unsafeKeyword: SyntaxToken, block: BlockSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): UnsafeStatementSyntax;
        ctor_1796(kind: SyntaxKind, unsafeKeyword: SyntaxToken, block: BlockSyntax, context: SyntaxFactoryContext): UnsafeStatementSyntax;
        ctor_9552(kind: SyntaxKind, unsafeKeyword: SyntaxToken, block: BlockSyntax): UnsafeStatementSyntax;
        UnsafeKeyword: SyntaxToken;
        Block: BlockSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(unsafeKeyword: SyntaxToken, block: BlockSyntax): UnsafeStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1280(reader: Roslyn.Utilities.ObjectReader): UnsafeStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class LockStatementSyntax extends StatementSyntax {
        lockKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;
        constructor();
        ctor_2094(kind: SyntaxKind, lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LockStatementSyntax;
        ctor_2931(kind: SyntaxKind, lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): LockStatementSyntax;
        ctor_1320(kind: SyntaxKind, lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): LockStatementSyntax;
        LockKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): LockStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1170(reader: Roslyn.Utilities.ObjectReader): LockStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class IfStatementSyntax extends StatementSyntax {
        ifKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        condition: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;
        $else: ElseClauseSyntax;
        constructor();
        ctor_1524(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IfStatementSyntax;
        ctor_2092(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax, context: SyntaxFactoryContext): IfStatementSyntax;
        ctor_7562(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax): IfStatementSyntax;
        IfKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Condition: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        Else: ElseClauseSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax): IfStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1472(reader: Roslyn.Utilities.ObjectReader): IfStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ElseClauseSyntax extends CSharpSyntaxNode {
        elseKeyword: SyntaxToken;
        statement: StatementSyntax;
        constructor();
        ctor_1047(kind: SyntaxKind, elseKeyword: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ElseClauseSyntax;
        ctor_1278(kind: SyntaxKind, elseKeyword: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): ElseClauseSyntax;
        ctor_4115(kind: SyntaxKind, elseKeyword: SyntaxToken, statement: StatementSyntax): ElseClauseSyntax;
        ElseKeyword: SyntaxToken;
        Statement: StatementSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(elseKeyword: SyntaxToken, statement: StatementSyntax): ElseClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_9306(reader: Roslyn.Utilities.ObjectReader): ElseClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class SwitchStatementSyntax extends StatementSyntax {
        switchKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        openBraceToken: SyntaxToken;
        sections: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        constructor();
        ctor_4949(kind: SyntaxKind, switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: CSharpSyntaxNode, closeBraceToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SwitchStatementSyntax;
        ctor_1210(kind: SyntaxKind, switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: CSharpSyntaxNode, closeBraceToken: SyntaxToken, context: SyntaxFactoryContext): SwitchStatementSyntax;
        ctor_4816(kind: SyntaxKind, switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: CSharpSyntaxNode, closeBraceToken: SyntaxToken): SwitchStatementSyntax;
        SwitchKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        OpenBraceToken: SyntaxToken;
        Sections: SyntaxList<SwitchSectionSyntax>;
        CloseBraceToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: SyntaxList<SwitchSectionSyntax>, closeBraceToken: SyntaxToken): SwitchStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2253(reader: Roslyn.Utilities.ObjectReader): SwitchStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class SwitchSectionSyntax extends CSharpSyntaxNode {
        labels: CSharpSyntaxNode;
        statements: CSharpSyntaxNode;
        constructor();
        ctor_6862(kind: SyntaxKind, labels: CSharpSyntaxNode, statements: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SwitchSectionSyntax;
        ctor_5747(kind: SyntaxKind, labels: CSharpSyntaxNode, statements: CSharpSyntaxNode, context: SyntaxFactoryContext): SwitchSectionSyntax;
        ctor_8674(kind: SyntaxKind, labels: CSharpSyntaxNode, statements: CSharpSyntaxNode): SwitchSectionSyntax;
        Labels: SyntaxList<SwitchLabelSyntax>;
        Statements: SyntaxList<StatementSyntax>;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(labels: SyntaxList<SwitchLabelSyntax>, statements: SyntaxList<StatementSyntax>): SwitchSectionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1828(reader: Roslyn.Utilities.ObjectReader): SwitchSectionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class SwitchLabelSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1375(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SwitchLabelSyntax;
        ctor_8342(kind: SyntaxKind): SwitchLabelSyntax;
        ctor_1946(reader: Roslyn.Utilities.ObjectReader): SwitchLabelSyntax;
        Keyword: SyntaxToken;
        ColonToken: SyntaxToken;
    }
    class CaseSwitchLabelSyntax extends SwitchLabelSyntax {
        keyword: SyntaxToken;
        value: ExpressionSyntax;
        colonToken: SyntaxToken;
        constructor();
        ctor_5679(kind: SyntaxKind, keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CaseSwitchLabelSyntax;
        ctor_5189(kind: SyntaxKind, keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken, context: SyntaxFactoryContext): CaseSwitchLabelSyntax;
        ctor_1897(kind: SyntaxKind, keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken): CaseSwitchLabelSyntax;
        Keyword: SyntaxToken;
        Value: ExpressionSyntax;
        ColonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken): CaseSwitchLabelSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_3750(reader: Roslyn.Utilities.ObjectReader): CaseSwitchLabelSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class DefaultSwitchLabelSyntax extends SwitchLabelSyntax {
        keyword: SyntaxToken;
        colonToken: SyntaxToken;
        constructor();
        ctor_1921(kind: SyntaxKind, keyword: SyntaxToken, colonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DefaultSwitchLabelSyntax;
        ctor_6195(kind: SyntaxKind, keyword: SyntaxToken, colonToken: SyntaxToken, context: SyntaxFactoryContext): DefaultSwitchLabelSyntax;
        ctor_8179(kind: SyntaxKind, keyword: SyntaxToken, colonToken: SyntaxToken): DefaultSwitchLabelSyntax;
        Keyword: SyntaxToken;
        ColonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, colonToken: SyntaxToken): DefaultSwitchLabelSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8246(reader: Roslyn.Utilities.ObjectReader): DefaultSwitchLabelSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class TryStatementSyntax extends StatementSyntax {
        tryKeyword: SyntaxToken;
        block: BlockSyntax;
        catches: CSharpSyntaxNode;
        $finally: FinallyClauseSyntax;
        constructor();
        ctor_5843(kind: SyntaxKind, tryKeyword: SyntaxToken, block: BlockSyntax, catches: CSharpSyntaxNode, $finally: FinallyClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TryStatementSyntax;
        ctor_1281(kind: SyntaxKind, tryKeyword: SyntaxToken, block: BlockSyntax, catches: CSharpSyntaxNode, $finally: FinallyClauseSyntax, context: SyntaxFactoryContext): TryStatementSyntax;
        ctor_1395(kind: SyntaxKind, tryKeyword: SyntaxToken, block: BlockSyntax, catches: CSharpSyntaxNode, $finally: FinallyClauseSyntax): TryStatementSyntax;
        TryKeyword: SyntaxToken;
        Block: BlockSyntax;
        Catches: SyntaxList<CatchClauseSyntax>;
        Finally: FinallyClauseSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(tryKeyword: SyntaxToken, block: BlockSyntax, catches: SyntaxList<CatchClauseSyntax>, $finally: FinallyClauseSyntax): TryStatementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8206(reader: Roslyn.Utilities.ObjectReader): TryStatementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class CatchClauseSyntax extends CSharpSyntaxNode {
        catchKeyword: SyntaxToken;
        declaration: CatchDeclarationSyntax;
        filter: CatchFilterClauseSyntax;
        block: BlockSyntax;
        constructor();
        ctor_1699(kind: SyntaxKind, catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CatchClauseSyntax;
        ctor_1246(kind: SyntaxKind, catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax, context: SyntaxFactoryContext): CatchClauseSyntax;
        ctor_1985(kind: SyntaxKind, catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax): CatchClauseSyntax;
        CatchKeyword: SyntaxToken;
        Declaration: CatchDeclarationSyntax;
        Filter: CatchFilterClauseSyntax;
        Block: BlockSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax): CatchClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_5034(reader: Roslyn.Utilities.ObjectReader): CatchClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class CatchDeclarationSyntax extends CSharpSyntaxNode {
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        identifier: SyntaxToken;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_1412(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CatchDeclarationSyntax;
        ctor_8016(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): CatchDeclarationSyntax;
        ctor_2026(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken): CatchDeclarationSyntax;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        Identifier: SyntaxToken;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken): CatchDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_6864(reader: Roslyn.Utilities.ObjectReader): CatchDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class CatchFilterClauseSyntax extends CSharpSyntaxNode {
        ifKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        filterExpression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_2244(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CatchFilterClauseSyntax;
        ctor_2083(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): CatchFilterClauseSyntax;
        ctor_1409(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken): CatchFilterClauseSyntax;
        IfKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        FilterExpression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken): CatchFilterClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2146(reader: Roslyn.Utilities.ObjectReader): CatchFilterClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class FinallyClauseSyntax extends CSharpSyntaxNode {
        finallyKeyword: SyntaxToken;
        block: BlockSyntax;
        constructor();
        ctor_3647(kind: SyntaxKind, finallyKeyword: SyntaxToken, block: BlockSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): FinallyClauseSyntax;
        ctor_1675(kind: SyntaxKind, finallyKeyword: SyntaxToken, block: BlockSyntax, context: SyntaxFactoryContext): FinallyClauseSyntax;
        ctor_1019(kind: SyntaxKind, finallyKeyword: SyntaxToken, block: BlockSyntax): FinallyClauseSyntax;
        FinallyKeyword: SyntaxToken;
        Block: BlockSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(finallyKeyword: SyntaxToken, block: BlockSyntax): FinallyClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1152(reader: Roslyn.Utilities.ObjectReader): FinallyClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class CompilationUnitSyntax extends CSharpSyntaxNode {
        externs: CSharpSyntaxNode;
        usings: CSharpSyntaxNode;
        attributeLists: CSharpSyntaxNode;
        members: CSharpSyntaxNode;
        endOfFileToken: SyntaxToken;
        constructor();
        ctor_2478(kind: SyntaxKind, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, attributeLists: CSharpSyntaxNode, members: CSharpSyntaxNode, endOfFileToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CompilationUnitSyntax;
        ctor_1663(kind: SyntaxKind, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, attributeLists: CSharpSyntaxNode, members: CSharpSyntaxNode, endOfFileToken: SyntaxToken, context: SyntaxFactoryContext): CompilationUnitSyntax;
        ctor_1196(kind: SyntaxKind, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, attributeLists: CSharpSyntaxNode, members: CSharpSyntaxNode, endOfFileToken: SyntaxToken): CompilationUnitSyntax;
        Externs: SyntaxList<ExternAliasDirectiveSyntax>;
        Usings: SyntaxList<UsingDirectiveSyntax>;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Members: SyntaxList<MemberDeclarationSyntax>;
        EndOfFileToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(externs: SyntaxList<ExternAliasDirectiveSyntax>, usings: SyntaxList<UsingDirectiveSyntax>, attributeLists: SyntaxList<AttributeListSyntax>, members: SyntaxList<MemberDeclarationSyntax>, endOfFileToken: SyntaxToken): CompilationUnitSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2631(reader: Roslyn.Utilities.ObjectReader): CompilationUnitSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ExternAliasDirectiveSyntax extends CSharpSyntaxNode {
        externKeyword: SyntaxToken;
        aliasKeyword: SyntaxToken;
        identifier: SyntaxToken;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_5288(kind: SyntaxKind, externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ExternAliasDirectiveSyntax;
        ctor_9386(kind: SyntaxKind, externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ExternAliasDirectiveSyntax;
        ctor_9086(kind: SyntaxKind, externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken): ExternAliasDirectiveSyntax;
        ExternKeyword: SyntaxToken;
        AliasKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken): ExternAliasDirectiveSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1316(reader: Roslyn.Utilities.ObjectReader): ExternAliasDirectiveSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class UsingDirectiveSyntax extends CSharpSyntaxNode {
        usingKeyword: SyntaxToken;
        staticKeyword: SyntaxToken;
        alias: NameEqualsSyntax;
        name: NameSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1096(kind: SyntaxKind, usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): UsingDirectiveSyntax;
        ctor_8988(kind: SyntaxKind, usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): UsingDirectiveSyntax;
        ctor_4334(kind: SyntaxKind, usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken): UsingDirectiveSyntax;
        UsingKeyword: SyntaxToken;
        StaticKeyword: SyntaxToken;
        Alias: NameEqualsSyntax;
        Name: NameSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken): UsingDirectiveSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_7082(reader: Roslyn.Utilities.ObjectReader): UsingDirectiveSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class NamespaceDeclarationSyntax extends MemberDeclarationSyntax {
        namespaceKeyword: SyntaxToken;
        name: NameSyntax;
        openBraceToken: SyntaxToken;
        externs: CSharpSyntaxNode;
        usings: CSharpSyntaxNode;
        members: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_8254(kind: SyntaxKind, namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NamespaceDeclarationSyntax;
        ctor_2049(kind: SyntaxKind, namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): NamespaceDeclarationSyntax;
        ctor_5721(kind: SyntaxKind, namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): NamespaceDeclarationSyntax;
        NamespaceKeyword: SyntaxToken;
        Name: NameSyntax;
        OpenBraceToken: SyntaxToken;
        Externs: SyntaxList<ExternAliasDirectiveSyntax>;
        Usings: SyntaxList<UsingDirectiveSyntax>;
        Members: SyntaxList<MemberDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: SyntaxList<ExternAliasDirectiveSyntax>, usings: SyntaxList<UsingDirectiveSyntax>, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): NamespaceDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1212(reader: Roslyn.Utilities.ObjectReader): NamespaceDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AttributeListSyntax extends CSharpSyntaxNode {
        openBracketToken: SyntaxToken;
        target: AttributeTargetSpecifierSyntax;
        attributes: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;
        constructor();
        ctor_1146(kind: SyntaxKind, openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: CSharpSyntaxNode, closeBracketToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AttributeListSyntax;
        ctor_2120(kind: SyntaxKind, openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: CSharpSyntaxNode, closeBracketToken: SyntaxToken, context: SyntaxFactoryContext): AttributeListSyntax;
        ctor_7159(kind: SyntaxKind, openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: CSharpSyntaxNode, closeBracketToken: SyntaxToken): AttributeListSyntax;
        OpenBracketToken: SyntaxToken;
        Target: AttributeTargetSpecifierSyntax;
        Attributes: SeparatedSyntaxList<AttributeSyntax>;
        CloseBracketToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: SeparatedSyntaxList<AttributeSyntax>, closeBracketToken: SyntaxToken): AttributeListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1570(reader: Roslyn.Utilities.ObjectReader): AttributeListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AttributeTargetSpecifierSyntax extends CSharpSyntaxNode {
        identifier: SyntaxToken;
        colonToken: SyntaxToken;
        constructor();
        ctor_3966(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AttributeTargetSpecifierSyntax;
        ctor_1154(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken, context: SyntaxFactoryContext): AttributeTargetSpecifierSyntax;
        ctor_7732(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken): AttributeTargetSpecifierSyntax;
        Identifier: SyntaxToken;
        ColonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(identifier: SyntaxToken, colonToken: SyntaxToken): AttributeTargetSpecifierSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1078(reader: Roslyn.Utilities.ObjectReader): AttributeTargetSpecifierSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AttributeSyntax extends CSharpSyntaxNode {
        name: NameSyntax;
        argumentList: AttributeArgumentListSyntax;
        constructor();
        ctor_1902(kind: SyntaxKind, name: NameSyntax, argumentList: AttributeArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AttributeSyntax;
        ctor_8644(kind: SyntaxKind, name: NameSyntax, argumentList: AttributeArgumentListSyntax, context: SyntaxFactoryContext): AttributeSyntax;
        ctor_1785(kind: SyntaxKind, name: NameSyntax, argumentList: AttributeArgumentListSyntax): AttributeSyntax;
        Name: NameSyntax;
        ArgumentList: AttributeArgumentListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: NameSyntax, argumentList: AttributeArgumentListSyntax): AttributeSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_4619(reader: Roslyn.Utilities.ObjectReader): AttributeSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AttributeArgumentListSyntax extends CSharpSyntaxNode {
        openParenToken: SyntaxToken;
        arguments: CSharpSyntaxNode;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_6518(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AttributeArgumentListSyntax;
        ctor_1825(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): AttributeArgumentListSyntax;
        ctor_7160(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken): AttributeArgumentListSyntax;
        OpenParenToken: SyntaxToken;
        Arguments: SeparatedSyntaxList<AttributeArgumentSyntax>;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, arguments: SeparatedSyntaxList<AttributeArgumentSyntax>, closeParenToken: SyntaxToken): AttributeArgumentListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1195(reader: Roslyn.Utilities.ObjectReader): AttributeArgumentListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AttributeArgumentSyntax extends CSharpSyntaxNode {
        nameEquals: NameEqualsSyntax;
        nameColon: NameColonSyntax;
        expression: ExpressionSyntax;
        constructor();
        ctor_1391(kind: SyntaxKind, nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AttributeArgumentSyntax;
        ctor_2711(kind: SyntaxKind, nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax, context: SyntaxFactoryContext): AttributeArgumentSyntax;
        ctor_1277(kind: SyntaxKind, nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax): AttributeArgumentSyntax;
        NameEquals: NameEqualsSyntax;
        NameColon: NameColonSyntax;
        Expression: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax): AttributeArgumentSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1998(reader: Roslyn.Utilities.ObjectReader): AttributeArgumentSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class NameEqualsSyntax extends CSharpSyntaxNode {
        name: IdentifierNameSyntax;
        equalsToken: SyntaxToken;
        constructor();
        ctor_8031(kind: SyntaxKind, name: IdentifierNameSyntax, equalsToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NameEqualsSyntax;
        ctor_8701(kind: SyntaxKind, name: IdentifierNameSyntax, equalsToken: SyntaxToken, context: SyntaxFactoryContext): NameEqualsSyntax;
        ctor_1747(kind: SyntaxKind, name: IdentifierNameSyntax, equalsToken: SyntaxToken): NameEqualsSyntax;
        Name: IdentifierNameSyntax;
        EqualsToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: IdentifierNameSyntax, equalsToken: SyntaxToken): NameEqualsSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8818(reader: Roslyn.Utilities.ObjectReader): NameEqualsSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class TypeParameterListSyntax extends CSharpSyntaxNode {
        lessThanToken: SyntaxToken;
        parameters: CSharpSyntaxNode;
        greaterThanToken: SyntaxToken;
        constructor();
        ctor_1188(kind: SyntaxKind, lessThanToken: SyntaxToken, parameters: CSharpSyntaxNode, greaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeParameterListSyntax;
        ctor_1045(kind: SyntaxKind, lessThanToken: SyntaxToken, parameters: CSharpSyntaxNode, greaterThanToken: SyntaxToken, context: SyntaxFactoryContext): TypeParameterListSyntax;
        ctor_1238(kind: SyntaxKind, lessThanToken: SyntaxToken, parameters: CSharpSyntaxNode, greaterThanToken: SyntaxToken): TypeParameterListSyntax;
        LessThanToken: SyntaxToken;
        Parameters: SeparatedSyntaxList<TypeParameterSyntax>;
        GreaterThanToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanToken: SyntaxToken, parameters: SeparatedSyntaxList<TypeParameterSyntax>, greaterThanToken: SyntaxToken): TypeParameterListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1484(reader: Roslyn.Utilities.ObjectReader): TypeParameterListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class TypeParameterSyntax extends CSharpSyntaxNode {
        attributeLists: CSharpSyntaxNode;
        varianceKeyword: SyntaxToken;
        identifier: SyntaxToken;
        constructor();
        ctor_1707(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, varianceKeyword: SyntaxToken, identifier: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeParameterSyntax;
        ctor_6048(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, varianceKeyword: SyntaxToken, identifier: SyntaxToken, context: SyntaxFactoryContext): TypeParameterSyntax;
        ctor_1702(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, varianceKeyword: SyntaxToken, identifier: SyntaxToken): TypeParameterSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        VarianceKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, varianceKeyword: SyntaxToken, identifier: SyntaxToken): TypeParameterSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_5018(reader: Roslyn.Utilities.ObjectReader): TypeParameterSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BaseTypeDeclarationSyntax extends MemberDeclarationSyntax {
        constructor();
        ctor_6723(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseTypeDeclarationSyntax;
        ctor_1217(kind: SyntaxKind): BaseTypeDeclarationSyntax;
        ctor_6865(reader: Roslyn.Utilities.ObjectReader): BaseTypeDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Identifier: SyntaxToken;
        BaseList: BaseListSyntax;
        OpenBraceToken: SyntaxToken;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
    }
    class TypeDeclarationSyntax extends BaseTypeDeclarationSyntax {
        constructor();
        ctor_1185(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeDeclarationSyntax;
        ctor_1477(kind: SyntaxKind): TypeDeclarationSyntax;
        ctor_7894(reader: Roslyn.Utilities.ObjectReader): TypeDeclarationSyntax;
        Keyword: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        Members: SyntaxList<MemberDeclarationSyntax>;
    }
    class ClassDeclarationSyntax extends TypeDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        keyword: SyntaxToken;
        identifier: SyntaxToken;
        typeParameterList: TypeParameterListSyntax;
        baseList: BaseListSyntax;
        constraintClauses: CSharpSyntaxNode;
        openBraceToken: SyntaxToken;
        members: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_6165(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ClassDeclarationSyntax;
        ctor_9117(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ClassDeclarationSyntax;
        ctor_1033(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): ClassDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Keyword: SyntaxToken;
        Identifier: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        BaseList: BaseListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        OpenBraceToken: SyntaxToken;
        Members: SyntaxList<MemberDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): ClassDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8597(reader: Roslyn.Utilities.ObjectReader): ClassDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class StructDeclarationSyntax extends TypeDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        keyword: SyntaxToken;
        identifier: SyntaxToken;
        typeParameterList: TypeParameterListSyntax;
        baseList: BaseListSyntax;
        constraintClauses: CSharpSyntaxNode;
        openBraceToken: SyntaxToken;
        members: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_9339(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): StructDeclarationSyntax;
        ctor_1044(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): StructDeclarationSyntax;
        ctor_2110(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): StructDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Keyword: SyntaxToken;
        Identifier: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        BaseList: BaseListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        OpenBraceToken: SyntaxToken;
        Members: SyntaxList<MemberDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): StructDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1785(reader: Roslyn.Utilities.ObjectReader): StructDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class InterfaceDeclarationSyntax extends TypeDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        keyword: SyntaxToken;
        identifier: SyntaxToken;
        typeParameterList: TypeParameterListSyntax;
        baseList: BaseListSyntax;
        constraintClauses: CSharpSyntaxNode;
        openBraceToken: SyntaxToken;
        members: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_7253(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InterfaceDeclarationSyntax;
        ctor_1608(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): InterfaceDeclarationSyntax;
        ctor_1999(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): InterfaceDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Keyword: SyntaxToken;
        Identifier: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        BaseList: BaseListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        OpenBraceToken: SyntaxToken;
        Members: SyntaxList<MemberDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): InterfaceDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1997(reader: Roslyn.Utilities.ObjectReader): InterfaceDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class EnumDeclarationSyntax extends BaseTypeDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        enumKeyword: SyntaxToken;
        identifier: SyntaxToken;
        baseList: BaseListSyntax;
        openBraceToken: SyntaxToken;
        members: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1399(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EnumDeclarationSyntax;
        ctor_1300(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): EnumDeclarationSyntax;
        ctor_5779(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): EnumDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        EnumKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        BaseList: BaseListSyntax;
        OpenBraceToken: SyntaxToken;
        Members: SeparatedSyntaxList<EnumMemberDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: SeparatedSyntaxList<EnumMemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): EnumDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2479(reader: Roslyn.Utilities.ObjectReader): EnumDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class DelegateDeclarationSyntax extends MemberDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        delegateKeyword: SyntaxToken;
        returnType: TypeSyntax;
        identifier: SyntaxToken;
        typeParameterList: TypeParameterListSyntax;
        parameterList: ParameterListSyntax;
        constraintClauses: CSharpSyntaxNode;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1428(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DelegateDeclarationSyntax;
        ctor_1031(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): DelegateDeclarationSyntax;
        ctor_4290(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, semicolonToken: SyntaxToken): DelegateDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        DelegateKeyword: SyntaxToken;
        ReturnType: TypeSyntax;
        Identifier: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        ParameterList: ParameterListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, semicolonToken: SyntaxToken): DelegateDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_4089(reader: Roslyn.Utilities.ObjectReader): DelegateDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class EnumMemberDeclarationSyntax extends MemberDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        identifier: SyntaxToken;
        equalsValue: EqualsValueClauseSyntax;
        constructor();
        ctor_1311(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EnumMemberDeclarationSyntax;
        ctor_1553(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax, context: SyntaxFactoryContext): EnumMemberDeclarationSyntax;
        ctor_2110(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax): EnumMemberDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Identifier: SyntaxToken;
        EqualsValue: EqualsValueClauseSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax): EnumMemberDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1255(reader: Roslyn.Utilities.ObjectReader): EnumMemberDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BaseListSyntax extends CSharpSyntaxNode {
        colonToken: SyntaxToken;
        types: CSharpSyntaxNode;
        constructor();
        ctor_7378(kind: SyntaxKind, colonToken: SyntaxToken, types: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseListSyntax;
        ctor_6846(kind: SyntaxKind, colonToken: SyntaxToken, types: CSharpSyntaxNode, context: SyntaxFactoryContext): BaseListSyntax;
        ctor_4637(kind: SyntaxKind, colonToken: SyntaxToken, types: CSharpSyntaxNode): BaseListSyntax;
        ColonToken: SyntaxToken;
        Types: SeparatedSyntaxList<BaseTypeSyntax>;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(colonToken: SyntaxToken, types: SeparatedSyntaxList<BaseTypeSyntax>): BaseListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2054(reader: Roslyn.Utilities.ObjectReader): BaseListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BaseTypeSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1077(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseTypeSyntax;
        ctor_5303(kind: SyntaxKind): BaseTypeSyntax;
        ctor_1167(reader: Roslyn.Utilities.ObjectReader): BaseTypeSyntax;
        Type: TypeSyntax;
    }
    class SimpleBaseTypeSyntax extends BaseTypeSyntax {
        type: TypeSyntax;
        constructor();
        ctor_1317(kind: SyntaxKind, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SimpleBaseTypeSyntax;
        ctor_1905(kind: SyntaxKind, type: TypeSyntax, context: SyntaxFactoryContext): SimpleBaseTypeSyntax;
        ctor_2816(kind: SyntaxKind, type: TypeSyntax): SimpleBaseTypeSyntax;
        Type: TypeSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(type: TypeSyntax): SimpleBaseTypeSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1769(reader: Roslyn.Utilities.ObjectReader): SimpleBaseTypeSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class TypeParameterConstraintClauseSyntax extends CSharpSyntaxNode {
        whereKeyword: SyntaxToken;
        name: IdentifierNameSyntax;
        colonToken: SyntaxToken;
        constraints: CSharpSyntaxNode;
        constructor();
        ctor_7439(kind: SyntaxKind, whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeParameterConstraintClauseSyntax;
        ctor_8985(kind: SyntaxKind, whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: CSharpSyntaxNode, context: SyntaxFactoryContext): TypeParameterConstraintClauseSyntax;
        ctor_7998(kind: SyntaxKind, whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: CSharpSyntaxNode): TypeParameterConstraintClauseSyntax;
        WhereKeyword: SyntaxToken;
        Name: IdentifierNameSyntax;
        ColonToken: SyntaxToken;
        Constraints: SeparatedSyntaxList<TypeParameterConstraintSyntax>;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: SeparatedSyntaxList<TypeParameterConstraintSyntax>): TypeParameterConstraintClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_7463(reader: Roslyn.Utilities.ObjectReader): TypeParameterConstraintClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class TypeParameterConstraintSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_5924(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeParameterConstraintSyntax;
        ctor_1641(kind: SyntaxKind): TypeParameterConstraintSyntax;
        ctor_2140(reader: Roslyn.Utilities.ObjectReader): TypeParameterConstraintSyntax;
    }
    class ConstructorConstraintSyntax extends TypeParameterConstraintSyntax {
        newKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_3835(kind: SyntaxKind, newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConstructorConstraintSyntax;
        ctor_1843(kind: SyntaxKind, newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): ConstructorConstraintSyntax;
        ctor_2123(kind: SyntaxKind, newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken): ConstructorConstraintSyntax;
        NewKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken): ConstructorConstraintSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1192(reader: Roslyn.Utilities.ObjectReader): ConstructorConstraintSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ClassOrStructConstraintSyntax extends TypeParameterConstraintSyntax {
        classOrStructKeyword: SyntaxToken;
        constructor();
        ctor_1261(kind: SyntaxKind, classOrStructKeyword: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ClassOrStructConstraintSyntax;
        ctor_1041(kind: SyntaxKind, classOrStructKeyword: SyntaxToken, context: SyntaxFactoryContext): ClassOrStructConstraintSyntax;
        ctor_1052(kind: SyntaxKind, classOrStructKeyword: SyntaxToken): ClassOrStructConstraintSyntax;
        ClassOrStructKeyword: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(classOrStructKeyword: SyntaxToken): ClassOrStructConstraintSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2023(reader: Roslyn.Utilities.ObjectReader): ClassOrStructConstraintSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class TypeConstraintSyntax extends TypeParameterConstraintSyntax {
        type: TypeSyntax;
        constructor();
        ctor_1014(kind: SyntaxKind, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeConstraintSyntax;
        ctor_1460(kind: SyntaxKind, type: TypeSyntax, context: SyntaxFactoryContext): TypeConstraintSyntax;
        ctor_9926(kind: SyntaxKind, type: TypeSyntax): TypeConstraintSyntax;
        Type: TypeSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(type: TypeSyntax): TypeConstraintSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_6116(reader: Roslyn.Utilities.ObjectReader): TypeConstraintSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BaseFieldDeclarationSyntax extends MemberDeclarationSyntax {
        constructor();
        ctor_1443(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseFieldDeclarationSyntax;
        ctor_1119(kind: SyntaxKind): BaseFieldDeclarationSyntax;
        ctor_7157(reader: Roslyn.Utilities.ObjectReader): BaseFieldDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Declaration: VariableDeclarationSyntax;
        SemicolonToken: SyntaxToken;
    }
    class FieldDeclarationSyntax extends BaseFieldDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        declaration: VariableDeclarationSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_6145(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): FieldDeclarationSyntax;
        ctor_6503(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): FieldDeclarationSyntax;
        ctor_1980(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): FieldDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Declaration: VariableDeclarationSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): FieldDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8559(reader: Roslyn.Utilities.ObjectReader): FieldDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class EventFieldDeclarationSyntax extends BaseFieldDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        eventKeyword: SyntaxToken;
        declaration: VariableDeclarationSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1250(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EventFieldDeclarationSyntax;
        ctor_1041(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): EventFieldDeclarationSyntax;
        ctor_3359(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): EventFieldDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        EventKeyword: SyntaxToken;
        Declaration: VariableDeclarationSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): EventFieldDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2799(reader: Roslyn.Utilities.ObjectReader): EventFieldDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ExplicitInterfaceSpecifierSyntax extends CSharpSyntaxNode {
        name: NameSyntax;
        dotToken: SyntaxToken;
        constructor();
        ctor_2893(kind: SyntaxKind, name: NameSyntax, dotToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ExplicitInterfaceSpecifierSyntax;
        ctor_1307(kind: SyntaxKind, name: NameSyntax, dotToken: SyntaxToken, context: SyntaxFactoryContext): ExplicitInterfaceSpecifierSyntax;
        ctor_1329(kind: SyntaxKind, name: NameSyntax, dotToken: SyntaxToken): ExplicitInterfaceSpecifierSyntax;
        Name: NameSyntax;
        DotToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: NameSyntax, dotToken: SyntaxToken): ExplicitInterfaceSpecifierSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_4143(reader: Roslyn.Utilities.ObjectReader): ExplicitInterfaceSpecifierSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BaseMethodDeclarationSyntax extends MemberDeclarationSyntax {
        constructor();
        ctor_1388(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseMethodDeclarationSyntax;
        ctor_1934(kind: SyntaxKind): BaseMethodDeclarationSyntax;
        ctor_5703(reader: Roslyn.Utilities.ObjectReader): BaseMethodDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        ParameterList: ParameterListSyntax;
        Body: BlockSyntax;
        SemicolonToken: SyntaxToken;
    }
    class MethodDeclarationSyntax extends BaseMethodDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        returnType: TypeSyntax;
        explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        identifier: SyntaxToken;
        typeParameterList: TypeParameterListSyntax;
        parameterList: ParameterListSyntax;
        constraintClauses: CSharpSyntaxNode;
        body: BlockSyntax;
        expressionBody: ArrowExpressionClauseSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_2048(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MethodDeclarationSyntax;
        ctor_1209(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): MethodDeclarationSyntax;
        ctor_1010(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): MethodDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        ReturnType: TypeSyntax;
        ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        Identifier: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        ParameterList: ParameterListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        Body: BlockSyntax;
        ExpressionBody: ArrowExpressionClauseSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): MethodDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2033(reader: Roslyn.Utilities.ObjectReader): MethodDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class OperatorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        returnType: TypeSyntax;
        operatorKeyword: SyntaxToken;
        operatorToken: SyntaxToken;
        parameterList: ParameterListSyntax;
        body: BlockSyntax;
        expressionBody: ArrowExpressionClauseSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1250(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OperatorDeclarationSyntax;
        ctor_1074(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): OperatorDeclarationSyntax;
        ctor_1579(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): OperatorDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        ReturnType: TypeSyntax;
        OperatorKeyword: SyntaxToken;
        OperatorToken: SyntaxToken;
        ParameterList: ParameterListSyntax;
        Body: BlockSyntax;
        ExpressionBody: ArrowExpressionClauseSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): OperatorDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1136(reader: Roslyn.Utilities.ObjectReader): OperatorDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ConversionOperatorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        implicitOrExplicitKeyword: SyntaxToken;
        operatorKeyword: SyntaxToken;
        type: TypeSyntax;
        parameterList: ParameterListSyntax;
        body: BlockSyntax;
        expressionBody: ArrowExpressionClauseSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_3968(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConversionOperatorDeclarationSyntax;
        ctor_1454(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ConversionOperatorDeclarationSyntax;
        ctor_8245(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): ConversionOperatorDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        ImplicitOrExplicitKeyword: SyntaxToken;
        OperatorKeyword: SyntaxToken;
        Type: TypeSyntax;
        ParameterList: ParameterListSyntax;
        Body: BlockSyntax;
        ExpressionBody: ArrowExpressionClauseSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): ConversionOperatorDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1363(reader: Roslyn.Utilities.ObjectReader): ConversionOperatorDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ConstructorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        identifier: SyntaxToken;
        parameterList: ParameterListSyntax;
        initializer: ConstructorInitializerSyntax;
        body: BlockSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_1590(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConstructorDeclarationSyntax;
        ctor_1430(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ConstructorDeclarationSyntax;
        ctor_1123(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): ConstructorDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Identifier: SyntaxToken;
        ParameterList: ParameterListSyntax;
        Initializer: ConstructorInitializerSyntax;
        Body: BlockSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): ConstructorDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1438(reader: Roslyn.Utilities.ObjectReader): ConstructorDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ConstructorInitializerSyntax extends CSharpSyntaxNode {
        colonToken: SyntaxToken;
        thisOrBaseKeyword: SyntaxToken;
        argumentList: ArgumentListSyntax;
        constructor();
        ctor_1065(kind: SyntaxKind, colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConstructorInitializerSyntax;
        ctor_9502(kind: SyntaxKind, colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax, context: SyntaxFactoryContext): ConstructorInitializerSyntax;
        ctor_6726(kind: SyntaxKind, colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax): ConstructorInitializerSyntax;
        ColonToken: SyntaxToken;
        ThisOrBaseKeyword: SyntaxToken;
        ArgumentList: ArgumentListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax): ConstructorInitializerSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2076(reader: Roslyn.Utilities.ObjectReader): ConstructorInitializerSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class DestructorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        tildeToken: SyntaxToken;
        identifier: SyntaxToken;
        parameterList: ParameterListSyntax;
        body: BlockSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_4916(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DestructorDeclarationSyntax;
        ctor_1525(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): DestructorDeclarationSyntax;
        ctor_1562(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): DestructorDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        TildeToken: SyntaxToken;
        Identifier: SyntaxToken;
        ParameterList: ParameterListSyntax;
        Body: BlockSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): DestructorDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1564(reader: Roslyn.Utilities.ObjectReader): DestructorDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BasePropertyDeclarationSyntax extends MemberDeclarationSyntax {
        constructor();
        ctor_1425(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BasePropertyDeclarationSyntax;
        ctor_1862(kind: SyntaxKind): BasePropertyDeclarationSyntax;
        ctor_1386(reader: Roslyn.Utilities.ObjectReader): BasePropertyDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Type: TypeSyntax;
        ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        AccessorList: AccessorListSyntax;
    }
    class PropertyDeclarationSyntax extends BasePropertyDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        type: TypeSyntax;
        explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        identifier: SyntaxToken;
        accessorList: AccessorListSyntax;
        expressionBody: ArrowExpressionClauseSyntax;
        initializer: EqualsValueClauseSyntax;
        semicolon: SyntaxToken;
        constructor();
        ctor_1737(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PropertyDeclarationSyntax;
        ctor_3039(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken, context: SyntaxFactoryContext): PropertyDeclarationSyntax;
        ctor_4136(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken): PropertyDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Type: TypeSyntax;
        ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        Identifier: SyntaxToken;
        AccessorList: AccessorListSyntax;
        ExpressionBody: ArrowExpressionClauseSyntax;
        Initializer: EqualsValueClauseSyntax;
        Semicolon: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken): PropertyDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1681(reader: Roslyn.Utilities.ObjectReader): PropertyDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ArrowExpressionClauseSyntax extends CSharpSyntaxNode {
        arrowToken: SyntaxToken;
        expression: ExpressionSyntax;
        constructor();
        ctor_2030(kind: SyntaxKind, arrowToken: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArrowExpressionClauseSyntax;
        ctor_5341(kind: SyntaxKind, arrowToken: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): ArrowExpressionClauseSyntax;
        ctor_1881(kind: SyntaxKind, arrowToken: SyntaxToken, expression: ExpressionSyntax): ArrowExpressionClauseSyntax;
        ArrowToken: SyntaxToken;
        Expression: ExpressionSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(arrowToken: SyntaxToken, expression: ExpressionSyntax): ArrowExpressionClauseSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8575(reader: Roslyn.Utilities.ObjectReader): ArrowExpressionClauseSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class EventDeclarationSyntax extends BasePropertyDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        eventKeyword: SyntaxToken;
        type: TypeSyntax;
        explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        identifier: SyntaxToken;
        accessorList: AccessorListSyntax;
        constructor();
        ctor_2047(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EventDeclarationSyntax;
        ctor_1179(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, context: SyntaxFactoryContext): EventDeclarationSyntax;
        ctor_6350(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax): EventDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        EventKeyword: SyntaxToken;
        Type: TypeSyntax;
        ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        Identifier: SyntaxToken;
        AccessorList: AccessorListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax): EventDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1343(reader: Roslyn.Utilities.ObjectReader): EventDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class IndexerDeclarationSyntax extends BasePropertyDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        type: TypeSyntax;
        explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        thisKeyword: SyntaxToken;
        parameterList: BracketedParameterListSyntax;
        accessorList: AccessorListSyntax;
        expressionBody: ArrowExpressionClauseSyntax;
        semicolon: SyntaxToken;
        constructor();
        ctor_1724(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IndexerDeclarationSyntax;
        ctor_1341(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken, context: SyntaxFactoryContext): IndexerDeclarationSyntax;
        ctor_1913(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken): IndexerDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Type: TypeSyntax;
        ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        ThisKeyword: SyntaxToken;
        ParameterList: BracketedParameterListSyntax;
        AccessorList: AccessorListSyntax;
        ExpressionBody: ArrowExpressionClauseSyntax;
        Semicolon: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken): IndexerDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_6123(reader: Roslyn.Utilities.ObjectReader): IndexerDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AccessorListSyntax extends CSharpSyntaxNode {
        openBraceToken: SyntaxToken;
        accessors: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        constructor();
        ctor_1983(kind: SyntaxKind, openBraceToken: SyntaxToken, accessors: CSharpSyntaxNode, closeBraceToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AccessorListSyntax;
        ctor_1005(kind: SyntaxKind, openBraceToken: SyntaxToken, accessors: CSharpSyntaxNode, closeBraceToken: SyntaxToken, context: SyntaxFactoryContext): AccessorListSyntax;
        ctor_4446(kind: SyntaxKind, openBraceToken: SyntaxToken, accessors: CSharpSyntaxNode, closeBraceToken: SyntaxToken): AccessorListSyntax;
        OpenBraceToken: SyntaxToken;
        Accessors: SyntaxList<AccessorDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBraceToken: SyntaxToken, accessors: SyntaxList<AccessorDeclarationSyntax>, closeBraceToken: SyntaxToken): AccessorListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1508(reader: Roslyn.Utilities.ObjectReader): AccessorListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class AccessorDeclarationSyntax extends CSharpSyntaxNode {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        keyword: SyntaxToken;
        body: BlockSyntax;
        semicolonToken: SyntaxToken;
        constructor();
        ctor_3526(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AccessorDeclarationSyntax;
        ctor_5617(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): AccessorDeclarationSyntax;
        ctor_1898(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken): AccessorDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Keyword: SyntaxToken;
        Body: BlockSyntax;
        SemicolonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken): AccessorDeclarationSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2034(reader: Roslyn.Utilities.ObjectReader): AccessorDeclarationSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BaseParameterListSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1312(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseParameterListSyntax;
        ctor_1762(kind: SyntaxKind): BaseParameterListSyntax;
        ctor_1023(reader: Roslyn.Utilities.ObjectReader): BaseParameterListSyntax;
        Parameters: SeparatedSyntaxList<ParameterSyntax>;
    }
    class ParameterListSyntax extends BaseParameterListSyntax {
        openParenToken: SyntaxToken;
        parameters: CSharpSyntaxNode;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_1688(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ParameterListSyntax;
        ctor_1342(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): ParameterListSyntax;
        ctor_2073(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken): ParameterListSyntax;
        OpenParenToken: SyntaxToken;
        Parameters: SeparatedSyntaxList<ParameterSyntax>;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<ParameterSyntax>, closeParenToken: SyntaxToken): ParameterListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8017(reader: Roslyn.Utilities.ObjectReader): ParameterListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BracketedParameterListSyntax extends BaseParameterListSyntax {
        openBracketToken: SyntaxToken;
        parameters: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;
        constructor();
        ctor_7255(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BracketedParameterListSyntax;
        ctor_3203(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken, context: SyntaxFactoryContext): BracketedParameterListSyntax;
        ctor_3556(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken): BracketedParameterListSyntax;
        OpenBracketToken: SyntaxToken;
        Parameters: SeparatedSyntaxList<ParameterSyntax>;
        CloseBracketToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<ParameterSyntax>, closeBracketToken: SyntaxToken): BracketedParameterListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1079(reader: Roslyn.Utilities.ObjectReader): BracketedParameterListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ParameterSyntax extends CSharpSyntaxNode {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        type: TypeSyntax;
        identifier: SyntaxToken;
        $default: EqualsValueClauseSyntax;
        constructor();
        ctor_1019(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ParameterSyntax;
        ctor_1292(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax, context: SyntaxFactoryContext): ParameterSyntax;
        ctor_1229(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax): ParameterSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Type: TypeSyntax;
        Identifier: SyntaxToken;
        Default: EqualsValueClauseSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax): ParameterSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_7554(reader: Roslyn.Utilities.ObjectReader): ParameterSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class IncompleteMemberSyntax extends MemberDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        type: TypeSyntax;
        constructor();
        ctor_1408(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IncompleteMemberSyntax;
        ctor_2249(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, context: SyntaxFactoryContext): IncompleteMemberSyntax;
        ctor_1869(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax): IncompleteMemberSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxList<SyntaxToken>;
        Type: TypeSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax): IncompleteMemberSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_4559(reader: Roslyn.Utilities.ObjectReader): IncompleteMemberSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class SkippedTokensTriviaSyntax extends StructuredTriviaSyntax {
        tokens: CSharpSyntaxNode;
        constructor();
        ctor_1606(kind: SyntaxKind, tokens: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SkippedTokensTriviaSyntax;
        ctor_2298(kind: SyntaxKind, tokens: CSharpSyntaxNode, context: SyntaxFactoryContext): SkippedTokensTriviaSyntax;
        ctor_1251(kind: SyntaxKind, tokens: CSharpSyntaxNode): SkippedTokensTriviaSyntax;
        Tokens: SyntaxList<SyntaxToken>;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(tokens: SyntaxList<SyntaxToken>): SkippedTokensTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1788(reader: Roslyn.Utilities.ObjectReader): SkippedTokensTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class DocumentationCommentTriviaSyntax extends StructuredTriviaSyntax {
        content: CSharpSyntaxNode;
        endOfComment: SyntaxToken;
        constructor();
        ctor_1873(kind: SyntaxKind, content: CSharpSyntaxNode, endOfComment: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DocumentationCommentTriviaSyntax;
        ctor_1399(kind: SyntaxKind, content: CSharpSyntaxNode, endOfComment: SyntaxToken, context: SyntaxFactoryContext): DocumentationCommentTriviaSyntax;
        ctor_5915(kind: SyntaxKind, content: CSharpSyntaxNode, endOfComment: SyntaxToken): DocumentationCommentTriviaSyntax;
        Content: SyntaxList<XmlNodeSyntax>;
        EndOfComment: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(content: SyntaxList<XmlNodeSyntax>, endOfComment: SyntaxToken): DocumentationCommentTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1096(reader: Roslyn.Utilities.ObjectReader): DocumentationCommentTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class CrefSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_2895(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CrefSyntax;
        ctor_9523(kind: SyntaxKind): CrefSyntax;
        ctor_2879(reader: Roslyn.Utilities.ObjectReader): CrefSyntax;
    }
    class TypeCrefSyntax extends CrefSyntax {
        type: TypeSyntax;
        constructor();
        ctor_1515(kind: SyntaxKind, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeCrefSyntax;
        ctor_1565(kind: SyntaxKind, type: TypeSyntax, context: SyntaxFactoryContext): TypeCrefSyntax;
        ctor_8612(kind: SyntaxKind, type: TypeSyntax): TypeCrefSyntax;
        Type: TypeSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(type: TypeSyntax): TypeCrefSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8795(reader: Roslyn.Utilities.ObjectReader): TypeCrefSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class QualifiedCrefSyntax extends CrefSyntax {
        container: TypeSyntax;
        dotToken: SyntaxToken;
        member: MemberCrefSyntax;
        constructor();
        ctor_1551(kind: SyntaxKind, container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QualifiedCrefSyntax;
        ctor_1897(kind: SyntaxKind, container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax, context: SyntaxFactoryContext): QualifiedCrefSyntax;
        ctor_1939(kind: SyntaxKind, container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax): QualifiedCrefSyntax;
        Container: TypeSyntax;
        DotToken: SyntaxToken;
        Member: MemberCrefSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax): QualifiedCrefSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1025(reader: Roslyn.Utilities.ObjectReader): QualifiedCrefSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class MemberCrefSyntax extends CrefSyntax {
        constructor();
        ctor_1053(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MemberCrefSyntax;
        ctor_3739(kind: SyntaxKind): MemberCrefSyntax;
        ctor_1923(reader: Roslyn.Utilities.ObjectReader): MemberCrefSyntax;
    }
    class NameMemberCrefSyntax extends MemberCrefSyntax {
        name: TypeSyntax;
        parameters: CrefParameterListSyntax;
        constructor();
        ctor_8612(kind: SyntaxKind, name: TypeSyntax, parameters: CrefParameterListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NameMemberCrefSyntax;
        ctor_9433(kind: SyntaxKind, name: TypeSyntax, parameters: CrefParameterListSyntax, context: SyntaxFactoryContext): NameMemberCrefSyntax;
        ctor_1436(kind: SyntaxKind, name: TypeSyntax, parameters: CrefParameterListSyntax): NameMemberCrefSyntax;
        Name: TypeSyntax;
        Parameters: CrefParameterListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: TypeSyntax, parameters: CrefParameterListSyntax): NameMemberCrefSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_4277(reader: Roslyn.Utilities.ObjectReader): NameMemberCrefSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class IndexerMemberCrefSyntax extends MemberCrefSyntax {
        thisKeyword: SyntaxToken;
        parameters: CrefBracketedParameterListSyntax;
        constructor();
        ctor_8475(kind: SyntaxKind, thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IndexerMemberCrefSyntax;
        ctor_4376(kind: SyntaxKind, thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax, context: SyntaxFactoryContext): IndexerMemberCrefSyntax;
        ctor_2097(kind: SyntaxKind, thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax): IndexerMemberCrefSyntax;
        ThisKeyword: SyntaxToken;
        Parameters: CrefBracketedParameterListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax): IndexerMemberCrefSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1214(reader: Roslyn.Utilities.ObjectReader): IndexerMemberCrefSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class OperatorMemberCrefSyntax extends MemberCrefSyntax {
        operatorKeyword: SyntaxToken;
        operatorToken: SyntaxToken;
        parameters: CrefParameterListSyntax;
        constructor();
        ctor_1212(kind: SyntaxKind, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OperatorMemberCrefSyntax;
        ctor_6188(kind: SyntaxKind, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax, context: SyntaxFactoryContext): OperatorMemberCrefSyntax;
        ctor_1625(kind: SyntaxKind, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax): OperatorMemberCrefSyntax;
        OperatorKeyword: SyntaxToken;
        OperatorToken: SyntaxToken;
        Parameters: CrefParameterListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax): OperatorMemberCrefSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1347(reader: Roslyn.Utilities.ObjectReader): OperatorMemberCrefSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ConversionOperatorMemberCrefSyntax extends MemberCrefSyntax {
        implicitOrExplicitKeyword: SyntaxToken;
        operatorKeyword: SyntaxToken;
        type: TypeSyntax;
        parameters: CrefParameterListSyntax;
        constructor();
        ctor_7616(kind: SyntaxKind, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConversionOperatorMemberCrefSyntax;
        ctor_7179(kind: SyntaxKind, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax, context: SyntaxFactoryContext): ConversionOperatorMemberCrefSyntax;
        ctor_1291(kind: SyntaxKind, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax): ConversionOperatorMemberCrefSyntax;
        ImplicitOrExplicitKeyword: SyntaxToken;
        OperatorKeyword: SyntaxToken;
        Type: TypeSyntax;
        Parameters: CrefParameterListSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax): ConversionOperatorMemberCrefSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_9378(reader: Roslyn.Utilities.ObjectReader): ConversionOperatorMemberCrefSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BaseCrefParameterListSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_6975(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseCrefParameterListSyntax;
        ctor_4040(kind: SyntaxKind): BaseCrefParameterListSyntax;
        ctor_1932(reader: Roslyn.Utilities.ObjectReader): BaseCrefParameterListSyntax;
        Parameters: SeparatedSyntaxList<CrefParameterSyntax>;
    }
    class CrefParameterListSyntax extends BaseCrefParameterListSyntax {
        openParenToken: SyntaxToken;
        parameters: CSharpSyntaxNode;
        closeParenToken: SyntaxToken;
        constructor();
        ctor_1950(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CrefParameterListSyntax;
        ctor_2311(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): CrefParameterListSyntax;
        ctor_4663(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken): CrefParameterListSyntax;
        OpenParenToken: SyntaxToken;
        Parameters: SeparatedSyntaxList<CrefParameterSyntax>;
        CloseParenToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<CrefParameterSyntax>, closeParenToken: SyntaxToken): CrefParameterListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_7526(reader: Roslyn.Utilities.ObjectReader): CrefParameterListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class CrefBracketedParameterListSyntax extends BaseCrefParameterListSyntax {
        openBracketToken: SyntaxToken;
        parameters: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;
        constructor();
        ctor_2822(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CrefBracketedParameterListSyntax;
        ctor_3133(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken, context: SyntaxFactoryContext): CrefBracketedParameterListSyntax;
        ctor_5561(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken): CrefBracketedParameterListSyntax;
        OpenBracketToken: SyntaxToken;
        Parameters: SeparatedSyntaxList<CrefParameterSyntax>;
        CloseBracketToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<CrefParameterSyntax>, closeBracketToken: SyntaxToken): CrefBracketedParameterListSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1146(reader: Roslyn.Utilities.ObjectReader): CrefBracketedParameterListSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class CrefParameterSyntax extends CSharpSyntaxNode {
        refOrOutKeyword: SyntaxToken;
        type: TypeSyntax;
        constructor();
        ctor_1463(kind: SyntaxKind, refOrOutKeyword: SyntaxToken, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CrefParameterSyntax;
        ctor_4620(kind: SyntaxKind, refOrOutKeyword: SyntaxToken, type: TypeSyntax, context: SyntaxFactoryContext): CrefParameterSyntax;
        ctor_1290(kind: SyntaxKind, refOrOutKeyword: SyntaxToken, type: TypeSyntax): CrefParameterSyntax;
        RefOrOutKeyword: SyntaxToken;
        Type: TypeSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(refOrOutKeyword: SyntaxToken, type: TypeSyntax): CrefParameterSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_5921(reader: Roslyn.Utilities.ObjectReader): CrefParameterSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlNodeSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1320(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlNodeSyntax;
        ctor_1732(kind: SyntaxKind): XmlNodeSyntax;
        ctor_9053(reader: Roslyn.Utilities.ObjectReader): XmlNodeSyntax;
    }
    class XmlElementSyntax extends XmlNodeSyntax {
        startTag: XmlElementStartTagSyntax;
        content: CSharpSyntaxNode;
        endTag: XmlElementEndTagSyntax;
        constructor();
        ctor_2144(kind: SyntaxKind, startTag: XmlElementStartTagSyntax, content: CSharpSyntaxNode, endTag: XmlElementEndTagSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlElementSyntax;
        ctor_1661(kind: SyntaxKind, startTag: XmlElementStartTagSyntax, content: CSharpSyntaxNode, endTag: XmlElementEndTagSyntax, context: SyntaxFactoryContext): XmlElementSyntax;
        ctor_1787(kind: SyntaxKind, startTag: XmlElementStartTagSyntax, content: CSharpSyntaxNode, endTag: XmlElementEndTagSyntax): XmlElementSyntax;
        StartTag: XmlElementStartTagSyntax;
        Content: SyntaxList<XmlNodeSyntax>;
        EndTag: XmlElementEndTagSyntax;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(startTag: XmlElementStartTagSyntax, content: SyntaxList<XmlNodeSyntax>, endTag: XmlElementEndTagSyntax): XmlElementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_5825(reader: Roslyn.Utilities.ObjectReader): XmlElementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlElementStartTagSyntax extends CSharpSyntaxNode {
        lessThanToken: SyntaxToken;
        name: XmlNameSyntax;
        attributes: CSharpSyntaxNode;
        greaterThanToken: SyntaxToken;
        constructor();
        ctor_3655(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, greaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlElementStartTagSyntax;
        ctor_7130(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, greaterThanToken: SyntaxToken, context: SyntaxFactoryContext): XmlElementStartTagSyntax;
        ctor_1726(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, greaterThanToken: SyntaxToken): XmlElementStartTagSyntax;
        LessThanToken: SyntaxToken;
        Name: XmlNameSyntax;
        Attributes: SyntaxList<XmlAttributeSyntax>;
        GreaterThanToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: SyntaxList<XmlAttributeSyntax>, greaterThanToken: SyntaxToken): XmlElementStartTagSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8444(reader: Roslyn.Utilities.ObjectReader): XmlElementStartTagSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlElementEndTagSyntax extends CSharpSyntaxNode {
        lessThanSlashToken: SyntaxToken;
        name: XmlNameSyntax;
        greaterThanToken: SyntaxToken;
        constructor();
        ctor_6287(kind: SyntaxKind, lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlElementEndTagSyntax;
        ctor_2034(kind: SyntaxKind, lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken, context: SyntaxFactoryContext): XmlElementEndTagSyntax;
        ctor_1135(kind: SyntaxKind, lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken): XmlElementEndTagSyntax;
        LessThanSlashToken: SyntaxToken;
        Name: XmlNameSyntax;
        GreaterThanToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken): XmlElementEndTagSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1776(reader: Roslyn.Utilities.ObjectReader): XmlElementEndTagSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlEmptyElementSyntax extends XmlNodeSyntax {
        lessThanToken: SyntaxToken;
        name: XmlNameSyntax;
        attributes: CSharpSyntaxNode;
        slashGreaterThanToken: SyntaxToken;
        constructor();
        ctor_1023(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, slashGreaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlEmptyElementSyntax;
        ctor_9676(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, slashGreaterThanToken: SyntaxToken, context: SyntaxFactoryContext): XmlEmptyElementSyntax;
        ctor_1537(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, slashGreaterThanToken: SyntaxToken): XmlEmptyElementSyntax;
        LessThanToken: SyntaxToken;
        Name: XmlNameSyntax;
        Attributes: SyntaxList<XmlAttributeSyntax>;
        SlashGreaterThanToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: SyntaxList<XmlAttributeSyntax>, slashGreaterThanToken: SyntaxToken): XmlEmptyElementSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1440(reader: Roslyn.Utilities.ObjectReader): XmlEmptyElementSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlNameSyntax extends CSharpSyntaxNode {
        prefix: XmlPrefixSyntax;
        localName: SyntaxToken;
        constructor();
        ctor_1617(kind: SyntaxKind, prefix: XmlPrefixSyntax, localName: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlNameSyntax;
        ctor_1772(kind: SyntaxKind, prefix: XmlPrefixSyntax, localName: SyntaxToken, context: SyntaxFactoryContext): XmlNameSyntax;
        ctor_1073(kind: SyntaxKind, prefix: XmlPrefixSyntax, localName: SyntaxToken): XmlNameSyntax;
        Prefix: XmlPrefixSyntax;
        LocalName: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(prefix: XmlPrefixSyntax, localName: SyntaxToken): XmlNameSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_4457(reader: Roslyn.Utilities.ObjectReader): XmlNameSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlPrefixSyntax extends CSharpSyntaxNode {
        prefix: SyntaxToken;
        colonToken: SyntaxToken;
        constructor();
        ctor_1733_C(kind: SyntaxKind, prefix: SyntaxToken, colonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlPrefixSyntax;
        ctor_1226(kind: SyntaxKind, prefix: SyntaxToken, colonToken: SyntaxToken, context: SyntaxFactoryContext): XmlPrefixSyntax;
        ctor_1260(kind: SyntaxKind, prefix: SyntaxToken, colonToken: SyntaxToken): XmlPrefixSyntax;
        Prefix: SyntaxToken;
        ColonToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(prefix: SyntaxToken, colonToken: SyntaxToken): XmlPrefixSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1218(reader: Roslyn.Utilities.ObjectReader): XmlPrefixSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlAttributeSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1557(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlAttributeSyntax;
        ctor_5213(kind: SyntaxKind): XmlAttributeSyntax;
        ctor_1098(reader: Roslyn.Utilities.ObjectReader): XmlAttributeSyntax;
        Name: XmlNameSyntax;
        EqualsToken: SyntaxToken;
        StartQuoteToken: SyntaxToken;
        EndQuoteToken: SyntaxToken;
    }
    class XmlTextAttributeSyntax extends XmlAttributeSyntax {
        name: XmlNameSyntax;
        equalsToken: SyntaxToken;
        startQuoteToken: SyntaxToken;
        textTokens: CSharpSyntaxNode;
        endQuoteToken: SyntaxToken;
        constructor();
        ctor_7087(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: CSharpSyntaxNode, endQuoteToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlTextAttributeSyntax;
        ctor_1991(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: CSharpSyntaxNode, endQuoteToken: SyntaxToken, context: SyntaxFactoryContext): XmlTextAttributeSyntax;
        ctor_2141(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: CSharpSyntaxNode, endQuoteToken: SyntaxToken): XmlTextAttributeSyntax;
        Name: XmlNameSyntax;
        EqualsToken: SyntaxToken;
        StartQuoteToken: SyntaxToken;
        TextTokens: SyntaxList<SyntaxToken>;
        EndQuoteToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, endQuoteToken: SyntaxToken): XmlTextAttributeSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1728(reader: Roslyn.Utilities.ObjectReader): XmlTextAttributeSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlCrefAttributeSyntax extends XmlAttributeSyntax {
        name: XmlNameSyntax;
        equalsToken: SyntaxToken;
        startQuoteToken: SyntaxToken;
        cref: CrefSyntax;
        endQuoteToken: SyntaxToken;
        constructor();
        ctor_2010(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlCrefAttributeSyntax;
        ctor_1110(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken, context: SyntaxFactoryContext): XmlCrefAttributeSyntax;
        ctor_2049(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken): XmlCrefAttributeSyntax;
        Name: XmlNameSyntax;
        EqualsToken: SyntaxToken;
        StartQuoteToken: SyntaxToken;
        Cref: CrefSyntax;
        EndQuoteToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken): XmlCrefAttributeSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1715(reader: Roslyn.Utilities.ObjectReader): XmlCrefAttributeSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlNameAttributeSyntax extends XmlAttributeSyntax {
        name: XmlNameSyntax;
        equalsToken: SyntaxToken;
        startQuoteToken: SyntaxToken;
        identifier: IdentifierNameSyntax;
        endQuoteToken: SyntaxToken;
        constructor();
        ctor_1926(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlNameAttributeSyntax;
        ctor_2473(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken, context: SyntaxFactoryContext): XmlNameAttributeSyntax;
        ctor_2001(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken): XmlNameAttributeSyntax;
        Name: XmlNameSyntax;
        EqualsToken: SyntaxToken;
        StartQuoteToken: SyntaxToken;
        Identifier: IdentifierNameSyntax;
        EndQuoteToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken): XmlNameAttributeSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1022(reader: Roslyn.Utilities.ObjectReader): XmlNameAttributeSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlTextSyntax extends XmlNodeSyntax {
        textTokens: CSharpSyntaxNode;
        constructor();
        ctor_8428(kind: SyntaxKind, textTokens: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlTextSyntax;
        ctor_4772(kind: SyntaxKind, textTokens: CSharpSyntaxNode, context: SyntaxFactoryContext): XmlTextSyntax;
        ctor_1049(kind: SyntaxKind, textTokens: CSharpSyntaxNode): XmlTextSyntax;
        TextTokens: SyntaxList<SyntaxToken>;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(textTokens: SyntaxList<SyntaxToken>): XmlTextSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1378(reader: Roslyn.Utilities.ObjectReader): XmlTextSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlCDataSectionSyntax extends XmlNodeSyntax {
        startCDataToken: SyntaxToken;
        textTokens: CSharpSyntaxNode;
        endCDataToken: SyntaxToken;
        constructor();
        ctor_1655(kind: SyntaxKind, startCDataToken: SyntaxToken, textTokens: CSharpSyntaxNode, endCDataToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlCDataSectionSyntax;
        ctor_1490(kind: SyntaxKind, startCDataToken: SyntaxToken, textTokens: CSharpSyntaxNode, endCDataToken: SyntaxToken, context: SyntaxFactoryContext): XmlCDataSectionSyntax;
        ctor_1686(kind: SyntaxKind, startCDataToken: SyntaxToken, textTokens: CSharpSyntaxNode, endCDataToken: SyntaxToken): XmlCDataSectionSyntax;
        StartCDataToken: SyntaxToken;
        TextTokens: SyntaxList<SyntaxToken>;
        EndCDataToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(startCDataToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, endCDataToken: SyntaxToken): XmlCDataSectionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2088(reader: Roslyn.Utilities.ObjectReader): XmlCDataSectionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlProcessingInstructionSyntax extends XmlNodeSyntax {
        startProcessingInstructionToken: SyntaxToken;
        name: XmlNameSyntax;
        textTokens: CSharpSyntaxNode;
        endProcessingInstructionToken: SyntaxToken;
        constructor();
        ctor_3526(kind: SyntaxKind, startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: CSharpSyntaxNode, endProcessingInstructionToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlProcessingInstructionSyntax;
        ctor_1507(kind: SyntaxKind, startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: CSharpSyntaxNode, endProcessingInstructionToken: SyntaxToken, context: SyntaxFactoryContext): XmlProcessingInstructionSyntax;
        ctor_1064(kind: SyntaxKind, startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: CSharpSyntaxNode, endProcessingInstructionToken: SyntaxToken): XmlProcessingInstructionSyntax;
        StartProcessingInstructionToken: SyntaxToken;
        Name: XmlNameSyntax;
        TextTokens: SyntaxList<SyntaxToken>;
        EndProcessingInstructionToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: SyntaxList<SyntaxToken>, endProcessingInstructionToken: SyntaxToken): XmlProcessingInstructionSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1488(reader: Roslyn.Utilities.ObjectReader): XmlProcessingInstructionSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class XmlCommentSyntax extends XmlNodeSyntax {
        lessThanExclamationMinusMinusToken: SyntaxToken;
        textTokens: CSharpSyntaxNode;
        minusMinusGreaterThanToken: SyntaxToken;
        constructor();
        ctor_3348(kind: SyntaxKind, lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: CSharpSyntaxNode, minusMinusGreaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlCommentSyntax;
        ctor_1022(kind: SyntaxKind, lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: CSharpSyntaxNode, minusMinusGreaterThanToken: SyntaxToken, context: SyntaxFactoryContext): XmlCommentSyntax;
        ctor_1033(kind: SyntaxKind, lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: CSharpSyntaxNode, minusMinusGreaterThanToken: SyntaxToken): XmlCommentSyntax;
        LessThanExclamationMinusMinusToken: SyntaxToken;
        TextTokens: SyntaxList<SyntaxToken>;
        MinusMinusGreaterThanToken: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, minusMinusGreaterThanToken: SyntaxToken): XmlCommentSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1732_C(reader: Roslyn.Utilities.ObjectReader): XmlCommentSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BranchingDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_1474(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BranchingDirectiveTriviaSyntax;
        ctor_2042(kind: SyntaxKind): BranchingDirectiveTriviaSyntax;
        ctor_6254(reader: Roslyn.Utilities.ObjectReader): BranchingDirectiveTriviaSyntax;
        BranchTaken: boolean;
    }
    class ConditionalDirectiveTriviaSyntax extends BranchingDirectiveTriviaSyntax {
        constructor();
        ctor_1319(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConditionalDirectiveTriviaSyntax;
        ctor_1596(kind: SyntaxKind): ConditionalDirectiveTriviaSyntax;
        ctor_1311(reader: Roslyn.Utilities.ObjectReader): ConditionalDirectiveTriviaSyntax;
        Condition: ExpressionSyntax;
        ConditionValue: boolean;
    }
    class IfDirectiveTriviaSyntax extends ConditionalDirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        ifKeyword: SyntaxToken;
        condition: ExpressionSyntax;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        branchTaken: boolean;
        conditionValue: boolean;
        constructor();
        ctor_7775(kind: SyntaxKind, hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IfDirectiveTriviaSyntax;
        ctor_2093(kind: SyntaxKind, hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean, context: SyntaxFactoryContext): IfDirectiveTriviaSyntax;
        ctor_2113(kind: SyntaxKind, hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): IfDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        IfKeyword: SyntaxToken;
        Condition: ExpressionSyntax;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        BranchTaken: boolean;
        ConditionValue: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): IfDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1308(reader: Roslyn.Utilities.ObjectReader): IfDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ElifDirectiveTriviaSyntax extends ConditionalDirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        elifKeyword: SyntaxToken;
        condition: ExpressionSyntax;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        branchTaken: boolean;
        conditionValue: boolean;
        constructor();
        ctor_1705(kind: SyntaxKind, hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ElifDirectiveTriviaSyntax;
        ctor_7592(kind: SyntaxKind, hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean, context: SyntaxFactoryContext): ElifDirectiveTriviaSyntax;
        ctor_9784(kind: SyntaxKind, hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): ElifDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        ElifKeyword: SyntaxToken;
        Condition: ExpressionSyntax;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        BranchTaken: boolean;
        ConditionValue: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): ElifDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_9079(reader: Roslyn.Utilities.ObjectReader): ElifDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ElseDirectiveTriviaSyntax extends BranchingDirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        elseKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        branchTaken: boolean;
        constructor();
        ctor_8514(kind: SyntaxKind, hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ElseDirectiveTriviaSyntax;
        ctor_2016(kind: SyntaxKind, hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, context: SyntaxFactoryContext): ElseDirectiveTriviaSyntax;
        ctor_1549(kind: SyntaxKind, hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean): ElseDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        ElseKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        BranchTaken: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean): ElseDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1067(reader: Roslyn.Utilities.ObjectReader): ElseDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class EndIfDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        endIfKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_1788(kind: SyntaxKind, hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EndIfDirectiveTriviaSyntax;
        ctor_6683(kind: SyntaxKind, hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): EndIfDirectiveTriviaSyntax;
        ctor_2989(kind: SyntaxKind, hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndIfDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        EndIfKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndIfDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1089(reader: Roslyn.Utilities.ObjectReader): EndIfDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class RegionDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        regionKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_8896(kind: SyntaxKind, hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): RegionDirectiveTriviaSyntax;
        ctor_1982(kind: SyntaxKind, hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): RegionDirectiveTriviaSyntax;
        ctor_2005(kind: SyntaxKind, hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): RegionDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        RegionKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): RegionDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1589(reader: Roslyn.Utilities.ObjectReader): RegionDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class EndRegionDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        endRegionKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_9044(kind: SyntaxKind, hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EndRegionDirectiveTriviaSyntax;
        ctor_1167(kind: SyntaxKind, hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): EndRegionDirectiveTriviaSyntax;
        ctor_1067(kind: SyntaxKind, hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndRegionDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        EndRegionKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndRegionDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1946(reader: Roslyn.Utilities.ObjectReader): EndRegionDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ErrorDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        errorKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_2123(kind: SyntaxKind, hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ErrorDirectiveTriviaSyntax;
        ctor_3594(kind: SyntaxKind, hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): ErrorDirectiveTriviaSyntax;
        ctor_1746(kind: SyntaxKind, hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ErrorDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        ErrorKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ErrorDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_7672(reader: Roslyn.Utilities.ObjectReader): ErrorDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class WarningDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        warningKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_8172(kind: SyntaxKind, hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): WarningDirectiveTriviaSyntax;
        ctor_1502(kind: SyntaxKind, hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): WarningDirectiveTriviaSyntax;
        ctor_1630(kind: SyntaxKind, hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): WarningDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        WarningKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): WarningDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1613(reader: Roslyn.Utilities.ObjectReader): WarningDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class BadDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        identifier: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_1152(kind: SyntaxKind, hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BadDirectiveTriviaSyntax;
        ctor_1120(kind: SyntaxKind, hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): BadDirectiveTriviaSyntax;
        ctor_1037(kind: SyntaxKind, hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): BadDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        Identifier: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): BadDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1471(reader: Roslyn.Utilities.ObjectReader): BadDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class DefineDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        defineKeyword: SyntaxToken;
        name: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_1065(kind: SyntaxKind, hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DefineDirectiveTriviaSyntax;
        ctor_1673(kind: SyntaxKind, hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): DefineDirectiveTriviaSyntax;
        ctor_1051(kind: SyntaxKind, hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): DefineDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        DefineKeyword: SyntaxToken;
        Name: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): DefineDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_8033(reader: Roslyn.Utilities.ObjectReader): DefineDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class UndefDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        undefKeyword: SyntaxToken;
        name: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_1777(kind: SyntaxKind, hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): UndefDirectiveTriviaSyntax;
        ctor_1192(kind: SyntaxKind, hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): UndefDirectiveTriviaSyntax;
        ctor_5569(kind: SyntaxKind, hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): UndefDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        UndefKeyword: SyntaxToken;
        Name: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): UndefDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_2015(reader: Roslyn.Utilities.ObjectReader): UndefDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class LineDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        lineKeyword: SyntaxToken;
        line: SyntaxToken;
        file: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_1702(kind: SyntaxKind, hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LineDirectiveTriviaSyntax;
        ctor_2058(kind: SyntaxKind, hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): LineDirectiveTriviaSyntax;
        ctor_4648(kind: SyntaxKind, hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): LineDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        LineKeyword: SyntaxToken;
        Line: SyntaxToken;
        File: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): LineDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1094(reader: Roslyn.Utilities.ObjectReader): LineDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class PragmaWarningDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        pragmaKeyword: SyntaxToken;
        warningKeyword: SyntaxToken;
        disableOrRestoreKeyword: SyntaxToken;
        errorCodes: CSharpSyntaxNode;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_1823(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: CSharpSyntaxNode, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PragmaWarningDirectiveTriviaSyntax;
        ctor_1913(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: CSharpSyntaxNode, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): PragmaWarningDirectiveTriviaSyntax;
        ctor_1755(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: CSharpSyntaxNode, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaWarningDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        PragmaKeyword: SyntaxToken;
        WarningKeyword: SyntaxToken;
        DisableOrRestoreKeyword: SyntaxToken;
        ErrorCodes: SeparatedSyntaxList<ExpressionSyntax>;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: SeparatedSyntaxList<ExpressionSyntax>, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaWarningDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1991(reader: Roslyn.Utilities.ObjectReader): PragmaWarningDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class PragmaChecksumDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        pragmaKeyword: SyntaxToken;
        checksumKeyword: SyntaxToken;
        file: SyntaxToken;
        guid: SyntaxToken;
        bytes: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_4505(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PragmaChecksumDirectiveTriviaSyntax;
        ctor_1957(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): PragmaChecksumDirectiveTriviaSyntax;
        ctor_1214(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaChecksumDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        PragmaKeyword: SyntaxToken;
        ChecksumKeyword: SyntaxToken;
        File: SyntaxToken;
        Guid: SyntaxToken;
        Bytes: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaChecksumDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_9866(reader: Roslyn.Utilities.ObjectReader): PragmaChecksumDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class ReferenceDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        referenceKeyword: SyntaxToken;
        file: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        constructor();
        ctor_1740(kind: SyntaxKind, hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ReferenceDirectiveTriviaSyntax;
        ctor_1770(kind: SyntaxKind, hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): ReferenceDirectiveTriviaSyntax;
        ctor_7929(kind: SyntaxKind, hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ReferenceDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        ReferenceKeyword: SyntaxToken;
        File: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ReferenceDirectiveTriviaSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1030(reader: Roslyn.Utilities.ObjectReader): ReferenceDirectiveTriviaSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class InterpolatedStringSyntax extends ExpressionSyntax {
        stringStart: SyntaxToken;
        interpolatedInserts: CSharpSyntaxNode;
        stringEnd: SyntaxToken;
        constructor();
        ctor_7981(kind: SyntaxKind, stringStart: SyntaxToken, interpolatedInserts: CSharpSyntaxNode, stringEnd: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InterpolatedStringSyntax;
        ctor_8834(kind: SyntaxKind, stringStart: SyntaxToken, interpolatedInserts: CSharpSyntaxNode, stringEnd: SyntaxToken, context: SyntaxFactoryContext): InterpolatedStringSyntax;
        ctor_2113(kind: SyntaxKind, stringStart: SyntaxToken, interpolatedInserts: CSharpSyntaxNode, stringEnd: SyntaxToken): InterpolatedStringSyntax;
        StringStart: SyntaxToken;
        InterpolatedInserts: SeparatedSyntaxList<InterpolatedStringInsertSyntax>;
        StringEnd: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(stringStart: SyntaxToken, interpolatedInserts: SeparatedSyntaxList<InterpolatedStringInsertSyntax>, stringEnd: SyntaxToken): InterpolatedStringSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1417(reader: Roslyn.Utilities.ObjectReader): InterpolatedStringSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
    class InterpolatedStringInsertSyntax extends CSharpSyntaxNode {
        expression: ExpressionSyntax;
        comma: SyntaxToken;
        alignment: ExpressionSyntax;
        format: SyntaxToken;
        constructor();
        ctor_1139(kind: SyntaxKind, expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InterpolatedStringInsertSyntax;
        ctor_2595(kind: SyntaxKind, expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken, context: SyntaxFactoryContext): InterpolatedStringInsertSyntax;
        ctor_7483(kind: SyntaxKind, expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken): InterpolatedStringInsertSyntax;
        Expression: ExpressionSyntax;
        Comma: SyntaxToken;
        Alignment: ExpressionSyntax;
        Format: SyntaxToken;
        GetSlot(index: number): GreenNode;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken): InterpolatedStringInsertSyntax;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ctor_1109(reader: Roslyn.Utilities.ObjectReader): InterpolatedStringInsertSyntax;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class CSharpSyntaxNode extends SyntaxNode implements IMessageSerializable {
        ctor_6242(green: GreenNode, parent: SyntaxNode, position: number): CSharpSyntaxNode;
        ctor_1688(green: GreenNode, position: number, syntaxTree: SyntaxTree): CSharpSyntaxNode;
        Navigator: AbstractSyntaxNavigator;
        static CloneNodeAsRoot<T extends SyntaxNode>(node: T, syntaxTree: SyntaxTree): T;
        SyntaxTree: SyntaxTree;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Parent: CSharpSyntaxNode;
        ParentOrStructuredTriviaParent: CSharpSyntaxNode;
        CsGreen: Syntax.InternalSyntax.CSharpSyntaxNode;
        Kind: SyntaxKind;
        CSharpKind(): SyntaxKind;
        KindText: string;
        Language: string;
        HasErrors: boolean;
        private HasErrorsSlow();
        GetLeadingTrivia(): SyntaxTriviaList;
        GetTrailingTrivia(): SyntaxTriviaList;
        Location: Location;
        ToString(): string;
        ToFullString(): string;
        WriteTo(writer: System.IO.TextWriter): void;
        private static defaultBinder;
        SerializeTo(stream: System.IO.Stream, cancellationToken?: System.Threading.CancellationToken): void;
        static DeserializeFrom(stream: System.IO.Stream, cancellationToken?: System.Threading.CancellationToken): SyntaxNode;
        private static defaultObjectWriterData;
        private static GetDefaultObjectWriterData();
        private static defaultObjectReaderData;
        private static GetDefaultObjectReaderData();
        private static serializationData;
        private static GetSerializationData();
        IsEquivalentTo(other: CSharpSyntaxNode): boolean;
        GetLocation(): Location;
        GetReference(): SyntaxReference;
        GetDiagnostics(): System.Collections.Generic.IEnumerable<Diagnostic>;
        GetDirectives(filter?: (_: Syntax.DirectiveTriviaSyntax) => boolean): System.Collections.Generic.IList<Syntax.DirectiveTriviaSyntax>;
        GetFirstDirective(predicate?: (_: Syntax.DirectiveTriviaSyntax) => boolean): Syntax.DirectiveTriviaSyntax;
        GetLastDirective(predicate?: (_: Syntax.DirectiveTriviaSyntax) => boolean): Syntax.DirectiveTriviaSyntax;
        ChildThatContainsPosition(position: number): SyntaxNodeOrToken;
        GetFirstToken_1962(includeZeroWidth?: boolean, includeSkipped?: boolean, includeDirectives?: boolean, includeDocumentationComments?: boolean): SyntaxToken;
        GetFirstToken_1039(predicate: (_: SyntaxToken) => boolean, stepInto?: (_: SyntaxTrivia) => boolean): SyntaxToken;
        GetLastToken(includeZeroWidth?: boolean, includeSkipped?: boolean, includeDirectives?: boolean, includeDocumentationComments?: boolean): SyntaxToken;
        FindTokenInternal(position: number): SyntaxToken;
        private FindToken_4481(position, findInsideTrivia);
        private static GetTriviaFromSyntaxToken(position, token);
        private TryGetEofAt(position, Eof);
        FindToken_1444(position: number, findInsideTrivia?: boolean): SyntaxToken;
        FindTokenIncludingCrefAndNameAttributes(position: number): SyntaxToken;
        static GetTriviaThatContainsPosition(list: SyntaxTriviaList, position: number): SyntaxTrivia;
        FindTrivia_1548(position: number, stepInto: (_: SyntaxTrivia) => boolean): SyntaxTrivia;
        FindTrivia_1737(position: number, findInsideTrivia?: boolean): SyntaxTrivia;
        static FindTriviaByOffset(node: SyntaxNode, textOffset: number, stepInto?: (_: SyntaxTrivia) => boolean): SyntaxTrivia;
        EquivalentToCore(other: SyntaxNode): boolean;
        SyntaxTreeCore: SyntaxTree;
        FindTokenCore_1334(position: number, findInsideTrivia: boolean): SyntaxToken;
        FindTokenCore_1204(position: number, stepInto: (_: SyntaxTrivia) => boolean): SyntaxToken;
        FindTriviaCore(position: number, findInsideTrivia: boolean): SyntaxTrivia;
        ReplaceCore<TNode extends SyntaxNode>(nodes?: System.Collections.Generic.IEnumerable<TNode>, computeReplacementNode?: (_: TNode, __: TNode) => SyntaxNode, tokens?: System.Collections.Generic.IEnumerable<SyntaxToken>, computeReplacementToken?: (_: SyntaxToken, __: SyntaxToken) => SyntaxToken, trivia?: System.Collections.Generic.IEnumerable<SyntaxTrivia>, computeReplacementTrivia?: (_: SyntaxTrivia, __: SyntaxTrivia) => SyntaxTrivia): SyntaxNode;
        ReplaceNodeInListCore(originalNode: SyntaxNode, replacementNodes: System.Collections.Generic.IEnumerable<SyntaxNode>): SyntaxNode;
        InsertNodesInListCore(nodeInList: SyntaxNode, nodesToInsert: System.Collections.Generic.IEnumerable<SyntaxNode>, insertBefore: boolean): SyntaxNode;
        ReplaceTokenInListCore(originalToken: SyntaxToken, newTokens: System.Collections.Generic.IEnumerable<SyntaxToken>): SyntaxNode;
        InsertTokensInListCore(originalToken: SyntaxToken, newTokens: System.Collections.Generic.IEnumerable<SyntaxToken>, insertBefore: boolean): SyntaxNode;
        ReplaceTriviaInListCore(originalTrivia: SyntaxTrivia, newTrivia: System.Collections.Generic.IEnumerable<SyntaxTrivia>): SyntaxNode;
        InsertTriviaInListCore(originalTrivia: SyntaxTrivia, newTrivia: System.Collections.Generic.IEnumerable<SyntaxTrivia>, insertBefore: boolean): SyntaxNode;
        RemoveNodesCore(nodes: System.Collections.Generic.IEnumerable<SyntaxNode>, options: SyntaxRemoveOptions): SyntaxNode;
        NormalizeWhitespaceCore(indentation: string, elasticTrivia: boolean): SyntaxNode;
        IsEquivalentToCore(node: SyntaxNode, topLevel?: boolean): boolean;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class StructuredTriviaSyntax extends CSharpSyntaxNode implements IStructuredTriviaSyntax {
        private parent1;
        ctor_1526(green: Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): StructuredTriviaSyntax;
        static Create(trivia: SyntaxTrivia): StructuredTriviaSyntax;
        ParentTrivia: SyntaxTrivia;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class DirectiveTriviaSyntax extends StructuredTriviaSyntax {
        DirectiveNameToken: SyntaxToken;
        GetNextDirective(predicate?: (_: DirectiveTriviaSyntax) => boolean): DirectiveTriviaSyntax;
        GetPreviousDirective(predicate?: (_: DirectiveTriviaSyntax) => boolean): DirectiveTriviaSyntax;
        GetRelatedDirectives_6891(): System.Collections.Generic.List<DirectiveTriviaSyntax>;
        private GetRelatedDirectives_1976(list);
        private GetNextRelatedDirective();
        private GetNextPossiblyRelatedDirective();
        private GetPreviousRelatedDirective();
        private GetPreviousPossiblyRelatedDirective();
        private static hasDirectivesFunction;
        ctor_1345(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): DirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class ExpressionSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1263(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ExpressionSyntax;
    }
    class TypeSyntax extends ExpressionSyntax {
        constructor();
        ctor_2045(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TypeSyntax;
    }
    class MemberDeclarationSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_7461(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): MemberDeclarationSyntax;
    }
    class NameSyntax extends TypeSyntax {
        constructor();
        ctor_1543(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): NameSyntax;
    }
    class SimpleNameSyntax extends NameSyntax {
        constructor();
        ctor_1962(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): SimpleNameSyntax;
        Identifier: SyntaxToken;
    }
    class IdentifierNameSyntax extends SimpleNameSyntax {
        constructor();
        ctor_1588(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): IdentifierNameSyntax;
        Identifier: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(identifier: SyntaxToken): IdentifierNameSyntax;
        WithIdentifier(identifier: SyntaxToken): IdentifierNameSyntax;
    }
    class QualifiedNameSyntax extends NameSyntax {
        private left;
        private right;
        constructor();
        ctor_5378(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): QualifiedNameSyntax;
        Left: NameSyntax;
        DotToken: SyntaxToken;
        Right: SimpleNameSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax): QualifiedNameSyntax;
        WithLeft(left: NameSyntax): QualifiedNameSyntax;
        WithDotToken(dotToken: SyntaxToken): QualifiedNameSyntax;
        WithRight(right: SimpleNameSyntax): QualifiedNameSyntax;
    }
    class GenericNameSyntax extends SimpleNameSyntax {
        private typeArgumentList;
        constructor();
        ctor_1471(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): GenericNameSyntax;
        Identifier: SyntaxToken;
        TypeArgumentList: TypeArgumentListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax): GenericNameSyntax;
        WithIdentifier(identifier: SyntaxToken): GenericNameSyntax;
        WithTypeArgumentList(typeArgumentList: TypeArgumentListSyntax): GenericNameSyntax;
        AddTypeArgumentListArguments(...items: TypeSyntax[]): GenericNameSyntax;
    }
    class TypeArgumentListSyntax extends CSharpSyntaxNode {
        private arguments;
        constructor();
        ctor_1247(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TypeArgumentListSyntax;
        LessThanToken: SyntaxToken;
        Arguments: SeparatedSyntaxList<TypeSyntax>;
        GreaterThanToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanToken: SyntaxToken, arguments: SeparatedSyntaxList<TypeSyntax>, greaterThanToken: SyntaxToken): TypeArgumentListSyntax;
        WithLessThanToken(lessThanToken: SyntaxToken): TypeArgumentListSyntax;
        WithArguments(arguments: SeparatedSyntaxList<TypeSyntax>): TypeArgumentListSyntax;
        WithGreaterThanToken(greaterThanToken: SyntaxToken): TypeArgumentListSyntax;
        AddArguments(...items: TypeSyntax[]): TypeArgumentListSyntax;
    }
    class AliasQualifiedNameSyntax extends NameSyntax {
        private alias;
        private name;
        constructor();
        ctor_1535(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AliasQualifiedNameSyntax;
        Alias: IdentifierNameSyntax;
        ColonColonToken: SyntaxToken;
        Name: SimpleNameSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax): AliasQualifiedNameSyntax;
        WithAlias(alias: IdentifierNameSyntax): AliasQualifiedNameSyntax;
        WithColonColonToken(colonColonToken: SyntaxToken): AliasQualifiedNameSyntax;
        WithName(name: SimpleNameSyntax): AliasQualifiedNameSyntax;
    }
    class PredefinedTypeSyntax extends TypeSyntax {
        constructor();
        ctor_1442(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): PredefinedTypeSyntax;
        Keyword: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken): PredefinedTypeSyntax;
        WithKeyword(keyword: SyntaxToken): PredefinedTypeSyntax;
    }
    class ArrayTypeSyntax extends TypeSyntax {
        private elementType;
        private rankSpecifiers;
        constructor();
        ctor_4307(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ArrayTypeSyntax;
        ElementType: TypeSyntax;
        RankSpecifiers: SyntaxList<ArrayRankSpecifierSyntax>;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(elementType: TypeSyntax, rankSpecifiers: SyntaxList<ArrayRankSpecifierSyntax>): ArrayTypeSyntax;
        WithElementType(elementType: TypeSyntax): ArrayTypeSyntax;
        WithRankSpecifiers(rankSpecifiers: SyntaxList<ArrayRankSpecifierSyntax>): ArrayTypeSyntax;
        AddRankSpecifiers(...items: ArrayRankSpecifierSyntax[]): ArrayTypeSyntax;
    }
    class ArrayRankSpecifierSyntax extends CSharpSyntaxNode {
        private sizes;
        constructor();
        ctor_5824(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ArrayRankSpecifierSyntax;
        OpenBracketToken: SyntaxToken;
        Sizes: SeparatedSyntaxList<ExpressionSyntax>;
        CloseBracketToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBracketToken: SyntaxToken, sizes: SeparatedSyntaxList<ExpressionSyntax>, closeBracketToken: SyntaxToken): ArrayRankSpecifierSyntax;
        WithOpenBracketToken(openBracketToken: SyntaxToken): ArrayRankSpecifierSyntax;
        WithSizes(sizes: SeparatedSyntaxList<ExpressionSyntax>): ArrayRankSpecifierSyntax;
        WithCloseBracketToken(closeBracketToken: SyntaxToken): ArrayRankSpecifierSyntax;
        AddSizes(...items: ExpressionSyntax[]): ArrayRankSpecifierSyntax;
    }
    class PointerTypeSyntax extends TypeSyntax {
        private elementType;
        constructor();
        ctor_6866(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): PointerTypeSyntax;
        ElementType: TypeSyntax;
        AsteriskToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(elementType: TypeSyntax, asteriskToken: SyntaxToken): PointerTypeSyntax;
        WithElementType(elementType: TypeSyntax): PointerTypeSyntax;
        WithAsteriskToken(asteriskToken: SyntaxToken): PointerTypeSyntax;
    }
    class NullableTypeSyntax extends TypeSyntax {
        private elementType;
        constructor();
        ctor_6515(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): NullableTypeSyntax;
        ElementType: TypeSyntax;
        QuestionToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(elementType: TypeSyntax, questionToken: SyntaxToken): NullableTypeSyntax;
        WithElementType(elementType: TypeSyntax): NullableTypeSyntax;
        WithQuestionToken(questionToken: SyntaxToken): NullableTypeSyntax;
    }
    class OmittedTypeArgumentSyntax extends TypeSyntax {
        constructor();
        ctor_5858(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): OmittedTypeArgumentSyntax;
        OmittedTypeArgumentToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(omittedTypeArgumentToken: SyntaxToken): OmittedTypeArgumentSyntax;
        WithOmittedTypeArgumentToken(omittedTypeArgumentToken: SyntaxToken): OmittedTypeArgumentSyntax;
    }
    class ParenthesizedExpressionSyntax extends ExpressionSyntax {
        private expression;
        constructor();
        ctor_2189(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ParenthesizedExpressionSyntax;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): ParenthesizedExpressionSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): ParenthesizedExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): ParenthesizedExpressionSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): ParenthesizedExpressionSyntax;
    }
    class PrefixUnaryExpressionSyntax extends ExpressionSyntax {
        private operand;
        constructor();
        ctor_9916(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): PrefixUnaryExpressionSyntax;
        OperatorToken: SyntaxToken;
        Operand: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(operatorToken: SyntaxToken, operand: ExpressionSyntax): PrefixUnaryExpressionSyntax;
        WithOperatorToken(operatorToken: SyntaxToken): PrefixUnaryExpressionSyntax;
        WithOperand(operand: ExpressionSyntax): PrefixUnaryExpressionSyntax;
    }
    class AwaitExpressionSyntax extends ExpressionSyntax {
        private expression;
        constructor();
        ctor_1769(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AwaitExpressionSyntax;
        AwaitKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(awaitKeyword: SyntaxToken, expression: ExpressionSyntax): AwaitExpressionSyntax;
        WithAwaitKeyword(awaitKeyword: SyntaxToken): AwaitExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): AwaitExpressionSyntax;
    }
    class PostfixUnaryExpressionSyntax extends ExpressionSyntax {
        private operand;
        constructor();
        ctor_8896(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): PostfixUnaryExpressionSyntax;
        Operand: ExpressionSyntax;
        OperatorToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(operand: ExpressionSyntax, operatorToken: SyntaxToken): PostfixUnaryExpressionSyntax;
        WithOperand(operand: ExpressionSyntax): PostfixUnaryExpressionSyntax;
        WithOperatorToken(operatorToken: SyntaxToken): PostfixUnaryExpressionSyntax;
    }
    class MemberAccessExpressionSyntax extends ExpressionSyntax {
        private expression;
        private name;
        constructor();
        ctor_3326(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): MemberAccessExpressionSyntax;
        Expression: ExpressionSyntax;
        OperatorToken: SyntaxToken;
        Name: SimpleNameSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberAccessExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): MemberAccessExpressionSyntax;
        WithOperatorToken(operatorToken: SyntaxToken): MemberAccessExpressionSyntax;
        WithName(name: SimpleNameSyntax): MemberAccessExpressionSyntax;
    }
    class ConditionalAccessExpressionSyntax extends ExpressionSyntax {
        private expression;
        private whenNotNull;
        constructor();
        ctor_1030(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ConditionalAccessExpressionSyntax;
        Expression: ExpressionSyntax;
        OperatorToken: SyntaxToken;
        WhenNotNull: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax): ConditionalAccessExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): ConditionalAccessExpressionSyntax;
        WithOperatorToken(operatorToken: SyntaxToken): ConditionalAccessExpressionSyntax;
        WithWhenNotNull(whenNotNull: ExpressionSyntax): ConditionalAccessExpressionSyntax;
    }
    class MemberBindingExpressionSyntax extends ExpressionSyntax {
        private name;
        constructor();
        ctor_1286(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): MemberBindingExpressionSyntax;
        OperatorToken: SyntaxToken;
        Name: SimpleNameSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberBindingExpressionSyntax;
        WithOperatorToken(operatorToken: SyntaxToken): MemberBindingExpressionSyntax;
        WithName(name: SimpleNameSyntax): MemberBindingExpressionSyntax;
    }
    class ElementBindingExpressionSyntax extends ExpressionSyntax {
        private argumentList;
        constructor();
        ctor_2138(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ElementBindingExpressionSyntax;
        ArgumentList: BracketedArgumentListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(argumentList: BracketedArgumentListSyntax): ElementBindingExpressionSyntax;
        WithArgumentList(argumentList: BracketedArgumentListSyntax): ElementBindingExpressionSyntax;
        AddArgumentListArguments(...items: ArgumentSyntax[]): ElementBindingExpressionSyntax;
    }
    class ImplicitElementAccessSyntax extends ExpressionSyntax {
        private argumentList;
        constructor();
        ctor_5704(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ImplicitElementAccessSyntax;
        ArgumentList: BracketedArgumentListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(argumentList: BracketedArgumentListSyntax): ImplicitElementAccessSyntax;
        WithArgumentList(argumentList: BracketedArgumentListSyntax): ImplicitElementAccessSyntax;
        AddArgumentListArguments(...items: ArgumentSyntax[]): ImplicitElementAccessSyntax;
    }
    class BinaryExpressionSyntax extends ExpressionSyntax {
        private left;
        private right;
        constructor();
        ctor_5723(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BinaryExpressionSyntax;
        Left: ExpressionSyntax;
        OperatorToken: SyntaxToken;
        Right: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): BinaryExpressionSyntax;
        WithLeft(left: ExpressionSyntax): BinaryExpressionSyntax;
        WithOperatorToken(operatorToken: SyntaxToken): BinaryExpressionSyntax;
        WithRight(right: ExpressionSyntax): BinaryExpressionSyntax;
    }
    class AssignmentExpressionSyntax extends ExpressionSyntax {
        private left;
        private right;
        constructor();
        ctor_1006(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AssignmentExpressionSyntax;
        Left: ExpressionSyntax;
        OperatorToken: SyntaxToken;
        Right: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): AssignmentExpressionSyntax;
        WithLeft(left: ExpressionSyntax): AssignmentExpressionSyntax;
        WithOperatorToken(operatorToken: SyntaxToken): AssignmentExpressionSyntax;
        WithRight(right: ExpressionSyntax): AssignmentExpressionSyntax;
    }
    class ConditionalExpressionSyntax extends ExpressionSyntax {
        private condition;
        private whenTrue;
        private whenFalse;
        constructor();
        ctor_1071(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ConditionalExpressionSyntax;
        Condition: ExpressionSyntax;
        QuestionToken: SyntaxToken;
        WhenTrue: ExpressionSyntax;
        ColonToken: SyntaxToken;
        WhenFalse: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax): ConditionalExpressionSyntax;
        WithCondition(condition: ExpressionSyntax): ConditionalExpressionSyntax;
        WithQuestionToken(questionToken: SyntaxToken): ConditionalExpressionSyntax;
        WithWhenTrue(whenTrue: ExpressionSyntax): ConditionalExpressionSyntax;
        WithColonToken(colonToken: SyntaxToken): ConditionalExpressionSyntax;
        WithWhenFalse(whenFalse: ExpressionSyntax): ConditionalExpressionSyntax;
    }
    class InstanceExpressionSyntax extends ExpressionSyntax {
        constructor();
        ctor_2961(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): InstanceExpressionSyntax;
    }
    class ThisExpressionSyntax extends InstanceExpressionSyntax {
        constructor();
        ctor_9095(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ThisExpressionSyntax;
        Token: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(token: SyntaxToken): ThisExpressionSyntax;
        WithToken(token: SyntaxToken): ThisExpressionSyntax;
    }
    class BaseExpressionSyntax extends InstanceExpressionSyntax {
        constructor();
        ctor_8798(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BaseExpressionSyntax;
        Token: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(token: SyntaxToken): BaseExpressionSyntax;
        WithToken(token: SyntaxToken): BaseExpressionSyntax;
    }
    class LiteralExpressionSyntax extends ExpressionSyntax {
        constructor();
        ctor_1907(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): LiteralExpressionSyntax;
        Token: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(token: SyntaxToken): LiteralExpressionSyntax;
        WithToken(token: SyntaxToken): LiteralExpressionSyntax;
    }
    class MakeRefExpressionSyntax extends ExpressionSyntax {
        private expression;
        constructor();
        ctor_6904(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): MakeRefExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): MakeRefExpressionSyntax;
        WithKeyword(keyword: SyntaxToken): MakeRefExpressionSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): MakeRefExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): MakeRefExpressionSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): MakeRefExpressionSyntax;
    }
    class RefTypeExpressionSyntax extends ExpressionSyntax {
        private expression;
        constructor();
        ctor_1551(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): RefTypeExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): RefTypeExpressionSyntax;
        WithKeyword(keyword: SyntaxToken): RefTypeExpressionSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): RefTypeExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): RefTypeExpressionSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): RefTypeExpressionSyntax;
    }
    class RefValueExpressionSyntax extends ExpressionSyntax {
        private expression;
        private type;
        constructor();
        ctor_1590(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): RefValueExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        Comma: SyntaxToken;
        Type: TypeSyntax;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): RefValueExpressionSyntax;
        WithKeyword(keyword: SyntaxToken): RefValueExpressionSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): RefValueExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): RefValueExpressionSyntax;
        WithComma(comma: SyntaxToken): RefValueExpressionSyntax;
        WithType(type: TypeSyntax): RefValueExpressionSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): RefValueExpressionSyntax;
    }
    class CheckedExpressionSyntax extends ExpressionSyntax {
        private expression;
        constructor();
        ctor_5940(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CheckedExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): CheckedExpressionSyntax;
        WithKeyword(keyword: SyntaxToken): CheckedExpressionSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): CheckedExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): CheckedExpressionSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): CheckedExpressionSyntax;
    }
    class DefaultExpressionSyntax extends ExpressionSyntax {
        private type;
        constructor();
        ctor_2428(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): DefaultExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): DefaultExpressionSyntax;
        WithKeyword(keyword: SyntaxToken): DefaultExpressionSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): DefaultExpressionSyntax;
        WithType(type: TypeSyntax): DefaultExpressionSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): DefaultExpressionSyntax;
    }
    class TypeOfExpressionSyntax extends ExpressionSyntax {
        private type;
        constructor();
        ctor_2097(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TypeOfExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): TypeOfExpressionSyntax;
        WithKeyword(keyword: SyntaxToken): TypeOfExpressionSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): TypeOfExpressionSyntax;
        WithType(type: TypeSyntax): TypeOfExpressionSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): TypeOfExpressionSyntax;
    }
    class SizeOfExpressionSyntax extends ExpressionSyntax {
        private type;
        constructor();
        ctor_1207(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): SizeOfExpressionSyntax;
        Keyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): SizeOfExpressionSyntax;
        WithKeyword(keyword: SyntaxToken): SizeOfExpressionSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): SizeOfExpressionSyntax;
        WithType(type: TypeSyntax): SizeOfExpressionSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): SizeOfExpressionSyntax;
    }
    class InvocationExpressionSyntax extends ExpressionSyntax {
        private expression;
        private argumentList;
        constructor();
        ctor_1641(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): InvocationExpressionSyntax;
        Expression: ExpressionSyntax;
        ArgumentList: ArgumentListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): InvocationExpressionSyntax;
        WithArgumentList(argumentList: ArgumentListSyntax): InvocationExpressionSyntax;
        AddArgumentListArguments(...items: ArgumentSyntax[]): InvocationExpressionSyntax;
    }
    class ElementAccessExpressionSyntax extends ExpressionSyntax {
        private expression;
        private argumentList;
        constructor();
        ctor_1611(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ElementAccessExpressionSyntax;
        Expression: ExpressionSyntax;
        ArgumentList: BracketedArgumentListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax): ElementAccessExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): ElementAccessExpressionSyntax;
        WithArgumentList(argumentList: BracketedArgumentListSyntax): ElementAccessExpressionSyntax;
        AddArgumentListArguments(...items: ArgumentSyntax[]): ElementAccessExpressionSyntax;
    }
    class BaseArgumentListSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1139(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BaseArgumentListSyntax;
        Arguments: SeparatedSyntaxList<ArgumentSyntax>;
    }
    class ArgumentListSyntax extends BaseArgumentListSyntax {
        private arguments;
        constructor();
        ctor_1575(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ArgumentListSyntax;
        OpenParenToken: SyntaxToken;
        Arguments: SeparatedSyntaxList<ArgumentSyntax>;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, arguments: SeparatedSyntaxList<ArgumentSyntax>, closeParenToken: SyntaxToken): ArgumentListSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): ArgumentListSyntax;
        WithArguments(arguments: SeparatedSyntaxList<ArgumentSyntax>): ArgumentListSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): ArgumentListSyntax;
        AddArguments(...items: ArgumentSyntax[]): ArgumentListSyntax;
    }
    class BracketedArgumentListSyntax extends BaseArgumentListSyntax {
        private arguments;
        constructor();
        ctor_2085(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BracketedArgumentListSyntax;
        OpenBracketToken: SyntaxToken;
        Arguments: SeparatedSyntaxList<ArgumentSyntax>;
        CloseBracketToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBracketToken: SyntaxToken, arguments: SeparatedSyntaxList<ArgumentSyntax>, closeBracketToken: SyntaxToken): BracketedArgumentListSyntax;
        WithOpenBracketToken(openBracketToken: SyntaxToken): BracketedArgumentListSyntax;
        WithArguments(arguments: SeparatedSyntaxList<ArgumentSyntax>): BracketedArgumentListSyntax;
        WithCloseBracketToken(closeBracketToken: SyntaxToken): BracketedArgumentListSyntax;
        AddArguments(...items: ArgumentSyntax[]): BracketedArgumentListSyntax;
    }
    class ArgumentSyntax extends CSharpSyntaxNode {
        private nameColon;
        private expression;
        constructor();
        ctor_7616(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ArgumentSyntax;
        NameColon: NameColonSyntax;
        RefOrOutKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax): ArgumentSyntax;
        WithNameColon(nameColon: NameColonSyntax): ArgumentSyntax;
        WithRefOrOutKeyword(refOrOutKeyword: SyntaxToken): ArgumentSyntax;
        WithExpression(expression: ExpressionSyntax): ArgumentSyntax;
    }
    class NameColonSyntax extends CSharpSyntaxNode {
        private name;
        constructor();
        ctor_6392(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): NameColonSyntax;
        Name: IdentifierNameSyntax;
        ColonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: IdentifierNameSyntax, colonToken: SyntaxToken): NameColonSyntax;
        WithName(name: IdentifierNameSyntax): NameColonSyntax;
        WithColonToken(colonToken: SyntaxToken): NameColonSyntax;
    }
    class CastExpressionSyntax extends ExpressionSyntax {
        private type;
        private expression;
        constructor();
        ctor_2030(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CastExpressionSyntax;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        CloseParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax): CastExpressionSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): CastExpressionSyntax;
        WithType(type: TypeSyntax): CastExpressionSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): CastExpressionSyntax;
        WithExpression(expression: ExpressionSyntax): CastExpressionSyntax;
    }
    class AnonymousMethodExpressionSyntax extends ExpressionSyntax {
        private parameterList;
        private block;
        constructor();
        ctor_7841(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AnonymousMethodExpressionSyntax;
        AsyncKeyword: SyntaxToken;
        DelegateKeyword: SyntaxToken;
        ParameterList: ParameterListSyntax;
        Block: BlockSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): AnonymousMethodExpressionSyntax;
        WithAsyncKeyword(asyncKeyword: SyntaxToken): AnonymousMethodExpressionSyntax;
        WithDelegateKeyword(delegateKeyword: SyntaxToken): AnonymousMethodExpressionSyntax;
        WithParameterList(parameterList: ParameterListSyntax): AnonymousMethodExpressionSyntax;
        WithBlock(block: BlockSyntax): AnonymousMethodExpressionSyntax;
        AddParameterListParameters(...items: ParameterSyntax[]): AnonymousMethodExpressionSyntax;
        AddBlockStatements(...items: StatementSyntax[]): AnonymousMethodExpressionSyntax;
    }
    class SimpleLambdaExpressionSyntax extends ExpressionSyntax {
        private parameter;
        private body;
        constructor();
        ctor_1697(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): SimpleLambdaExpressionSyntax;
        AsyncKeyword: SyntaxToken;
        Parameter: ParameterSyntax;
        ArrowToken: SyntaxToken;
        Body: CSharpSyntaxNode;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): SimpleLambdaExpressionSyntax;
        WithAsyncKeyword(asyncKeyword: SyntaxToken): SimpleLambdaExpressionSyntax;
        WithParameter(parameter: ParameterSyntax): SimpleLambdaExpressionSyntax;
        WithArrowToken(arrowToken: SyntaxToken): SimpleLambdaExpressionSyntax;
        WithBody(body: CSharpSyntaxNode): SimpleLambdaExpressionSyntax;
        AddParameterAttributeLists(...items: AttributeListSyntax[]): SimpleLambdaExpressionSyntax;
        AddParameterModifiers(...items: SyntaxToken[]): SimpleLambdaExpressionSyntax;
    }
    class ParenthesizedLambdaExpressionSyntax extends ExpressionSyntax {
        private parameterList;
        private body;
        constructor();
        ctor_1854(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ParenthesizedLambdaExpressionSyntax;
        AsyncKeyword: SyntaxToken;
        ParameterList: ParameterListSyntax;
        ArrowToken: SyntaxToken;
        Body: CSharpSyntaxNode;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): ParenthesizedLambdaExpressionSyntax;
        WithAsyncKeyword(asyncKeyword: SyntaxToken): ParenthesizedLambdaExpressionSyntax;
        WithParameterList(parameterList: ParameterListSyntax): ParenthesizedLambdaExpressionSyntax;
        WithArrowToken(arrowToken: SyntaxToken): ParenthesizedLambdaExpressionSyntax;
        WithBody(body: CSharpSyntaxNode): ParenthesizedLambdaExpressionSyntax;
        AddParameterListParameters(...items: ParameterSyntax[]): ParenthesizedLambdaExpressionSyntax;
    }
    class InitializerExpressionSyntax extends ExpressionSyntax {
        private expressions;
        constructor();
        ctor_9252(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): InitializerExpressionSyntax;
        OpenBraceToken: SyntaxToken;
        Expressions: SeparatedSyntaxList<ExpressionSyntax>;
        CloseBraceToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBraceToken: SyntaxToken, expressions: SeparatedSyntaxList<ExpressionSyntax>, closeBraceToken: SyntaxToken): InitializerExpressionSyntax;
        WithOpenBraceToken(openBraceToken: SyntaxToken): InitializerExpressionSyntax;
        WithExpressions(expressions: SeparatedSyntaxList<ExpressionSyntax>): InitializerExpressionSyntax;
        WithCloseBraceToken(closeBraceToken: SyntaxToken): InitializerExpressionSyntax;
        AddExpressions(...items: ExpressionSyntax[]): InitializerExpressionSyntax;
    }
    class ObjectCreationExpressionSyntax extends ExpressionSyntax {
        private type;
        private argumentList;
        private initializer;
        constructor();
        ctor_2065(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ObjectCreationExpressionSyntax;
        NewKeyword: SyntaxToken;
        Type: TypeSyntax;
        ArgumentList: ArgumentListSyntax;
        Initializer: InitializerExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax): ObjectCreationExpressionSyntax;
        WithNewKeyword(newKeyword: SyntaxToken): ObjectCreationExpressionSyntax;
        WithType(type: TypeSyntax): ObjectCreationExpressionSyntax;
        WithArgumentList(argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax;
        WithInitializer(initializer: InitializerExpressionSyntax): ObjectCreationExpressionSyntax;
        AddArgumentListArguments(...items: ArgumentSyntax[]): ObjectCreationExpressionSyntax;
    }
    class AnonymousObjectMemberDeclaratorSyntax extends CSharpSyntaxNode {
        private nameEquals;
        private expression;
        constructor();
        ctor_5348(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AnonymousObjectMemberDeclaratorSyntax;
        NameEquals: NameEqualsSyntax;
        Expression: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(nameEquals: NameEqualsSyntax, expression: ExpressionSyntax): AnonymousObjectMemberDeclaratorSyntax;
        WithNameEquals(nameEquals: NameEqualsSyntax): AnonymousObjectMemberDeclaratorSyntax;
        WithExpression(expression: ExpressionSyntax): AnonymousObjectMemberDeclaratorSyntax;
    }
    class AnonymousObjectCreationExpressionSyntax extends ExpressionSyntax {
        private initializers;
        constructor();
        ctor_1554(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AnonymousObjectCreationExpressionSyntax;
        NewKeyword: SyntaxToken;
        OpenBraceToken: SyntaxToken;
        Initializers: SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>;
        CloseBraceToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>, closeBraceToken: SyntaxToken): AnonymousObjectCreationExpressionSyntax;
        WithNewKeyword(newKeyword: SyntaxToken): AnonymousObjectCreationExpressionSyntax;
        WithOpenBraceToken(openBraceToken: SyntaxToken): AnonymousObjectCreationExpressionSyntax;
        WithInitializers(initializers: SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>): AnonymousObjectCreationExpressionSyntax;
        WithCloseBraceToken(closeBraceToken: SyntaxToken): AnonymousObjectCreationExpressionSyntax;
        AddInitializers(...items: AnonymousObjectMemberDeclaratorSyntax[]): AnonymousObjectCreationExpressionSyntax;
    }
    class ArrayCreationExpressionSyntax extends ExpressionSyntax {
        private type;
        private initializer;
        constructor();
        ctor_4775(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ArrayCreationExpressionSyntax;
        NewKeyword: SyntaxToken;
        Type: ArrayTypeSyntax;
        Initializer: InitializerExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax): ArrayCreationExpressionSyntax;
        WithNewKeyword(newKeyword: SyntaxToken): ArrayCreationExpressionSyntax;
        WithType(type: ArrayTypeSyntax): ArrayCreationExpressionSyntax;
        WithInitializer(initializer: InitializerExpressionSyntax): ArrayCreationExpressionSyntax;
        AddTypeRankSpecifiers(...items: ArrayRankSpecifierSyntax[]): ArrayCreationExpressionSyntax;
    }
    class ImplicitArrayCreationExpressionSyntax extends ExpressionSyntax {
        private initializer;
        constructor();
        ctor_1315(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ImplicitArrayCreationExpressionSyntax;
        NewKeyword: SyntaxToken;
        OpenBracketToken: SyntaxToken;
        Commas: SyntaxTokenList;
        CloseBracketToken: SyntaxToken;
        Initializer: InitializerExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: SyntaxTokenList, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax): ImplicitArrayCreationExpressionSyntax;
        WithNewKeyword(newKeyword: SyntaxToken): ImplicitArrayCreationExpressionSyntax;
        WithOpenBracketToken(openBracketToken: SyntaxToken): ImplicitArrayCreationExpressionSyntax;
        WithCommas(commas: SyntaxTokenList): ImplicitArrayCreationExpressionSyntax;
        WithCloseBracketToken(closeBracketToken: SyntaxToken): ImplicitArrayCreationExpressionSyntax;
        WithInitializer(initializer: InitializerExpressionSyntax): ImplicitArrayCreationExpressionSyntax;
        AddCommas(...items: SyntaxToken[]): ImplicitArrayCreationExpressionSyntax;
        AddInitializerExpressions(...items: ExpressionSyntax[]): ImplicitArrayCreationExpressionSyntax;
    }
    class StackAllocArrayCreationExpressionSyntax extends ExpressionSyntax {
        private type;
        constructor();
        ctor_1350(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): StackAllocArrayCreationExpressionSyntax;
        StackAllocKeyword: SyntaxToken;
        Type: TypeSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(stackAllocKeyword: SyntaxToken, type: TypeSyntax): StackAllocArrayCreationExpressionSyntax;
        WithStackAllocKeyword(stackAllocKeyword: SyntaxToken): StackAllocArrayCreationExpressionSyntax;
        WithType(type: TypeSyntax): StackAllocArrayCreationExpressionSyntax;
    }
    class QueryClauseSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1944(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): QueryClauseSyntax;
    }
    class SelectOrGroupClauseSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_2028(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): SelectOrGroupClauseSyntax;
    }
    class QueryExpressionSyntax extends ExpressionSyntax {
        private fromClause;
        private body;
        constructor();
        ctor_1529(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): QueryExpressionSyntax;
        FromClause: FromClauseSyntax;
        Body: QueryBodySyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(fromClause: FromClauseSyntax, body: QueryBodySyntax): QueryExpressionSyntax;
        WithFromClause(fromClause: FromClauseSyntax): QueryExpressionSyntax;
        WithBody(body: QueryBodySyntax): QueryExpressionSyntax;
        AddBodyClauses(...items: QueryClauseSyntax[]): QueryExpressionSyntax;
    }
    class QueryBodySyntax extends CSharpSyntaxNode {
        private clauses;
        private selectOrGroup;
        private continuation;
        constructor();
        ctor_1968(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): QueryBodySyntax;
        Clauses: SyntaxList<QueryClauseSyntax>;
        SelectOrGroup: SelectOrGroupClauseSyntax;
        Continuation: QueryContinuationSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(clauses: SyntaxList<QueryClauseSyntax>, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax): QueryBodySyntax;
        WithClauses(clauses: SyntaxList<QueryClauseSyntax>): QueryBodySyntax;
        WithSelectOrGroup(selectOrGroup: SelectOrGroupClauseSyntax): QueryBodySyntax;
        WithContinuation(continuation: QueryContinuationSyntax): QueryBodySyntax;
        AddClauses(...items: QueryClauseSyntax[]): QueryBodySyntax;
    }
    class FromClauseSyntax extends QueryClauseSyntax {
        private type;
        private expression;
        constructor();
        ctor_1530(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): FromClauseSyntax;
        FromKeyword: SyntaxToken;
        Type: TypeSyntax;
        Identifier: SyntaxToken;
        InKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax): FromClauseSyntax;
        WithFromKeyword(fromKeyword: SyntaxToken): FromClauseSyntax;
        WithType(type: TypeSyntax): FromClauseSyntax;
        WithIdentifier(identifier: SyntaxToken): FromClauseSyntax;
        WithInKeyword(inKeyword: SyntaxToken): FromClauseSyntax;
        WithExpression(expression: ExpressionSyntax): FromClauseSyntax;
    }
    class LetClauseSyntax extends QueryClauseSyntax {
        private expression;
        constructor();
        ctor_7080(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): LetClauseSyntax;
        LetKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        EqualsToken: SyntaxToken;
        Expression: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax): LetClauseSyntax;
        WithLetKeyword(letKeyword: SyntaxToken): LetClauseSyntax;
        WithIdentifier(identifier: SyntaxToken): LetClauseSyntax;
        WithEqualsToken(equalsToken: SyntaxToken): LetClauseSyntax;
        WithExpression(expression: ExpressionSyntax): LetClauseSyntax;
    }
    class JoinClauseSyntax extends QueryClauseSyntax {
        private type;
        private inExpression;
        private leftExpression;
        private rightExpression;
        private into;
        constructor();
        ctor_1474(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): JoinClauseSyntax;
        JoinKeyword: SyntaxToken;
        Type: TypeSyntax;
        Identifier: SyntaxToken;
        InKeyword: SyntaxToken;
        InExpression: ExpressionSyntax;
        OnKeyword: SyntaxToken;
        LeftExpression: ExpressionSyntax;
        EqualsKeyword: SyntaxToken;
        RightExpression: ExpressionSyntax;
        Into: JoinIntoClauseSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax): JoinClauseSyntax;
        WithJoinKeyword(joinKeyword: SyntaxToken): JoinClauseSyntax;
        WithType(type: TypeSyntax): JoinClauseSyntax;
        WithIdentifier(identifier: SyntaxToken): JoinClauseSyntax;
        WithInKeyword(inKeyword: SyntaxToken): JoinClauseSyntax;
        WithInExpression(inExpression: ExpressionSyntax): JoinClauseSyntax;
        WithOnKeyword(onKeyword: SyntaxToken): JoinClauseSyntax;
        WithLeftExpression(leftExpression: ExpressionSyntax): JoinClauseSyntax;
        WithEqualsKeyword(equalsKeyword: SyntaxToken): JoinClauseSyntax;
        WithRightExpression(rightExpression: ExpressionSyntax): JoinClauseSyntax;
        WithInto(into: JoinIntoClauseSyntax): JoinClauseSyntax;
    }
    class JoinIntoClauseSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_3874(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): JoinIntoClauseSyntax;
        IntoKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(intoKeyword: SyntaxToken, identifier: SyntaxToken): JoinIntoClauseSyntax;
        WithIntoKeyword(intoKeyword: SyntaxToken): JoinIntoClauseSyntax;
        WithIdentifier(identifier: SyntaxToken): JoinIntoClauseSyntax;
    }
    class WhereClauseSyntax extends QueryClauseSyntax {
        private condition;
        constructor();
        ctor_6964(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): WhereClauseSyntax;
        WhereKeyword: SyntaxToken;
        Condition: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(whereKeyword: SyntaxToken, condition: ExpressionSyntax): WhereClauseSyntax;
        WithWhereKeyword(whereKeyword: SyntaxToken): WhereClauseSyntax;
        WithCondition(condition: ExpressionSyntax): WhereClauseSyntax;
    }
    class OrderByClauseSyntax extends QueryClauseSyntax {
        private orderings;
        constructor();
        ctor_7165(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): OrderByClauseSyntax;
        OrderByKeyword: SyntaxToken;
        Orderings: SeparatedSyntaxList<OrderingSyntax>;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(orderByKeyword: SyntaxToken, orderings: SeparatedSyntaxList<OrderingSyntax>): OrderByClauseSyntax;
        WithOrderByKeyword(orderByKeyword: SyntaxToken): OrderByClauseSyntax;
        WithOrderings(orderings: SeparatedSyntaxList<OrderingSyntax>): OrderByClauseSyntax;
        AddOrderings(...items: OrderingSyntax[]): OrderByClauseSyntax;
    }
    class OrderingSyntax extends CSharpSyntaxNode {
        private expression;
        constructor();
        ctor_1222(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): OrderingSyntax;
        Expression: ExpressionSyntax;
        AscendingOrDescendingKeyword: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken): OrderingSyntax;
        WithExpression(expression: ExpressionSyntax): OrderingSyntax;
        WithAscendingOrDescendingKeyword(ascendingOrDescendingKeyword: SyntaxToken): OrderingSyntax;
    }
    class SelectClauseSyntax extends SelectOrGroupClauseSyntax {
        private expression;
        constructor();
        ctor_2370(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): SelectClauseSyntax;
        SelectKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(selectKeyword: SyntaxToken, expression: ExpressionSyntax): SelectClauseSyntax;
        WithSelectKeyword(selectKeyword: SyntaxToken): SelectClauseSyntax;
        WithExpression(expression: ExpressionSyntax): SelectClauseSyntax;
    }
    class GroupClauseSyntax extends SelectOrGroupClauseSyntax {
        private groupExpression;
        private byExpression;
        constructor();
        ctor_3745(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): GroupClauseSyntax;
        GroupKeyword: SyntaxToken;
        GroupExpression: ExpressionSyntax;
        ByKeyword: SyntaxToken;
        ByExpression: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax): GroupClauseSyntax;
        WithGroupKeyword(groupKeyword: SyntaxToken): GroupClauseSyntax;
        WithGroupExpression(groupExpression: ExpressionSyntax): GroupClauseSyntax;
        WithByKeyword(byKeyword: SyntaxToken): GroupClauseSyntax;
        WithByExpression(byExpression: ExpressionSyntax): GroupClauseSyntax;
    }
    class QueryContinuationSyntax extends CSharpSyntaxNode {
        private body;
        constructor();
        ctor_9699(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): QueryContinuationSyntax;
        IntoKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        Body: QueryBodySyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax): QueryContinuationSyntax;
        WithIntoKeyword(intoKeyword: SyntaxToken): QueryContinuationSyntax;
        WithIdentifier(identifier: SyntaxToken): QueryContinuationSyntax;
        WithBody(body: QueryBodySyntax): QueryContinuationSyntax;
        AddBodyClauses(...items: QueryClauseSyntax[]): QueryContinuationSyntax;
    }
    class OmittedArraySizeExpressionSyntax extends ExpressionSyntax {
        constructor();
        ctor_1950(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): OmittedArraySizeExpressionSyntax;
        OmittedArraySizeExpressionToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(omittedArraySizeExpressionToken: SyntaxToken): OmittedArraySizeExpressionSyntax;
        WithOmittedArraySizeExpressionToken(omittedArraySizeExpressionToken: SyntaxToken): OmittedArraySizeExpressionSyntax;
    }
    class GlobalStatementSyntax extends MemberDeclarationSyntax {
        private statement;
        constructor();
        ctor_1315(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): GlobalStatementSyntax;
        Statement: StatementSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(statement: StatementSyntax): GlobalStatementSyntax;
        WithStatement(statement: StatementSyntax): GlobalStatementSyntax;
    }
    class StatementSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_9341(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): StatementSyntax;
    }
    class BlockSyntax extends StatementSyntax {
        private statements;
        constructor();
        ctor_2388(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BlockSyntax;
        OpenBraceToken: SyntaxToken;
        Statements: SyntaxList<StatementSyntax>;
        CloseBraceToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBraceToken: SyntaxToken, statements: SyntaxList<StatementSyntax>, closeBraceToken: SyntaxToken): BlockSyntax;
        WithOpenBraceToken(openBraceToken: SyntaxToken): BlockSyntax;
        WithStatements(statements: SyntaxList<StatementSyntax>): BlockSyntax;
        WithCloseBraceToken(closeBraceToken: SyntaxToken): BlockSyntax;
        AddStatements(...items: StatementSyntax[]): BlockSyntax;
    }
    class LocalDeclarationStatementSyntax extends StatementSyntax {
        private declaration;
        constructor();
        ctor_1590(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): LocalDeclarationStatementSyntax;
        Modifiers: SyntaxTokenList;
        Declaration: VariableDeclarationSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(modifiers: SyntaxTokenList, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): LocalDeclarationStatementSyntax;
        WithModifiers(modifiers: SyntaxTokenList): LocalDeclarationStatementSyntax;
        WithDeclaration(declaration: VariableDeclarationSyntax): LocalDeclarationStatementSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): LocalDeclarationStatementSyntax;
        AddModifiers(...items: SyntaxToken[]): LocalDeclarationStatementSyntax;
        AddDeclarationVariables(...items: VariableDeclaratorSyntax[]): LocalDeclarationStatementSyntax;
    }
    class VariableDeclarationSyntax extends CSharpSyntaxNode {
        private type;
        private variables;
        constructor();
        ctor_3026(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): VariableDeclarationSyntax;
        Type: TypeSyntax;
        Variables: SeparatedSyntaxList<VariableDeclaratorSyntax>;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(type: TypeSyntax, variables: SeparatedSyntaxList<VariableDeclaratorSyntax>): VariableDeclarationSyntax;
        WithType(type: TypeSyntax): VariableDeclarationSyntax;
        WithVariables(variables: SeparatedSyntaxList<VariableDeclaratorSyntax>): VariableDeclarationSyntax;
        AddVariables(...items: VariableDeclaratorSyntax[]): VariableDeclarationSyntax;
    }
    class VariableDeclaratorSyntax extends CSharpSyntaxNode {
        private argumentList;
        private initializer;
        constructor();
        ctor_1406(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): VariableDeclaratorSyntax;
        Identifier: SyntaxToken;
        ArgumentList: BracketedArgumentListSyntax;
        Initializer: EqualsValueClauseSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax): VariableDeclaratorSyntax;
        WithIdentifier(identifier: SyntaxToken): VariableDeclaratorSyntax;
        WithArgumentList(argumentList: BracketedArgumentListSyntax): VariableDeclaratorSyntax;
        WithInitializer(initializer: EqualsValueClauseSyntax): VariableDeclaratorSyntax;
        AddArgumentListArguments(...items: ArgumentSyntax[]): VariableDeclaratorSyntax;
    }
    class EqualsValueClauseSyntax extends CSharpSyntaxNode {
        private value;
        constructor();
        ctor_9464(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): EqualsValueClauseSyntax;
        EqualsToken: SyntaxToken;
        Value: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(equalsToken: SyntaxToken, value: ExpressionSyntax): EqualsValueClauseSyntax;
        WithEqualsToken(equalsToken: SyntaxToken): EqualsValueClauseSyntax;
        WithValue(value: ExpressionSyntax): EqualsValueClauseSyntax;
    }
    class ExpressionStatementSyntax extends StatementSyntax {
        private expression;
        constructor();
        ctor_1290(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ExpressionStatementSyntax;
        Expression: ExpressionSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, semicolonToken: SyntaxToken): ExpressionStatementSyntax;
        WithExpression(expression: ExpressionSyntax): ExpressionStatementSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): ExpressionStatementSyntax;
    }
    class EmptyStatementSyntax extends StatementSyntax {
        constructor();
        ctor_1090(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): EmptyStatementSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(semicolonToken: SyntaxToken): EmptyStatementSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): EmptyStatementSyntax;
    }
    class LabeledStatementSyntax extends StatementSyntax {
        private statement;
        constructor();
        ctor_2895(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): LabeledStatementSyntax;
        Identifier: SyntaxToken;
        ColonToken: SyntaxToken;
        Statement: StatementSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax): LabeledStatementSyntax;
        WithIdentifier(identifier: SyntaxToken): LabeledStatementSyntax;
        WithColonToken(colonToken: SyntaxToken): LabeledStatementSyntax;
        WithStatement(statement: StatementSyntax): LabeledStatementSyntax;
    }
    class GotoStatementSyntax extends StatementSyntax {
        private expression;
        constructor();
        ctor_1317(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): GotoStatementSyntax;
        GotoKeyword: SyntaxToken;
        CaseOrDefaultKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): GotoStatementSyntax;
        WithGotoKeyword(gotoKeyword: SyntaxToken): GotoStatementSyntax;
        WithCaseOrDefaultKeyword(caseOrDefaultKeyword: SyntaxToken): GotoStatementSyntax;
        WithExpression(expression: ExpressionSyntax): GotoStatementSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): GotoStatementSyntax;
    }
    class BreakStatementSyntax extends StatementSyntax {
        constructor();
        ctor_1552(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BreakStatementSyntax;
        BreakKeyword: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(breakKeyword: SyntaxToken, semicolonToken: SyntaxToken): BreakStatementSyntax;
        WithBreakKeyword(breakKeyword: SyntaxToken): BreakStatementSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): BreakStatementSyntax;
    }
    class ContinueStatementSyntax extends StatementSyntax {
        constructor();
        ctor_1832(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ContinueStatementSyntax;
        ContinueKeyword: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(continueKeyword: SyntaxToken, semicolonToken: SyntaxToken): ContinueStatementSyntax;
        WithContinueKeyword(continueKeyword: SyntaxToken): ContinueStatementSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): ContinueStatementSyntax;
    }
    class ReturnStatementSyntax extends StatementSyntax {
        private expression;
        constructor();
        ctor_7247(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ReturnStatementSyntax;
        ReturnKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ReturnStatementSyntax;
        WithReturnKeyword(returnKeyword: SyntaxToken): ReturnStatementSyntax;
        WithExpression(expression: ExpressionSyntax): ReturnStatementSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): ReturnStatementSyntax;
    }
    class ThrowStatementSyntax extends StatementSyntax {
        private expression;
        constructor();
        ctor_6630(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ThrowStatementSyntax;
        ThrowKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ThrowStatementSyntax;
        WithThrowKeyword(throwKeyword: SyntaxToken): ThrowStatementSyntax;
        WithExpression(expression: ExpressionSyntax): ThrowStatementSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): ThrowStatementSyntax;
    }
    class YieldStatementSyntax extends StatementSyntax {
        private expression;
        constructor();
        ctor_1958(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): YieldStatementSyntax;
        YieldKeyword: SyntaxToken;
        ReturnOrBreakKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): YieldStatementSyntax;
        WithYieldKeyword(yieldKeyword: SyntaxToken): YieldStatementSyntax;
        WithReturnOrBreakKeyword(returnOrBreakKeyword: SyntaxToken): YieldStatementSyntax;
        WithExpression(expression: ExpressionSyntax): YieldStatementSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): YieldStatementSyntax;
    }
    class WhileStatementSyntax extends StatementSyntax {
        private condition;
        private statement;
        constructor();
        ctor_1352(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): WhileStatementSyntax;
        WhileKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Condition: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): WhileStatementSyntax;
        WithWhileKeyword(whileKeyword: SyntaxToken): WhileStatementSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): WhileStatementSyntax;
        WithCondition(condition: ExpressionSyntax): WhileStatementSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): WhileStatementSyntax;
        WithStatement(statement: StatementSyntax): WhileStatementSyntax;
    }
    class DoStatementSyntax extends StatementSyntax {
        private statement;
        private condition;
        constructor();
        ctor_6607(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): DoStatementSyntax;
        DoKeyword: SyntaxToken;
        Statement: StatementSyntax;
        WhileKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Condition: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken): DoStatementSyntax;
        WithDoKeyword(doKeyword: SyntaxToken): DoStatementSyntax;
        WithStatement(statement: StatementSyntax): DoStatementSyntax;
        WithWhileKeyword(whileKeyword: SyntaxToken): DoStatementSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): DoStatementSyntax;
        WithCondition(condition: ExpressionSyntax): DoStatementSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): DoStatementSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): DoStatementSyntax;
    }
    class ForStatementSyntax extends StatementSyntax {
        private declaration;
        private initializers;
        private condition;
        private incrementors;
        private statement;
        constructor();
        ctor_5717(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ForStatementSyntax;
        ForKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Declaration: VariableDeclarationSyntax;
        Initializers: SeparatedSyntaxList<ExpressionSyntax>;
        FirstSemicolonToken: SyntaxToken;
        Condition: ExpressionSyntax;
        SecondSemicolonToken: SyntaxToken;
        Incrementors: SeparatedSyntaxList<ExpressionSyntax>;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: SeparatedSyntaxList<ExpressionSyntax>, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: SeparatedSyntaxList<ExpressionSyntax>, closeParenToken: SyntaxToken, statement: StatementSyntax): ForStatementSyntax;
        WithForKeyword(forKeyword: SyntaxToken): ForStatementSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): ForStatementSyntax;
        WithDeclaration(declaration: VariableDeclarationSyntax): ForStatementSyntax;
        WithInitializers(initializers: SeparatedSyntaxList<ExpressionSyntax>): ForStatementSyntax;
        WithFirstSemicolonToken(firstSemicolonToken: SyntaxToken): ForStatementSyntax;
        WithCondition(condition: ExpressionSyntax): ForStatementSyntax;
        WithSecondSemicolonToken(secondSemicolonToken: SyntaxToken): ForStatementSyntax;
        WithIncrementors(incrementors: SeparatedSyntaxList<ExpressionSyntax>): ForStatementSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): ForStatementSyntax;
        WithStatement(statement: StatementSyntax): ForStatementSyntax;
        AddInitializers(...items: ExpressionSyntax[]): ForStatementSyntax;
        AddIncrementors(...items: ExpressionSyntax[]): ForStatementSyntax;
    }
    class ForEachStatementSyntax extends StatementSyntax {
        private type;
        private expression;
        private statement;
        constructor();
        ctor_5886(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ForEachStatementSyntax;
        ForEachKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        Identifier: SyntaxToken;
        InKeyword: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): ForEachStatementSyntax;
        WithForEachKeyword(forEachKeyword: SyntaxToken): ForEachStatementSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): ForEachStatementSyntax;
        WithType(type: TypeSyntax): ForEachStatementSyntax;
        WithIdentifier(identifier: SyntaxToken): ForEachStatementSyntax;
        WithInKeyword(inKeyword: SyntaxToken): ForEachStatementSyntax;
        WithExpression(expression: ExpressionSyntax): ForEachStatementSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): ForEachStatementSyntax;
        WithStatement(statement: StatementSyntax): ForEachStatementSyntax;
    }
    class UsingStatementSyntax extends StatementSyntax {
        private declaration;
        private expression;
        private statement;
        constructor();
        ctor_2075(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): UsingStatementSyntax;
        UsingKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Declaration: VariableDeclarationSyntax;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): UsingStatementSyntax;
        WithUsingKeyword(usingKeyword: SyntaxToken): UsingStatementSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): UsingStatementSyntax;
        WithDeclaration(declaration: VariableDeclarationSyntax): UsingStatementSyntax;
        WithExpression(expression: ExpressionSyntax): UsingStatementSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): UsingStatementSyntax;
        WithStatement(statement: StatementSyntax): UsingStatementSyntax;
    }
    class FixedStatementSyntax extends StatementSyntax {
        private declaration;
        private statement;
        constructor();
        ctor_8045(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): FixedStatementSyntax;
        FixedKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Declaration: VariableDeclarationSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): FixedStatementSyntax;
        WithFixedKeyword(fixedKeyword: SyntaxToken): FixedStatementSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): FixedStatementSyntax;
        WithDeclaration(declaration: VariableDeclarationSyntax): FixedStatementSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): FixedStatementSyntax;
        WithStatement(statement: StatementSyntax): FixedStatementSyntax;
        AddDeclarationVariables(...items: VariableDeclaratorSyntax[]): FixedStatementSyntax;
    }
    class CheckedStatementSyntax extends StatementSyntax {
        private block;
        constructor();
        ctor_5206(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CheckedStatementSyntax;
        Keyword: SyntaxToken;
        Block: BlockSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, block: BlockSyntax): CheckedStatementSyntax;
        WithKeyword(keyword: SyntaxToken): CheckedStatementSyntax;
        WithBlock(block: BlockSyntax): CheckedStatementSyntax;
        AddBlockStatements(...items: StatementSyntax[]): CheckedStatementSyntax;
    }
    class UnsafeStatementSyntax extends StatementSyntax {
        private block;
        constructor();
        ctor_5623(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): UnsafeStatementSyntax;
        UnsafeKeyword: SyntaxToken;
        Block: BlockSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(unsafeKeyword: SyntaxToken, block: BlockSyntax): UnsafeStatementSyntax;
        WithUnsafeKeyword(unsafeKeyword: SyntaxToken): UnsafeStatementSyntax;
        WithBlock(block: BlockSyntax): UnsafeStatementSyntax;
        AddBlockStatements(...items: StatementSyntax[]): UnsafeStatementSyntax;
    }
    class LockStatementSyntax extends StatementSyntax {
        private expression;
        private statement;
        constructor();
        ctor_4559(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): LockStatementSyntax;
        LockKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): LockStatementSyntax;
        WithLockKeyword(lockKeyword: SyntaxToken): LockStatementSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): LockStatementSyntax;
        WithExpression(expression: ExpressionSyntax): LockStatementSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): LockStatementSyntax;
        WithStatement(statement: StatementSyntax): LockStatementSyntax;
    }
    class IfStatementSyntax extends StatementSyntax {
        private condition;
        private statement;
        private $else;
        constructor();
        ctor_7214(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): IfStatementSyntax;
        IfKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Condition: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        Statement: StatementSyntax;
        Else: ElseClauseSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax): IfStatementSyntax;
        WithIfKeyword(ifKeyword: SyntaxToken): IfStatementSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): IfStatementSyntax;
        WithCondition(condition: ExpressionSyntax): IfStatementSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): IfStatementSyntax;
        WithStatement(statement: StatementSyntax): IfStatementSyntax;
        WithElse($else: ElseClauseSyntax): IfStatementSyntax;
    }
    class ElseClauseSyntax extends CSharpSyntaxNode {
        private statement;
        constructor();
        ctor_6425(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ElseClauseSyntax;
        ElseKeyword: SyntaxToken;
        Statement: StatementSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(elseKeyword: SyntaxToken, statement: StatementSyntax): ElseClauseSyntax;
        WithElseKeyword(elseKeyword: SyntaxToken): ElseClauseSyntax;
        WithStatement(statement: StatementSyntax): ElseClauseSyntax;
    }
    class SwitchStatementSyntax extends StatementSyntax {
        private expression;
        private sections;
        constructor();
        ctor_1833(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): SwitchStatementSyntax;
        SwitchKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        Expression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        OpenBraceToken: SyntaxToken;
        Sections: SyntaxList<SwitchSectionSyntax>;
        CloseBraceToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: SyntaxList<SwitchSectionSyntax>, closeBraceToken: SyntaxToken): SwitchStatementSyntax;
        WithSwitchKeyword(switchKeyword: SyntaxToken): SwitchStatementSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): SwitchStatementSyntax;
        WithExpression(expression: ExpressionSyntax): SwitchStatementSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): SwitchStatementSyntax;
        WithOpenBraceToken(openBraceToken: SyntaxToken): SwitchStatementSyntax;
        WithSections(sections: SyntaxList<SwitchSectionSyntax>): SwitchStatementSyntax;
        WithCloseBraceToken(closeBraceToken: SyntaxToken): SwitchStatementSyntax;
        AddSections(...items: SwitchSectionSyntax[]): SwitchStatementSyntax;
    }
    class SwitchSectionSyntax extends CSharpSyntaxNode {
        private labels;
        private statements;
        constructor();
        ctor_1124(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): SwitchSectionSyntax;
        Labels: SyntaxList<SwitchLabelSyntax>;
        Statements: SyntaxList<StatementSyntax>;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(labels: SyntaxList<SwitchLabelSyntax>, statements: SyntaxList<StatementSyntax>): SwitchSectionSyntax;
        WithLabels(labels: SyntaxList<SwitchLabelSyntax>): SwitchSectionSyntax;
        WithStatements(statements: SyntaxList<StatementSyntax>): SwitchSectionSyntax;
        AddLabels(...items: SwitchLabelSyntax[]): SwitchSectionSyntax;
        AddStatements(...items: StatementSyntax[]): SwitchSectionSyntax;
    }
    class SwitchLabelSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_3712(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): SwitchLabelSyntax;
        Keyword: SyntaxToken;
        ColonToken: SyntaxToken;
    }
    class CaseSwitchLabelSyntax extends SwitchLabelSyntax {
        private value;
        constructor();
        ctor_1688_C(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CaseSwitchLabelSyntax;
        Keyword: SyntaxToken;
        Value: ExpressionSyntax;
        ColonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken): CaseSwitchLabelSyntax;
        WithKeyword(keyword: SyntaxToken): CaseSwitchLabelSyntax;
        WithValue(value: ExpressionSyntax): CaseSwitchLabelSyntax;
        WithColonToken(colonToken: SyntaxToken): CaseSwitchLabelSyntax;
    }
    class DefaultSwitchLabelSyntax extends SwitchLabelSyntax {
        constructor();
        ctor_1836(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): DefaultSwitchLabelSyntax;
        Keyword: SyntaxToken;
        ColonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(keyword: SyntaxToken, colonToken: SyntaxToken): DefaultSwitchLabelSyntax;
        WithKeyword(keyword: SyntaxToken): DefaultSwitchLabelSyntax;
        WithColonToken(colonToken: SyntaxToken): DefaultSwitchLabelSyntax;
    }
    class TryStatementSyntax extends StatementSyntax {
        private block;
        private catches;
        private $finally;
        constructor();
        ctor_1844(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TryStatementSyntax;
        TryKeyword: SyntaxToken;
        Block: BlockSyntax;
        Catches: SyntaxList<CatchClauseSyntax>;
        Finally: FinallyClauseSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(tryKeyword: SyntaxToken, block: BlockSyntax, catches: SyntaxList<CatchClauseSyntax>, $finally: FinallyClauseSyntax): TryStatementSyntax;
        WithTryKeyword(tryKeyword: SyntaxToken): TryStatementSyntax;
        WithBlock(block: BlockSyntax): TryStatementSyntax;
        WithCatches(catches: SyntaxList<CatchClauseSyntax>): TryStatementSyntax;
        WithFinally($finally: FinallyClauseSyntax): TryStatementSyntax;
        AddBlockStatements(...items: StatementSyntax[]): TryStatementSyntax;
        AddCatches(...items: CatchClauseSyntax[]): TryStatementSyntax;
    }
    class CatchClauseSyntax extends CSharpSyntaxNode {
        private declaration;
        private filter;
        private block;
        constructor();
        ctor_1474(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CatchClauseSyntax;
        CatchKeyword: SyntaxToken;
        Declaration: CatchDeclarationSyntax;
        Filter: CatchFilterClauseSyntax;
        Block: BlockSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax): CatchClauseSyntax;
        WithCatchKeyword(catchKeyword: SyntaxToken): CatchClauseSyntax;
        WithDeclaration(declaration: CatchDeclarationSyntax): CatchClauseSyntax;
        WithFilter(filter: CatchFilterClauseSyntax): CatchClauseSyntax;
        WithBlock(block: BlockSyntax): CatchClauseSyntax;
        AddBlockStatements(...items: StatementSyntax[]): CatchClauseSyntax;
    }
    class CatchDeclarationSyntax extends CSharpSyntaxNode {
        private type;
        constructor();
        ctor_8164(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CatchDeclarationSyntax;
        OpenParenToken: SyntaxToken;
        Type: TypeSyntax;
        Identifier: SyntaxToken;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken): CatchDeclarationSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): CatchDeclarationSyntax;
        WithType(type: TypeSyntax): CatchDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): CatchDeclarationSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): CatchDeclarationSyntax;
    }
    class CatchFilterClauseSyntax extends CSharpSyntaxNode {
        private filterExpression;
        constructor();
        ctor_1545(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CatchFilterClauseSyntax;
        IfKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        FilterExpression: ExpressionSyntax;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken): CatchFilterClauseSyntax;
        WithIfKeyword(ifKeyword: SyntaxToken): CatchFilterClauseSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): CatchFilterClauseSyntax;
        WithFilterExpression(filterExpression: ExpressionSyntax): CatchFilterClauseSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): CatchFilterClauseSyntax;
    }
    class FinallyClauseSyntax extends CSharpSyntaxNode {
        private block;
        constructor();
        ctor_1882(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): FinallyClauseSyntax;
        FinallyKeyword: SyntaxToken;
        Block: BlockSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(finallyKeyword: SyntaxToken, block: BlockSyntax): FinallyClauseSyntax;
        WithFinallyKeyword(finallyKeyword: SyntaxToken): FinallyClauseSyntax;
        WithBlock(block: BlockSyntax): FinallyClauseSyntax;
        AddBlockStatements(...items: StatementSyntax[]): FinallyClauseSyntax;
    }
    class ExternAliasDirectiveSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_2123(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ExternAliasDirectiveSyntax;
        ExternKeyword: SyntaxToken;
        AliasKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken): ExternAliasDirectiveSyntax;
        WithExternKeyword(externKeyword: SyntaxToken): ExternAliasDirectiveSyntax;
        WithAliasKeyword(aliasKeyword: SyntaxToken): ExternAliasDirectiveSyntax;
        WithIdentifier(identifier: SyntaxToken): ExternAliasDirectiveSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): ExternAliasDirectiveSyntax;
    }
    class UsingDirectiveSyntax extends CSharpSyntaxNode {
        private alias;
        private name;
        constructor();
        ctor_1802(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): UsingDirectiveSyntax;
        UsingKeyword: SyntaxToken;
        StaticKeyword: SyntaxToken;
        Alias: NameEqualsSyntax;
        Name: NameSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken): UsingDirectiveSyntax;
        WithUsingKeyword(usingKeyword: SyntaxToken): UsingDirectiveSyntax;
        WithStaticKeyword(staticKeyword: SyntaxToken): UsingDirectiveSyntax;
        WithAlias(alias: NameEqualsSyntax): UsingDirectiveSyntax;
        WithName(name: NameSyntax): UsingDirectiveSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): UsingDirectiveSyntax;
    }
    class NamespaceDeclarationSyntax extends MemberDeclarationSyntax {
        private name;
        private externs;
        private usings;
        private members;
        constructor();
        ctor_1862(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): NamespaceDeclarationSyntax;
        NamespaceKeyword: SyntaxToken;
        Name: NameSyntax;
        OpenBraceToken: SyntaxToken;
        Externs: SyntaxList<ExternAliasDirectiveSyntax>;
        Usings: SyntaxList<UsingDirectiveSyntax>;
        Members: SyntaxList<MemberDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: SyntaxList<ExternAliasDirectiveSyntax>, usings: SyntaxList<UsingDirectiveSyntax>, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): NamespaceDeclarationSyntax;
        WithNamespaceKeyword(namespaceKeyword: SyntaxToken): NamespaceDeclarationSyntax;
        WithName(name: NameSyntax): NamespaceDeclarationSyntax;
        WithOpenBraceToken(openBraceToken: SyntaxToken): NamespaceDeclarationSyntax;
        WithExterns(externs: SyntaxList<ExternAliasDirectiveSyntax>): NamespaceDeclarationSyntax;
        WithUsings(usings: SyntaxList<UsingDirectiveSyntax>): NamespaceDeclarationSyntax;
        WithMembers(members: SyntaxList<MemberDeclarationSyntax>): NamespaceDeclarationSyntax;
        WithCloseBraceToken(closeBraceToken: SyntaxToken): NamespaceDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): NamespaceDeclarationSyntax;
        AddExterns(...items: ExternAliasDirectiveSyntax[]): NamespaceDeclarationSyntax;
        AddUsings(...items: UsingDirectiveSyntax[]): NamespaceDeclarationSyntax;
        AddMembers(...items: MemberDeclarationSyntax[]): NamespaceDeclarationSyntax;
    }
    class AttributeListSyntax extends CSharpSyntaxNode {
        private target;
        private attributes;
        constructor();
        ctor_3299(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AttributeListSyntax;
        OpenBracketToken: SyntaxToken;
        Target: AttributeTargetSpecifierSyntax;
        Attributes: SeparatedSyntaxList<AttributeSyntax>;
        CloseBracketToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: SeparatedSyntaxList<AttributeSyntax>, closeBracketToken: SyntaxToken): AttributeListSyntax;
        WithOpenBracketToken(openBracketToken: SyntaxToken): AttributeListSyntax;
        WithTarget(target: AttributeTargetSpecifierSyntax): AttributeListSyntax;
        WithAttributes(attributes: SeparatedSyntaxList<AttributeSyntax>): AttributeListSyntax;
        WithCloseBracketToken(closeBracketToken: SyntaxToken): AttributeListSyntax;
        AddAttributes(...items: AttributeSyntax[]): AttributeListSyntax;
    }
    class AttributeTargetSpecifierSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_2639(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AttributeTargetSpecifierSyntax;
        Identifier: SyntaxToken;
        ColonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(identifier: SyntaxToken, colonToken: SyntaxToken): AttributeTargetSpecifierSyntax;
        WithIdentifier(identifier: SyntaxToken): AttributeTargetSpecifierSyntax;
        WithColonToken(colonToken: SyntaxToken): AttributeTargetSpecifierSyntax;
    }
    class AttributeSyntax extends CSharpSyntaxNode {
        private name;
        private argumentList;
        constructor();
        ctor_1064(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AttributeSyntax;
        Name: NameSyntax;
        ArgumentList: AttributeArgumentListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: NameSyntax, argumentList: AttributeArgumentListSyntax): AttributeSyntax;
        WithName(name: NameSyntax): AttributeSyntax;
        WithArgumentList(argumentList: AttributeArgumentListSyntax): AttributeSyntax;
        AddArgumentListArguments(...items: AttributeArgumentSyntax[]): AttributeSyntax;
    }
    class AttributeArgumentListSyntax extends CSharpSyntaxNode {
        private arguments;
        constructor();
        ctor_6570(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AttributeArgumentListSyntax;
        OpenParenToken: SyntaxToken;
        Arguments: SeparatedSyntaxList<AttributeArgumentSyntax>;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, arguments: SeparatedSyntaxList<AttributeArgumentSyntax>, closeParenToken: SyntaxToken): AttributeArgumentListSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): AttributeArgumentListSyntax;
        WithArguments(arguments: SeparatedSyntaxList<AttributeArgumentSyntax>): AttributeArgumentListSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): AttributeArgumentListSyntax;
        AddArguments(...items: AttributeArgumentSyntax[]): AttributeArgumentListSyntax;
    }
    class AttributeArgumentSyntax extends CSharpSyntaxNode {
        private nameEquals;
        private nameColon;
        private expression;
        constructor();
        ctor_1819(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AttributeArgumentSyntax;
        NameEquals: NameEqualsSyntax;
        NameColon: NameColonSyntax;
        Expression: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax): AttributeArgumentSyntax;
        WithNameEquals(nameEquals: NameEqualsSyntax): AttributeArgumentSyntax;
        WithNameColon(nameColon: NameColonSyntax): AttributeArgumentSyntax;
        WithExpression(expression: ExpressionSyntax): AttributeArgumentSyntax;
    }
    class NameEqualsSyntax extends CSharpSyntaxNode {
        private name;
        constructor();
        ctor_8735(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): NameEqualsSyntax;
        Name: IdentifierNameSyntax;
        EqualsToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: IdentifierNameSyntax, equalsToken: SyntaxToken): NameEqualsSyntax;
        WithName(name: IdentifierNameSyntax): NameEqualsSyntax;
        WithEqualsToken(equalsToken: SyntaxToken): NameEqualsSyntax;
    }
    class TypeParameterListSyntax extends CSharpSyntaxNode {
        private parameters;
        constructor();
        ctor_2009(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TypeParameterListSyntax;
        LessThanToken: SyntaxToken;
        Parameters: SeparatedSyntaxList<TypeParameterSyntax>;
        GreaterThanToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanToken: SyntaxToken, parameters: SeparatedSyntaxList<TypeParameterSyntax>, greaterThanToken: SyntaxToken): TypeParameterListSyntax;
        WithLessThanToken(lessThanToken: SyntaxToken): TypeParameterListSyntax;
        WithParameters(parameters: SeparatedSyntaxList<TypeParameterSyntax>): TypeParameterListSyntax;
        WithGreaterThanToken(greaterThanToken: SyntaxToken): TypeParameterListSyntax;
        AddParameters(...items: TypeParameterSyntax[]): TypeParameterListSyntax;
    }
    class TypeParameterSyntax extends CSharpSyntaxNode {
        private attributeLists;
        constructor();
        ctor_1706(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TypeParameterSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        VarianceKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, varianceKeyword: SyntaxToken, identifier: SyntaxToken): TypeParameterSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): TypeParameterSyntax;
        WithVarianceKeyword(varianceKeyword: SyntaxToken): TypeParameterSyntax;
        WithIdentifier(identifier: SyntaxToken): TypeParameterSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): TypeParameterSyntax;
    }
    class BaseTypeDeclarationSyntax extends MemberDeclarationSyntax {
        constructor();
        ctor_1624(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BaseTypeDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Identifier: SyntaxToken;
        BaseList: BaseListSyntax;
        OpenBraceToken: SyntaxToken;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
    }
    class TypeDeclarationSyntax extends BaseTypeDeclarationSyntax {
        constructor();
        ctor_1437(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TypeDeclarationSyntax;
        Keyword: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        Members: SyntaxList<MemberDeclarationSyntax>;
    }
    class ClassDeclarationSyntax extends TypeDeclarationSyntax {
        private attributeLists;
        private typeParameterList;
        private baseList;
        private constraintClauses;
        private members;
        constructor();
        ctor_1093(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ClassDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Keyword: SyntaxToken;
        Identifier: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        BaseList: BaseListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        OpenBraceToken: SyntaxToken;
        Members: SyntaxList<MemberDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): ClassDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): ClassDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): ClassDeclarationSyntax;
        WithKeyword(keyword: SyntaxToken): ClassDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): ClassDeclarationSyntax;
        WithTypeParameterList(typeParameterList: TypeParameterListSyntax): ClassDeclarationSyntax;
        WithBaseList(baseList: BaseListSyntax): ClassDeclarationSyntax;
        WithConstraintClauses(constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>): ClassDeclarationSyntax;
        WithOpenBraceToken(openBraceToken: SyntaxToken): ClassDeclarationSyntax;
        WithMembers(members: SyntaxList<MemberDeclarationSyntax>): ClassDeclarationSyntax;
        WithCloseBraceToken(closeBraceToken: SyntaxToken): ClassDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): ClassDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): ClassDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): ClassDeclarationSyntax;
        AddTypeParameterListParameters(...items: TypeParameterSyntax[]): ClassDeclarationSyntax;
        AddBaseListTypes(...items: BaseTypeSyntax[]): ClassDeclarationSyntax;
        AddConstraintClauses(...items: TypeParameterConstraintClauseSyntax[]): ClassDeclarationSyntax;
        AddMembers(...items: MemberDeclarationSyntax[]): ClassDeclarationSyntax;
    }
    class StructDeclarationSyntax extends TypeDeclarationSyntax {
        private attributeLists;
        private typeParameterList;
        private baseList;
        private constraintClauses;
        private members;
        constructor();
        ctor_1296(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): StructDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Keyword: SyntaxToken;
        Identifier: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        BaseList: BaseListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        OpenBraceToken: SyntaxToken;
        Members: SyntaxList<MemberDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): StructDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): StructDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): StructDeclarationSyntax;
        WithKeyword(keyword: SyntaxToken): StructDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): StructDeclarationSyntax;
        WithTypeParameterList(typeParameterList: TypeParameterListSyntax): StructDeclarationSyntax;
        WithBaseList(baseList: BaseListSyntax): StructDeclarationSyntax;
        WithConstraintClauses(constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>): StructDeclarationSyntax;
        WithOpenBraceToken(openBraceToken: SyntaxToken): StructDeclarationSyntax;
        WithMembers(members: SyntaxList<MemberDeclarationSyntax>): StructDeclarationSyntax;
        WithCloseBraceToken(closeBraceToken: SyntaxToken): StructDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): StructDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): StructDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): StructDeclarationSyntax;
        AddTypeParameterListParameters(...items: TypeParameterSyntax[]): StructDeclarationSyntax;
        AddBaseListTypes(...items: BaseTypeSyntax[]): StructDeclarationSyntax;
        AddConstraintClauses(...items: TypeParameterConstraintClauseSyntax[]): StructDeclarationSyntax;
        AddMembers(...items: MemberDeclarationSyntax[]): StructDeclarationSyntax;
    }
    class InterfaceDeclarationSyntax extends TypeDeclarationSyntax {
        private attributeLists;
        private typeParameterList;
        private baseList;
        private constraintClauses;
        private members;
        constructor();
        ctor_6961(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): InterfaceDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Keyword: SyntaxToken;
        Identifier: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        BaseList: BaseListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        OpenBraceToken: SyntaxToken;
        Members: SyntaxList<MemberDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): InterfaceDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): InterfaceDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): InterfaceDeclarationSyntax;
        WithKeyword(keyword: SyntaxToken): InterfaceDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): InterfaceDeclarationSyntax;
        WithTypeParameterList(typeParameterList: TypeParameterListSyntax): InterfaceDeclarationSyntax;
        WithBaseList(baseList: BaseListSyntax): InterfaceDeclarationSyntax;
        WithConstraintClauses(constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>): InterfaceDeclarationSyntax;
        WithOpenBraceToken(openBraceToken: SyntaxToken): InterfaceDeclarationSyntax;
        WithMembers(members: SyntaxList<MemberDeclarationSyntax>): InterfaceDeclarationSyntax;
        WithCloseBraceToken(closeBraceToken: SyntaxToken): InterfaceDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): InterfaceDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): InterfaceDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): InterfaceDeclarationSyntax;
        AddTypeParameterListParameters(...items: TypeParameterSyntax[]): InterfaceDeclarationSyntax;
        AddBaseListTypes(...items: BaseTypeSyntax[]): InterfaceDeclarationSyntax;
        AddConstraintClauses(...items: TypeParameterConstraintClauseSyntax[]): InterfaceDeclarationSyntax;
        AddMembers(...items: MemberDeclarationSyntax[]): InterfaceDeclarationSyntax;
    }
    class EnumDeclarationSyntax extends BaseTypeDeclarationSyntax {
        private attributeLists;
        private baseList;
        private members;
        constructor();
        ctor_1697(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): EnumDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        EnumKeyword: SyntaxToken;
        Identifier: SyntaxToken;
        BaseList: BaseListSyntax;
        OpenBraceToken: SyntaxToken;
        Members: SeparatedSyntaxList<EnumMemberDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: SeparatedSyntaxList<EnumMemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): EnumDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): EnumDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): EnumDeclarationSyntax;
        WithEnumKeyword(enumKeyword: SyntaxToken): EnumDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): EnumDeclarationSyntax;
        WithBaseList(baseList: BaseListSyntax): EnumDeclarationSyntax;
        WithOpenBraceToken(openBraceToken: SyntaxToken): EnumDeclarationSyntax;
        WithMembers(members: SeparatedSyntaxList<EnumMemberDeclarationSyntax>): EnumDeclarationSyntax;
        WithCloseBraceToken(closeBraceToken: SyntaxToken): EnumDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): EnumDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): EnumDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): EnumDeclarationSyntax;
        AddBaseListTypes(...items: BaseTypeSyntax[]): EnumDeclarationSyntax;
        AddMembers(...items: EnumMemberDeclarationSyntax[]): EnumDeclarationSyntax;
    }
    class DelegateDeclarationSyntax extends MemberDeclarationSyntax {
        private attributeLists;
        private returnType;
        private typeParameterList;
        private parameterList;
        private constraintClauses;
        constructor();
        ctor_1095(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): DelegateDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        DelegateKeyword: SyntaxToken;
        ReturnType: TypeSyntax;
        Identifier: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        ParameterList: ParameterListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, semicolonToken: SyntaxToken): DelegateDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): DelegateDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): DelegateDeclarationSyntax;
        WithDelegateKeyword(delegateKeyword: SyntaxToken): DelegateDeclarationSyntax;
        WithReturnType(returnType: TypeSyntax): DelegateDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): DelegateDeclarationSyntax;
        WithTypeParameterList(typeParameterList: TypeParameterListSyntax): DelegateDeclarationSyntax;
        WithParameterList(parameterList: ParameterListSyntax): DelegateDeclarationSyntax;
        WithConstraintClauses(constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>): DelegateDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): DelegateDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): DelegateDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): DelegateDeclarationSyntax;
        AddTypeParameterListParameters(...items: TypeParameterSyntax[]): DelegateDeclarationSyntax;
        AddParameterListParameters(...items: ParameterSyntax[]): DelegateDeclarationSyntax;
        AddConstraintClauses(...items: TypeParameterConstraintClauseSyntax[]): DelegateDeclarationSyntax;
    }
    class EnumMemberDeclarationSyntax extends MemberDeclarationSyntax {
        private attributeLists;
        private equalsValue;
        constructor();
        ctor_9853(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): EnumMemberDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Identifier: SyntaxToken;
        EqualsValue: EqualsValueClauseSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax): EnumMemberDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): EnumMemberDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): EnumMemberDeclarationSyntax;
        WithEqualsValue(equalsValue: EqualsValueClauseSyntax): EnumMemberDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): EnumMemberDeclarationSyntax;
    }
    class BaseListSyntax extends CSharpSyntaxNode {
        private types;
        constructor();
        ctor_1136(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BaseListSyntax;
        ColonToken: SyntaxToken;
        Types: SeparatedSyntaxList<BaseTypeSyntax>;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(colonToken: SyntaxToken, types: SeparatedSyntaxList<BaseTypeSyntax>): BaseListSyntax;
        WithColonToken(colonToken: SyntaxToken): BaseListSyntax;
        WithTypes(types: SeparatedSyntaxList<BaseTypeSyntax>): BaseListSyntax;
        AddTypes(...items: BaseTypeSyntax[]): BaseListSyntax;
    }
    class BaseTypeSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_3109(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BaseTypeSyntax;
        Type: TypeSyntax;
    }
    class SimpleBaseTypeSyntax extends BaseTypeSyntax {
        private type;
        constructor();
        ctor_1308(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): SimpleBaseTypeSyntax;
        Type: TypeSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(type: TypeSyntax): SimpleBaseTypeSyntax;
        WithType(type: TypeSyntax): SimpleBaseTypeSyntax;
    }
    class TypeParameterConstraintClauseSyntax extends CSharpSyntaxNode {
        private name;
        private constraints;
        constructor();
        ctor_2081(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TypeParameterConstraintClauseSyntax;
        WhereKeyword: SyntaxToken;
        Name: IdentifierNameSyntax;
        ColonToken: SyntaxToken;
        Constraints: SeparatedSyntaxList<TypeParameterConstraintSyntax>;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: SeparatedSyntaxList<TypeParameterConstraintSyntax>): TypeParameterConstraintClauseSyntax;
        WithWhereKeyword(whereKeyword: SyntaxToken): TypeParameterConstraintClauseSyntax;
        WithName(name: IdentifierNameSyntax): TypeParameterConstraintClauseSyntax;
        WithColonToken(colonToken: SyntaxToken): TypeParameterConstraintClauseSyntax;
        WithConstraints(constraints: SeparatedSyntaxList<TypeParameterConstraintSyntax>): TypeParameterConstraintClauseSyntax;
        AddConstraints(...items: TypeParameterConstraintSyntax[]): TypeParameterConstraintClauseSyntax;
    }
    class TypeParameterConstraintSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1687(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TypeParameterConstraintSyntax;
    }
    class ConstructorConstraintSyntax extends TypeParameterConstraintSyntax {
        constructor();
        ctor_4479(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ConstructorConstraintSyntax;
        NewKeyword: SyntaxToken;
        OpenParenToken: SyntaxToken;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken): ConstructorConstraintSyntax;
        WithNewKeyword(newKeyword: SyntaxToken): ConstructorConstraintSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): ConstructorConstraintSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): ConstructorConstraintSyntax;
    }
    class ClassOrStructConstraintSyntax extends TypeParameterConstraintSyntax {
        constructor();
        ctor_1223(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ClassOrStructConstraintSyntax;
        ClassOrStructKeyword: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(classOrStructKeyword: SyntaxToken): ClassOrStructConstraintSyntax;
        WithClassOrStructKeyword(classOrStructKeyword: SyntaxToken): ClassOrStructConstraintSyntax;
    }
    class TypeConstraintSyntax extends TypeParameterConstraintSyntax {
        private type;
        constructor();
        ctor_2135(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TypeConstraintSyntax;
        Type: TypeSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(type: TypeSyntax): TypeConstraintSyntax;
        WithType(type: TypeSyntax): TypeConstraintSyntax;
    }
    class BaseFieldDeclarationSyntax extends MemberDeclarationSyntax {
        constructor();
        ctor_1810(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BaseFieldDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Declaration: VariableDeclarationSyntax;
        SemicolonToken: SyntaxToken;
    }
    class FieldDeclarationSyntax extends BaseFieldDeclarationSyntax {
        private attributeLists;
        private declaration;
        constructor();
        ctor_1589(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): FieldDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Declaration: VariableDeclarationSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): FieldDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): FieldDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): FieldDeclarationSyntax;
        WithDeclaration(declaration: VariableDeclarationSyntax): FieldDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): FieldDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): FieldDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): FieldDeclarationSyntax;
        AddDeclarationVariables(...items: VariableDeclaratorSyntax[]): FieldDeclarationSyntax;
    }
    class EventFieldDeclarationSyntax extends BaseFieldDeclarationSyntax {
        private attributeLists;
        private declaration;
        constructor();
        ctor_1583(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): EventFieldDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        EventKeyword: SyntaxToken;
        Declaration: VariableDeclarationSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): EventFieldDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): EventFieldDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): EventFieldDeclarationSyntax;
        WithEventKeyword(eventKeyword: SyntaxToken): EventFieldDeclarationSyntax;
        WithDeclaration(declaration: VariableDeclarationSyntax): EventFieldDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): EventFieldDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): EventFieldDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): EventFieldDeclarationSyntax;
        AddDeclarationVariables(...items: VariableDeclaratorSyntax[]): EventFieldDeclarationSyntax;
    }
    class ExplicitInterfaceSpecifierSyntax extends CSharpSyntaxNode {
        private name;
        constructor();
        ctor_1299(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ExplicitInterfaceSpecifierSyntax;
        Name: NameSyntax;
        DotToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: NameSyntax, dotToken: SyntaxToken): ExplicitInterfaceSpecifierSyntax;
        WithName(name: NameSyntax): ExplicitInterfaceSpecifierSyntax;
        WithDotToken(dotToken: SyntaxToken): ExplicitInterfaceSpecifierSyntax;
    }
    class BaseMethodDeclarationSyntax extends MemberDeclarationSyntax {
        constructor();
        ctor_1899(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BaseMethodDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        ParameterList: ParameterListSyntax;
        Body: BlockSyntax;
        SemicolonToken: SyntaxToken;
    }
    class MethodDeclarationSyntax extends BaseMethodDeclarationSyntax {
        private attributeLists;
        private returnType;
        private explicitInterfaceSpecifier;
        private typeParameterList;
        private parameterList;
        private constraintClauses;
        private body;
        private expressionBody;
        constructor();
        ctor_4143(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): MethodDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        ReturnType: TypeSyntax;
        ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        Identifier: SyntaxToken;
        TypeParameterList: TypeParameterListSyntax;
        ParameterList: ParameterListSyntax;
        ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;
        Body: BlockSyntax;
        ExpressionBody: ArrowExpressionClauseSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): MethodDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): MethodDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): MethodDeclarationSyntax;
        WithReturnType(returnType: TypeSyntax): MethodDeclarationSyntax;
        WithExplicitInterfaceSpecifier(explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax): MethodDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): MethodDeclarationSyntax;
        WithTypeParameterList(typeParameterList: TypeParameterListSyntax): MethodDeclarationSyntax;
        WithParameterList(parameterList: ParameterListSyntax): MethodDeclarationSyntax;
        WithConstraintClauses(constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>): MethodDeclarationSyntax;
        WithBody(body: BlockSyntax): MethodDeclarationSyntax;
        WithExpressionBody(expressionBody: ArrowExpressionClauseSyntax): MethodDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): MethodDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): MethodDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): MethodDeclarationSyntax;
        AddTypeParameterListParameters(...items: TypeParameterSyntax[]): MethodDeclarationSyntax;
        AddParameterListParameters(...items: ParameterSyntax[]): MethodDeclarationSyntax;
        AddConstraintClauses(...items: TypeParameterConstraintClauseSyntax[]): MethodDeclarationSyntax;
        AddBodyStatements(...items: StatementSyntax[]): MethodDeclarationSyntax;
    }
    class OperatorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        private attributeLists;
        private returnType;
        private parameterList;
        private body;
        private expressionBody;
        constructor();
        ctor_4027(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): OperatorDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        ReturnType: TypeSyntax;
        OperatorKeyword: SyntaxToken;
        OperatorToken: SyntaxToken;
        ParameterList: ParameterListSyntax;
        Body: BlockSyntax;
        ExpressionBody: ArrowExpressionClauseSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): OperatorDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): OperatorDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): OperatorDeclarationSyntax;
        WithReturnType(returnType: TypeSyntax): OperatorDeclarationSyntax;
        WithOperatorKeyword(operatorKeyword: SyntaxToken): OperatorDeclarationSyntax;
        WithOperatorToken(operatorToken: SyntaxToken): OperatorDeclarationSyntax;
        WithParameterList(parameterList: ParameterListSyntax): OperatorDeclarationSyntax;
        WithBody(body: BlockSyntax): OperatorDeclarationSyntax;
        WithExpressionBody(expressionBody: ArrowExpressionClauseSyntax): OperatorDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): OperatorDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): OperatorDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): OperatorDeclarationSyntax;
        AddParameterListParameters(...items: ParameterSyntax[]): OperatorDeclarationSyntax;
        AddBodyStatements(...items: StatementSyntax[]): OperatorDeclarationSyntax;
    }
    class ConversionOperatorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        private attributeLists;
        private type;
        private parameterList;
        private body;
        private expressionBody;
        constructor();
        ctor_4050(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ConversionOperatorDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        ImplicitOrExplicitKeyword: SyntaxToken;
        OperatorKeyword: SyntaxToken;
        Type: TypeSyntax;
        ParameterList: ParameterListSyntax;
        Body: BlockSyntax;
        ExpressionBody: ArrowExpressionClauseSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): ConversionOperatorDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): ConversionOperatorDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): ConversionOperatorDeclarationSyntax;
        WithImplicitOrExplicitKeyword(implicitOrExplicitKeyword: SyntaxToken): ConversionOperatorDeclarationSyntax;
        WithOperatorKeyword(operatorKeyword: SyntaxToken): ConversionOperatorDeclarationSyntax;
        WithType(type: TypeSyntax): ConversionOperatorDeclarationSyntax;
        WithParameterList(parameterList: ParameterListSyntax): ConversionOperatorDeclarationSyntax;
        WithBody(body: BlockSyntax): ConversionOperatorDeclarationSyntax;
        WithExpressionBody(expressionBody: ArrowExpressionClauseSyntax): ConversionOperatorDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): ConversionOperatorDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): ConversionOperatorDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): ConversionOperatorDeclarationSyntax;
        AddParameterListParameters(...items: ParameterSyntax[]): ConversionOperatorDeclarationSyntax;
        AddBodyStatements(...items: StatementSyntax[]): ConversionOperatorDeclarationSyntax;
    }
    class ConstructorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        private attributeLists;
        private parameterList;
        private initializer;
        private body;
        constructor();
        ctor_1279(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ConstructorDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Identifier: SyntaxToken;
        ParameterList: ParameterListSyntax;
        Initializer: ConstructorInitializerSyntax;
        Body: BlockSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): ConstructorDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): ConstructorDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): ConstructorDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): ConstructorDeclarationSyntax;
        WithParameterList(parameterList: ParameterListSyntax): ConstructorDeclarationSyntax;
        WithInitializer(initializer: ConstructorInitializerSyntax): ConstructorDeclarationSyntax;
        WithBody(body: BlockSyntax): ConstructorDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): ConstructorDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): ConstructorDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): ConstructorDeclarationSyntax;
        AddParameterListParameters(...items: ParameterSyntax[]): ConstructorDeclarationSyntax;
        AddBodyStatements(...items: StatementSyntax[]): ConstructorDeclarationSyntax;
    }
    class ConstructorInitializerSyntax extends CSharpSyntaxNode {
        private argumentList;
        constructor();
        ctor_7521(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ConstructorInitializerSyntax;
        ColonToken: SyntaxToken;
        ThisOrBaseKeyword: SyntaxToken;
        ArgumentList: ArgumentListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax): ConstructorInitializerSyntax;
        WithColonToken(colonToken: SyntaxToken): ConstructorInitializerSyntax;
        WithThisOrBaseKeyword(thisOrBaseKeyword: SyntaxToken): ConstructorInitializerSyntax;
        WithArgumentList(argumentList: ArgumentListSyntax): ConstructorInitializerSyntax;
        AddArgumentListArguments(...items: ArgumentSyntax[]): ConstructorInitializerSyntax;
    }
    class DestructorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        private attributeLists;
        private parameterList;
        private body;
        constructor();
        ctor_1597(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): DestructorDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        TildeToken: SyntaxToken;
        Identifier: SyntaxToken;
        ParameterList: ParameterListSyntax;
        Body: BlockSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): DestructorDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): DestructorDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): DestructorDeclarationSyntax;
        WithTildeToken(tildeToken: SyntaxToken): DestructorDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): DestructorDeclarationSyntax;
        WithParameterList(parameterList: ParameterListSyntax): DestructorDeclarationSyntax;
        WithBody(body: BlockSyntax): DestructorDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): DestructorDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): DestructorDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): DestructorDeclarationSyntax;
        AddParameterListParameters(...items: ParameterSyntax[]): DestructorDeclarationSyntax;
        AddBodyStatements(...items: StatementSyntax[]): DestructorDeclarationSyntax;
    }
    class BasePropertyDeclarationSyntax extends MemberDeclarationSyntax {
        constructor();
        ctor_3562(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BasePropertyDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Type: TypeSyntax;
        ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        AccessorList: AccessorListSyntax;
    }
    class PropertyDeclarationSyntax extends BasePropertyDeclarationSyntax {
        private attributeLists;
        private type;
        private explicitInterfaceSpecifier;
        private accessorList;
        private expressionBody;
        private initializer;
        constructor();
        ctor_1532(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): PropertyDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Type: TypeSyntax;
        ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        Identifier: SyntaxToken;
        AccessorList: AccessorListSyntax;
        ExpressionBody: ArrowExpressionClauseSyntax;
        Initializer: EqualsValueClauseSyntax;
        Semicolon: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken): PropertyDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): PropertyDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): PropertyDeclarationSyntax;
        WithType(type: TypeSyntax): PropertyDeclarationSyntax;
        WithExplicitInterfaceSpecifier(explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax): PropertyDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): PropertyDeclarationSyntax;
        WithAccessorList(accessorList: AccessorListSyntax): PropertyDeclarationSyntax;
        WithExpressionBody(expressionBody: ArrowExpressionClauseSyntax): PropertyDeclarationSyntax;
        WithInitializer(initializer: EqualsValueClauseSyntax): PropertyDeclarationSyntax;
        WithSemicolon(semicolon: SyntaxToken): PropertyDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): PropertyDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): PropertyDeclarationSyntax;
        AddAccessorListAccessors(...items: AccessorDeclarationSyntax[]): PropertyDeclarationSyntax;
    }
    class ArrowExpressionClauseSyntax extends CSharpSyntaxNode {
        private expression;
        constructor();
        ctor_1013(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ArrowExpressionClauseSyntax;
        ArrowToken: SyntaxToken;
        Expression: ExpressionSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(arrowToken: SyntaxToken, expression: ExpressionSyntax): ArrowExpressionClauseSyntax;
        WithArrowToken(arrowToken: SyntaxToken): ArrowExpressionClauseSyntax;
        WithExpression(expression: ExpressionSyntax): ArrowExpressionClauseSyntax;
    }
    class EventDeclarationSyntax extends BasePropertyDeclarationSyntax {
        private attributeLists;
        private type;
        private explicitInterfaceSpecifier;
        private accessorList;
        constructor();
        ctor_1337(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): EventDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        EventKeyword: SyntaxToken;
        Type: TypeSyntax;
        ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        Identifier: SyntaxToken;
        AccessorList: AccessorListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax): EventDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): EventDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): EventDeclarationSyntax;
        WithEventKeyword(eventKeyword: SyntaxToken): EventDeclarationSyntax;
        WithType(type: TypeSyntax): EventDeclarationSyntax;
        WithExplicitInterfaceSpecifier(explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax): EventDeclarationSyntax;
        WithIdentifier(identifier: SyntaxToken): EventDeclarationSyntax;
        WithAccessorList(accessorList: AccessorListSyntax): EventDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): EventDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): EventDeclarationSyntax;
        AddAccessorListAccessors(...items: AccessorDeclarationSyntax[]): EventDeclarationSyntax;
    }
    class IndexerDeclarationSyntax extends BasePropertyDeclarationSyntax {
        private attributeLists;
        private type;
        private explicitInterfaceSpecifier;
        private parameterList;
        private accessorList;
        private expressionBody;
        constructor();
        ctor_3620(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): IndexerDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Type: TypeSyntax;
        ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        ThisKeyword: SyntaxToken;
        ParameterList: BracketedParameterListSyntax;
        AccessorList: AccessorListSyntax;
        ExpressionBody: ArrowExpressionClauseSyntax;
        Semicolon: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken): IndexerDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): IndexerDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): IndexerDeclarationSyntax;
        WithType(type: TypeSyntax): IndexerDeclarationSyntax;
        WithExplicitInterfaceSpecifier(explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax): IndexerDeclarationSyntax;
        WithThisKeyword(thisKeyword: SyntaxToken): IndexerDeclarationSyntax;
        WithParameterList(parameterList: BracketedParameterListSyntax): IndexerDeclarationSyntax;
        WithAccessorList(accessorList: AccessorListSyntax): IndexerDeclarationSyntax;
        WithExpressionBody(expressionBody: ArrowExpressionClauseSyntax): IndexerDeclarationSyntax;
        WithSemicolon(semicolon: SyntaxToken): IndexerDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): IndexerDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): IndexerDeclarationSyntax;
        AddParameterListParameters(...items: ParameterSyntax[]): IndexerDeclarationSyntax;
        AddAccessorListAccessors(...items: AccessorDeclarationSyntax[]): IndexerDeclarationSyntax;
    }
    class AccessorListSyntax extends CSharpSyntaxNode {
        private accessors;
        constructor();
        ctor_1609(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AccessorListSyntax;
        OpenBraceToken: SyntaxToken;
        Accessors: SyntaxList<AccessorDeclarationSyntax>;
        CloseBraceToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBraceToken: SyntaxToken, accessors: SyntaxList<AccessorDeclarationSyntax>, closeBraceToken: SyntaxToken): AccessorListSyntax;
        WithOpenBraceToken(openBraceToken: SyntaxToken): AccessorListSyntax;
        WithAccessors(accessors: SyntaxList<AccessorDeclarationSyntax>): AccessorListSyntax;
        WithCloseBraceToken(closeBraceToken: SyntaxToken): AccessorListSyntax;
        AddAccessors(...items: AccessorDeclarationSyntax[]): AccessorListSyntax;
    }
    class AccessorDeclarationSyntax extends CSharpSyntaxNode {
        private attributeLists;
        private body;
        constructor();
        ctor_1760(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): AccessorDeclarationSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Keyword: SyntaxToken;
        Body: BlockSyntax;
        SemicolonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken): AccessorDeclarationSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): AccessorDeclarationSyntax;
        WithModifiers(modifiers: SyntaxTokenList): AccessorDeclarationSyntax;
        WithKeyword(keyword: SyntaxToken): AccessorDeclarationSyntax;
        WithBody(body: BlockSyntax): AccessorDeclarationSyntax;
        WithSemicolonToken(semicolonToken: SyntaxToken): AccessorDeclarationSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): AccessorDeclarationSyntax;
        AddModifiers(...items: SyntaxToken[]): AccessorDeclarationSyntax;
        AddBodyStatements(...items: StatementSyntax[]): AccessorDeclarationSyntax;
    }
    class BaseParameterListSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1577(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BaseParameterListSyntax;
        Parameters: SeparatedSyntaxList<ParameterSyntax>;
    }
    class ParameterListSyntax extends BaseParameterListSyntax {
        private parameters;
        constructor();
        ctor_1013(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ParameterListSyntax;
        OpenParenToken: SyntaxToken;
        Parameters: SeparatedSyntaxList<ParameterSyntax>;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<ParameterSyntax>, closeParenToken: SyntaxToken): ParameterListSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): ParameterListSyntax;
        WithParameters(parameters: SeparatedSyntaxList<ParameterSyntax>): ParameterListSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): ParameterListSyntax;
        AddParameters(...items: ParameterSyntax[]): ParameterListSyntax;
    }
    class BracketedParameterListSyntax extends BaseParameterListSyntax {
        private parameters;
        constructor();
        ctor_2140(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BracketedParameterListSyntax;
        OpenBracketToken: SyntaxToken;
        Parameters: SeparatedSyntaxList<ParameterSyntax>;
        CloseBracketToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<ParameterSyntax>, closeBracketToken: SyntaxToken): BracketedParameterListSyntax;
        WithOpenBracketToken(openBracketToken: SyntaxToken): BracketedParameterListSyntax;
        WithParameters(parameters: SeparatedSyntaxList<ParameterSyntax>): BracketedParameterListSyntax;
        WithCloseBracketToken(closeBracketToken: SyntaxToken): BracketedParameterListSyntax;
        AddParameters(...items: ParameterSyntax[]): BracketedParameterListSyntax;
    }
    class ParameterSyntax extends CSharpSyntaxNode {
        private attributeLists;
        private type;
        private $default;
        constructor();
        ctor_1019(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ParameterSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Type: TypeSyntax;
        Identifier: SyntaxToken;
        Default: EqualsValueClauseSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax): ParameterSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): ParameterSyntax;
        WithModifiers(modifiers: SyntaxTokenList): ParameterSyntax;
        WithType(type: TypeSyntax): ParameterSyntax;
        WithIdentifier(identifier: SyntaxToken): ParameterSyntax;
        WithDefault($default: EqualsValueClauseSyntax): ParameterSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): ParameterSyntax;
        AddModifiers(...items: SyntaxToken[]): ParameterSyntax;
    }
    class IncompleteMemberSyntax extends MemberDeclarationSyntax {
        private attributeLists;
        private type;
        constructor();
        ctor_1857(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): IncompleteMemberSyntax;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Modifiers: SyntaxTokenList;
        Type: TypeSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxTokenList, type: TypeSyntax): IncompleteMemberSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): IncompleteMemberSyntax;
        WithModifiers(modifiers: SyntaxTokenList): IncompleteMemberSyntax;
        WithType(type: TypeSyntax): IncompleteMemberSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): IncompleteMemberSyntax;
        AddModifiers(...items: SyntaxToken[]): IncompleteMemberSyntax;
    }
    class SkippedTokensTriviaSyntax extends StructuredTriviaSyntax {
        constructor();
        ctor_9665(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): SkippedTokensTriviaSyntax;
        Tokens: SyntaxTokenList;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(tokens: SyntaxTokenList): SkippedTokensTriviaSyntax;
        WithTokens(tokens: SyntaxTokenList): SkippedTokensTriviaSyntax;
        AddTokens(...items: SyntaxToken[]): SkippedTokensTriviaSyntax;
    }
    class DocumentationCommentTriviaSyntax extends StructuredTriviaSyntax {
        private content;
        constructor();
        ctor_4695(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): DocumentationCommentTriviaSyntax;
        Content: SyntaxList<XmlNodeSyntax>;
        EndOfComment: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(content: SyntaxList<XmlNodeSyntax>, endOfComment: SyntaxToken): DocumentationCommentTriviaSyntax;
        WithContent(content: SyntaxList<XmlNodeSyntax>): DocumentationCommentTriviaSyntax;
        WithEndOfComment(endOfComment: SyntaxToken): DocumentationCommentTriviaSyntax;
        AddContent(...items: XmlNodeSyntax[]): DocumentationCommentTriviaSyntax;
    }
    class CrefSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_7314(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CrefSyntax;
    }
    class TypeCrefSyntax extends CrefSyntax {
        private type;
        constructor();
        ctor_9808(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): TypeCrefSyntax;
        Type: TypeSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(type: TypeSyntax): TypeCrefSyntax;
        WithType(type: TypeSyntax): TypeCrefSyntax;
    }
    class QualifiedCrefSyntax extends CrefSyntax {
        private container;
        private member;
        constructor();
        ctor_9087(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): QualifiedCrefSyntax;
        Container: TypeSyntax;
        DotToken: SyntaxToken;
        Member: MemberCrefSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax): QualifiedCrefSyntax;
        WithContainer(container: TypeSyntax): QualifiedCrefSyntax;
        WithDotToken(dotToken: SyntaxToken): QualifiedCrefSyntax;
        WithMember(member: MemberCrefSyntax): QualifiedCrefSyntax;
    }
    class MemberCrefSyntax extends CrefSyntax {
        constructor();
        ctor_1516(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): MemberCrefSyntax;
    }
    class NameMemberCrefSyntax extends MemberCrefSyntax {
        private name;
        private parameters;
        constructor();
        ctor_6585(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): NameMemberCrefSyntax;
        Name: TypeSyntax;
        Parameters: CrefParameterListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: TypeSyntax, parameters: CrefParameterListSyntax): NameMemberCrefSyntax;
        WithName(name: TypeSyntax): NameMemberCrefSyntax;
        WithParameters(parameters: CrefParameterListSyntax): NameMemberCrefSyntax;
        AddParametersParameters(...items: CrefParameterSyntax[]): NameMemberCrefSyntax;
    }
    class IndexerMemberCrefSyntax extends MemberCrefSyntax {
        private parameters;
        constructor();
        ctor_1598(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): IndexerMemberCrefSyntax;
        ThisKeyword: SyntaxToken;
        Parameters: CrefBracketedParameterListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax): IndexerMemberCrefSyntax;
        WithThisKeyword(thisKeyword: SyntaxToken): IndexerMemberCrefSyntax;
        WithParameters(parameters: CrefBracketedParameterListSyntax): IndexerMemberCrefSyntax;
        AddParametersParameters(...items: CrefParameterSyntax[]): IndexerMemberCrefSyntax;
    }
    class OperatorMemberCrefSyntax extends MemberCrefSyntax {
        private parameters;
        constructor();
        ctor_1011(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): OperatorMemberCrefSyntax;
        OperatorKeyword: SyntaxToken;
        OperatorToken: SyntaxToken;
        Parameters: CrefParameterListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax): OperatorMemberCrefSyntax;
        WithOperatorKeyword(operatorKeyword: SyntaxToken): OperatorMemberCrefSyntax;
        WithOperatorToken(operatorToken: SyntaxToken): OperatorMemberCrefSyntax;
        WithParameters(parameters: CrefParameterListSyntax): OperatorMemberCrefSyntax;
        AddParametersParameters(...items: CrefParameterSyntax[]): OperatorMemberCrefSyntax;
    }
    class ConversionOperatorMemberCrefSyntax extends MemberCrefSyntax {
        private type;
        private parameters;
        constructor();
        ctor_1441(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ConversionOperatorMemberCrefSyntax;
        ImplicitOrExplicitKeyword: SyntaxToken;
        OperatorKeyword: SyntaxToken;
        Type: TypeSyntax;
        Parameters: CrefParameterListSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax): ConversionOperatorMemberCrefSyntax;
        WithImplicitOrExplicitKeyword(implicitOrExplicitKeyword: SyntaxToken): ConversionOperatorMemberCrefSyntax;
        WithOperatorKeyword(operatorKeyword: SyntaxToken): ConversionOperatorMemberCrefSyntax;
        WithType(type: TypeSyntax): ConversionOperatorMemberCrefSyntax;
        WithParameters(parameters: CrefParameterListSyntax): ConversionOperatorMemberCrefSyntax;
        AddParametersParameters(...items: CrefParameterSyntax[]): ConversionOperatorMemberCrefSyntax;
    }
    class BaseCrefParameterListSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_9114(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BaseCrefParameterListSyntax;
        Parameters: SeparatedSyntaxList<CrefParameterSyntax>;
    }
    class CrefParameterListSyntax extends BaseCrefParameterListSyntax {
        private parameters;
        constructor();
        ctor_1513(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CrefParameterListSyntax;
        OpenParenToken: SyntaxToken;
        Parameters: SeparatedSyntaxList<CrefParameterSyntax>;
        CloseParenToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<CrefParameterSyntax>, closeParenToken: SyntaxToken): CrefParameterListSyntax;
        WithOpenParenToken(openParenToken: SyntaxToken): CrefParameterListSyntax;
        WithParameters(parameters: SeparatedSyntaxList<CrefParameterSyntax>): CrefParameterListSyntax;
        WithCloseParenToken(closeParenToken: SyntaxToken): CrefParameterListSyntax;
        AddParameters(...items: CrefParameterSyntax[]): CrefParameterListSyntax;
    }
    class CrefBracketedParameterListSyntax extends BaseCrefParameterListSyntax {
        private parameters;
        constructor();
        ctor_9776(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CrefBracketedParameterListSyntax;
        OpenBracketToken: SyntaxToken;
        Parameters: SeparatedSyntaxList<CrefParameterSyntax>;
        CloseBracketToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<CrefParameterSyntax>, closeBracketToken: SyntaxToken): CrefBracketedParameterListSyntax;
        WithOpenBracketToken(openBracketToken: SyntaxToken): CrefBracketedParameterListSyntax;
        WithParameters(parameters: SeparatedSyntaxList<CrefParameterSyntax>): CrefBracketedParameterListSyntax;
        WithCloseBracketToken(closeBracketToken: SyntaxToken): CrefBracketedParameterListSyntax;
        AddParameters(...items: CrefParameterSyntax[]): CrefBracketedParameterListSyntax;
    }
    class CrefParameterSyntax extends CSharpSyntaxNode {
        private type;
        constructor();
        ctor_1978(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CrefParameterSyntax;
        RefOrOutKeyword: SyntaxToken;
        Type: TypeSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(refOrOutKeyword: SyntaxToken, type: TypeSyntax): CrefParameterSyntax;
        WithRefOrOutKeyword(refOrOutKeyword: SyntaxToken): CrefParameterSyntax;
        WithType(type: TypeSyntax): CrefParameterSyntax;
    }
    class XmlNodeSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1957(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlNodeSyntax;
    }
    class XmlElementSyntax extends XmlNodeSyntax {
        private startTag;
        private content;
        private endTag;
        constructor();
        ctor_3794(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlElementSyntax;
        StartTag: XmlElementStartTagSyntax;
        Content: SyntaxList<XmlNodeSyntax>;
        EndTag: XmlElementEndTagSyntax;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(startTag: XmlElementStartTagSyntax, content: SyntaxList<XmlNodeSyntax>, endTag: XmlElementEndTagSyntax): XmlElementSyntax;
        WithStartTag(startTag: XmlElementStartTagSyntax): XmlElementSyntax;
        WithContent(content: SyntaxList<XmlNodeSyntax>): XmlElementSyntax;
        WithEndTag(endTag: XmlElementEndTagSyntax): XmlElementSyntax;
        AddStartTagAttributes(...items: XmlAttributeSyntax[]): XmlElementSyntax;
        AddContent(...items: XmlNodeSyntax[]): XmlElementSyntax;
    }
    class XmlElementStartTagSyntax extends CSharpSyntaxNode {
        private name;
        private attributes;
        constructor();
        ctor_1010(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlElementStartTagSyntax;
        LessThanToken: SyntaxToken;
        Name: XmlNameSyntax;
        Attributes: SyntaxList<XmlAttributeSyntax>;
        GreaterThanToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: SyntaxList<XmlAttributeSyntax>, greaterThanToken: SyntaxToken): XmlElementStartTagSyntax;
        WithLessThanToken(lessThanToken: SyntaxToken): XmlElementStartTagSyntax;
        WithName(name: XmlNameSyntax): XmlElementStartTagSyntax;
        WithAttributes(attributes: SyntaxList<XmlAttributeSyntax>): XmlElementStartTagSyntax;
        WithGreaterThanToken(greaterThanToken: SyntaxToken): XmlElementStartTagSyntax;
        AddAttributes(...items: XmlAttributeSyntax[]): XmlElementStartTagSyntax;
    }
    class XmlElementEndTagSyntax extends CSharpSyntaxNode {
        private name;
        constructor();
        ctor_7385(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlElementEndTagSyntax;
        LessThanSlashToken: SyntaxToken;
        Name: XmlNameSyntax;
        GreaterThanToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken): XmlElementEndTagSyntax;
        WithLessThanSlashToken(lessThanSlashToken: SyntaxToken): XmlElementEndTagSyntax;
        WithName(name: XmlNameSyntax): XmlElementEndTagSyntax;
        WithGreaterThanToken(greaterThanToken: SyntaxToken): XmlElementEndTagSyntax;
    }
    class XmlEmptyElementSyntax extends XmlNodeSyntax {
        private name;
        private attributes;
        constructor();
        ctor_8541(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlEmptyElementSyntax;
        LessThanToken: SyntaxToken;
        Name: XmlNameSyntax;
        Attributes: SyntaxList<XmlAttributeSyntax>;
        SlashGreaterThanToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: SyntaxList<XmlAttributeSyntax>, slashGreaterThanToken: SyntaxToken): XmlEmptyElementSyntax;
        WithLessThanToken(lessThanToken: SyntaxToken): XmlEmptyElementSyntax;
        WithName(name: XmlNameSyntax): XmlEmptyElementSyntax;
        WithAttributes(attributes: SyntaxList<XmlAttributeSyntax>): XmlEmptyElementSyntax;
        WithSlashGreaterThanToken(slashGreaterThanToken: SyntaxToken): XmlEmptyElementSyntax;
        AddAttributes(...items: XmlAttributeSyntax[]): XmlEmptyElementSyntax;
    }
    class XmlNameSyntax extends CSharpSyntaxNode {
        private prefix;
        constructor();
        ctor_3909(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlNameSyntax;
        Prefix: XmlPrefixSyntax;
        LocalName: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(prefix: XmlPrefixSyntax, localName: SyntaxToken): XmlNameSyntax;
        WithPrefix(prefix: XmlPrefixSyntax): XmlNameSyntax;
        WithLocalName(localName: SyntaxToken): XmlNameSyntax;
    }
    class XmlPrefixSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_2531(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlPrefixSyntax;
        Prefix: SyntaxToken;
        ColonToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(prefix: SyntaxToken, colonToken: SyntaxToken): XmlPrefixSyntax;
        WithPrefix(prefix: SyntaxToken): XmlPrefixSyntax;
        WithColonToken(colonToken: SyntaxToken): XmlPrefixSyntax;
    }
    class XmlAttributeSyntax extends CSharpSyntaxNode {
        constructor();
        ctor_1306(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlAttributeSyntax;
        Name: XmlNameSyntax;
        EqualsToken: SyntaxToken;
        StartQuoteToken: SyntaxToken;
        EndQuoteToken: SyntaxToken;
    }
    class XmlTextAttributeSyntax extends XmlAttributeSyntax {
        private name;
        constructor();
        ctor_1853(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlTextAttributeSyntax;
        Name: XmlNameSyntax;
        EqualsToken: SyntaxToken;
        StartQuoteToken: SyntaxToken;
        TextTokens: SyntaxTokenList;
        EndQuoteToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: SyntaxTokenList, endQuoteToken: SyntaxToken): XmlTextAttributeSyntax;
        WithName(name: XmlNameSyntax): XmlTextAttributeSyntax;
        WithEqualsToken(equalsToken: SyntaxToken): XmlTextAttributeSyntax;
        WithStartQuoteToken(startQuoteToken: SyntaxToken): XmlTextAttributeSyntax;
        WithTextTokens(textTokens: SyntaxTokenList): XmlTextAttributeSyntax;
        WithEndQuoteToken(endQuoteToken: SyntaxToken): XmlTextAttributeSyntax;
        AddTextTokens(...items: SyntaxToken[]): XmlTextAttributeSyntax;
    }
    class XmlCrefAttributeSyntax extends XmlAttributeSyntax {
        private name;
        private cref;
        constructor();
        ctor_1305(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlCrefAttributeSyntax;
        Name: XmlNameSyntax;
        EqualsToken: SyntaxToken;
        StartQuoteToken: SyntaxToken;
        Cref: CrefSyntax;
        EndQuoteToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken): XmlCrefAttributeSyntax;
        WithName(name: XmlNameSyntax): XmlCrefAttributeSyntax;
        WithEqualsToken(equalsToken: SyntaxToken): XmlCrefAttributeSyntax;
        WithStartQuoteToken(startQuoteToken: SyntaxToken): XmlCrefAttributeSyntax;
        WithCref(cref: CrefSyntax): XmlCrefAttributeSyntax;
        WithEndQuoteToken(endQuoteToken: SyntaxToken): XmlCrefAttributeSyntax;
    }
    class XmlNameAttributeSyntax extends XmlAttributeSyntax {
        private name;
        private identifier;
        constructor();
        ctor_1624(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlNameAttributeSyntax;
        Name: XmlNameSyntax;
        EqualsToken: SyntaxToken;
        StartQuoteToken: SyntaxToken;
        Identifier: IdentifierNameSyntax;
        EndQuoteToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken): XmlNameAttributeSyntax;
        WithName(name: XmlNameSyntax): XmlNameAttributeSyntax;
        WithEqualsToken(equalsToken: SyntaxToken): XmlNameAttributeSyntax;
        WithStartQuoteToken(startQuoteToken: SyntaxToken): XmlNameAttributeSyntax;
        WithIdentifier(identifier: IdentifierNameSyntax): XmlNameAttributeSyntax;
        WithEndQuoteToken(endQuoteToken: SyntaxToken): XmlNameAttributeSyntax;
    }
    class XmlTextSyntax extends XmlNodeSyntax {
        constructor();
        ctor_1447(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlTextSyntax;
        TextTokens: SyntaxTokenList;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(textTokens: SyntaxTokenList): XmlTextSyntax;
        WithTextTokens(textTokens: SyntaxTokenList): XmlTextSyntax;
        AddTextTokens(...items: SyntaxToken[]): XmlTextSyntax;
    }
    class XmlCDataSectionSyntax extends XmlNodeSyntax {
        constructor();
        ctor_5139(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlCDataSectionSyntax;
        StartCDataToken: SyntaxToken;
        TextTokens: SyntaxTokenList;
        EndCDataToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(startCDataToken: SyntaxToken, textTokens: SyntaxTokenList, endCDataToken: SyntaxToken): XmlCDataSectionSyntax;
        WithStartCDataToken(startCDataToken: SyntaxToken): XmlCDataSectionSyntax;
        WithTextTokens(textTokens: SyntaxTokenList): XmlCDataSectionSyntax;
        WithEndCDataToken(endCDataToken: SyntaxToken): XmlCDataSectionSyntax;
        AddTextTokens(...items: SyntaxToken[]): XmlCDataSectionSyntax;
    }
    class XmlProcessingInstructionSyntax extends XmlNodeSyntax {
        private name;
        constructor();
        ctor_3449(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlProcessingInstructionSyntax;
        StartProcessingInstructionToken: SyntaxToken;
        Name: XmlNameSyntax;
        TextTokens: SyntaxTokenList;
        EndProcessingInstructionToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: SyntaxTokenList, endProcessingInstructionToken: SyntaxToken): XmlProcessingInstructionSyntax;
        WithStartProcessingInstructionToken(startProcessingInstructionToken: SyntaxToken): XmlProcessingInstructionSyntax;
        WithName(name: XmlNameSyntax): XmlProcessingInstructionSyntax;
        WithTextTokens(textTokens: SyntaxTokenList): XmlProcessingInstructionSyntax;
        WithEndProcessingInstructionToken(endProcessingInstructionToken: SyntaxToken): XmlProcessingInstructionSyntax;
        AddTextTokens(...items: SyntaxToken[]): XmlProcessingInstructionSyntax;
    }
    class XmlCommentSyntax extends XmlNodeSyntax {
        constructor();
        ctor_1807(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): XmlCommentSyntax;
        LessThanExclamationMinusMinusToken: SyntaxToken;
        TextTokens: SyntaxTokenList;
        MinusMinusGreaterThanToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: SyntaxTokenList, minusMinusGreaterThanToken: SyntaxToken): XmlCommentSyntax;
        WithLessThanExclamationMinusMinusToken(lessThanExclamationMinusMinusToken: SyntaxToken): XmlCommentSyntax;
        WithTextTokens(textTokens: SyntaxTokenList): XmlCommentSyntax;
        WithMinusMinusGreaterThanToken(minusMinusGreaterThanToken: SyntaxToken): XmlCommentSyntax;
        AddTextTokens(...items: SyntaxToken[]): XmlCommentSyntax;
    }
    class BranchingDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_4303(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BranchingDirectiveTriviaSyntax;
        BranchTaken: boolean;
    }
    class ConditionalDirectiveTriviaSyntax extends BranchingDirectiveTriviaSyntax {
        constructor();
        ctor_1842(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ConditionalDirectiveTriviaSyntax;
        Condition: ExpressionSyntax;
        ConditionValue: boolean;
    }
    class IfDirectiveTriviaSyntax extends ConditionalDirectiveTriviaSyntax {
        private condition;
        constructor();
        ctor_1844(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): IfDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        IfKeyword: SyntaxToken;
        Condition: ExpressionSyntax;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        BranchTaken: boolean;
        ConditionValue: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): IfDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): IfDirectiveTriviaSyntax;
        WithIfKeyword(ifKeyword: SyntaxToken): IfDirectiveTriviaSyntax;
        WithCondition(condition: ExpressionSyntax): IfDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): IfDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): IfDirectiveTriviaSyntax;
        WithBranchTaken(branchTaken: boolean): IfDirectiveTriviaSyntax;
        WithConditionValue(conditionValue: boolean): IfDirectiveTriviaSyntax;
    }
    class ElifDirectiveTriviaSyntax extends ConditionalDirectiveTriviaSyntax {
        private condition;
        constructor();
        ctor_1977(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ElifDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        ElifKeyword: SyntaxToken;
        Condition: ExpressionSyntax;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        BranchTaken: boolean;
        ConditionValue: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): ElifDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): ElifDirectiveTriviaSyntax;
        WithElifKeyword(elifKeyword: SyntaxToken): ElifDirectiveTriviaSyntax;
        WithCondition(condition: ExpressionSyntax): ElifDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): ElifDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): ElifDirectiveTriviaSyntax;
        WithBranchTaken(branchTaken: boolean): ElifDirectiveTriviaSyntax;
        WithConditionValue(conditionValue: boolean): ElifDirectiveTriviaSyntax;
    }
    class ElseDirectiveTriviaSyntax extends BranchingDirectiveTriviaSyntax {
        constructor();
        ctor_1939(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ElseDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        ElseKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        BranchTaken: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean): ElseDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): ElseDirectiveTriviaSyntax;
        WithElseKeyword(elseKeyword: SyntaxToken): ElseDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): ElseDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): ElseDirectiveTriviaSyntax;
        WithBranchTaken(branchTaken: boolean): ElseDirectiveTriviaSyntax;
    }
    class EndIfDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_1812(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): EndIfDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        EndIfKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndIfDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): EndIfDirectiveTriviaSyntax;
        WithEndIfKeyword(endIfKeyword: SyntaxToken): EndIfDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): EndIfDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): EndIfDirectiveTriviaSyntax;
    }
    class RegionDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_1446(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): RegionDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        RegionKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): RegionDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): RegionDirectiveTriviaSyntax;
        WithRegionKeyword(regionKeyword: SyntaxToken): RegionDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): RegionDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): RegionDirectiveTriviaSyntax;
    }
    class EndRegionDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_2484(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): EndRegionDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        EndRegionKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndRegionDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): EndRegionDirectiveTriviaSyntax;
        WithEndRegionKeyword(endRegionKeyword: SyntaxToken): EndRegionDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): EndRegionDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): EndRegionDirectiveTriviaSyntax;
    }
    class ErrorDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_1813(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ErrorDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        ErrorKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ErrorDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): ErrorDirectiveTriviaSyntax;
        WithErrorKeyword(errorKeyword: SyntaxToken): ErrorDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): ErrorDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): ErrorDirectiveTriviaSyntax;
    }
    class WarningDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_1762(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): WarningDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        WarningKeyword: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): WarningDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): WarningDirectiveTriviaSyntax;
        WithWarningKeyword(warningKeyword: SyntaxToken): WarningDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): WarningDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): WarningDirectiveTriviaSyntax;
    }
    class BadDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_8533(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): BadDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        Identifier: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): BadDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): BadDirectiveTriviaSyntax;
        WithIdentifier(identifier: SyntaxToken): BadDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): BadDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): BadDirectiveTriviaSyntax;
    }
    class DefineDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_1613(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): DefineDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        DefineKeyword: SyntaxToken;
        Name: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): DefineDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): DefineDirectiveTriviaSyntax;
        WithDefineKeyword(defineKeyword: SyntaxToken): DefineDirectiveTriviaSyntax;
        WithName(name: SyntaxToken): DefineDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): DefineDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): DefineDirectiveTriviaSyntax;
    }
    class UndefDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_2071(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): UndefDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        UndefKeyword: SyntaxToken;
        Name: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): UndefDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): UndefDirectiveTriviaSyntax;
        WithUndefKeyword(undefKeyword: SyntaxToken): UndefDirectiveTriviaSyntax;
        WithName(name: SyntaxToken): UndefDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): UndefDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): UndefDirectiveTriviaSyntax;
    }
    class LineDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_1199(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): LineDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        LineKeyword: SyntaxToken;
        Line: SyntaxToken;
        File: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): LineDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): LineDirectiveTriviaSyntax;
        WithLineKeyword(lineKeyword: SyntaxToken): LineDirectiveTriviaSyntax;
        WithLine(line: SyntaxToken): LineDirectiveTriviaSyntax;
        WithFile(file: SyntaxToken): LineDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): LineDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): LineDirectiveTriviaSyntax;
    }
    class PragmaWarningDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        private errorCodes;
        constructor();
        ctor_7374(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): PragmaWarningDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        PragmaKeyword: SyntaxToken;
        WarningKeyword: SyntaxToken;
        DisableOrRestoreKeyword: SyntaxToken;
        ErrorCodes: SeparatedSyntaxList<ExpressionSyntax>;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: SeparatedSyntaxList<ExpressionSyntax>, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaWarningDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): PragmaWarningDirectiveTriviaSyntax;
        WithPragmaKeyword(pragmaKeyword: SyntaxToken): PragmaWarningDirectiveTriviaSyntax;
        WithWarningKeyword(warningKeyword: SyntaxToken): PragmaWarningDirectiveTriviaSyntax;
        WithDisableOrRestoreKeyword(disableOrRestoreKeyword: SyntaxToken): PragmaWarningDirectiveTriviaSyntax;
        WithErrorCodes(errorCodes: SeparatedSyntaxList<ExpressionSyntax>): PragmaWarningDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): PragmaWarningDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): PragmaWarningDirectiveTriviaSyntax;
        AddErrorCodes(...items: ExpressionSyntax[]): PragmaWarningDirectiveTriviaSyntax;
    }
    class PragmaChecksumDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_1261(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): PragmaChecksumDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        PragmaKeyword: SyntaxToken;
        ChecksumKeyword: SyntaxToken;
        File: SyntaxToken;
        Guid: SyntaxToken;
        Bytes: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaChecksumDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): PragmaChecksumDirectiveTriviaSyntax;
        WithPragmaKeyword(pragmaKeyword: SyntaxToken): PragmaChecksumDirectiveTriviaSyntax;
        WithChecksumKeyword(checksumKeyword: SyntaxToken): PragmaChecksumDirectiveTriviaSyntax;
        WithFile(file: SyntaxToken): PragmaChecksumDirectiveTriviaSyntax;
        WithGuid(guid: SyntaxToken): PragmaChecksumDirectiveTriviaSyntax;
        WithBytes(bytes: SyntaxToken): PragmaChecksumDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): PragmaChecksumDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): PragmaChecksumDirectiveTriviaSyntax;
    }
    class ReferenceDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor();
        ctor_1757(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): ReferenceDirectiveTriviaSyntax;
        HashToken: SyntaxToken;
        ReferenceKeyword: SyntaxToken;
        File: SyntaxToken;
        EndOfDirectiveToken: SyntaxToken;
        IsActive: boolean;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ReferenceDirectiveTriviaSyntax;
        WithHashToken(hashToken: SyntaxToken): ReferenceDirectiveTriviaSyntax;
        WithReferenceKeyword(referenceKeyword: SyntaxToken): ReferenceDirectiveTriviaSyntax;
        WithFile(file: SyntaxToken): ReferenceDirectiveTriviaSyntax;
        WithEndOfDirectiveToken(endOfDirectiveToken: SyntaxToken): ReferenceDirectiveTriviaSyntax;
        WithIsActive(isActive: boolean): ReferenceDirectiveTriviaSyntax;
    }
    class InterpolatedStringSyntax extends ExpressionSyntax {
        private interpolatedInserts;
        constructor();
        ctor_1690(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): InterpolatedStringSyntax;
        StringStart: SyntaxToken;
        InterpolatedInserts: SeparatedSyntaxList<InterpolatedStringInsertSyntax>;
        StringEnd: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(stringStart: SyntaxToken, interpolatedInserts: SeparatedSyntaxList<InterpolatedStringInsertSyntax>, stringEnd: SyntaxToken): InterpolatedStringSyntax;
        WithStringStart(stringStart: SyntaxToken): InterpolatedStringSyntax;
        WithInterpolatedInserts(interpolatedInserts: SeparatedSyntaxList<InterpolatedStringInsertSyntax>): InterpolatedStringSyntax;
        WithStringEnd(stringEnd: SyntaxToken): InterpolatedStringSyntax;
        AddInterpolatedInserts(...items: InterpolatedStringInsertSyntax[]): InterpolatedStringSyntax;
    }
    class InterpolatedStringInsertSyntax extends CSharpSyntaxNode {
        private expression;
        private alignment;
        constructor();
        ctor_1720(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): InterpolatedStringInsertSyntax;
        Expression: ExpressionSyntax;
        Comma: SyntaxToken;
        Alignment: ExpressionSyntax;
        Format: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken): InterpolatedStringInsertSyntax;
        WithExpression(expression: ExpressionSyntax): InterpolatedStringInsertSyntax;
        WithComma(comma: SyntaxToken): InterpolatedStringInsertSyntax;
        WithAlignment(alignment: ExpressionSyntax): InterpolatedStringInsertSyntax;
        WithFormat(format: SyntaxToken): InterpolatedStringInsertSyntax;
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class AbstractLexer implements System.IDisposable {
        TextWindow: SlidingTextWindow;
        private errors;
        ctor_1225(text: Text.SourceText): AbstractLexer;
        Dispose(): void;
        protected Start(): void;
        protected HasErrors: boolean;
        protected GetErrors(leadingTriviaWidth: number): SyntaxDiagnosticInfo[];
        protected AddError_1749(position: number, width: number, code: ErrorCode): void;
        protected AddError_1288(position: number, width: number, code: ErrorCode, ...args: Object[]): void;
        protected AddError_1315(position: number, width: number, code: XmlParseErrorCode, ...args: Object[]): void;
        protected AddError_1261(code: ErrorCode): void;
        protected AddError_1515(code: ErrorCode, ...args: Object[]): void;
        protected AddError_2006(code: XmlParseErrorCode): void;
        protected AddError_2611(code: XmlParseErrorCode, ...args: Object[]): void;
        protected AddError_9129(error: SyntaxDiagnosticInfo): void;
        MakeError_1764(position: number, width: number, code: ErrorCode): SyntaxDiagnosticInfo;
        MakeError_1930(position: number, width: number, code: ErrorCode, ...args: Object[]): SyntaxDiagnosticInfo;
        MakeError_1925(position: number, width: number, code: XmlParseErrorCode, ...args: Object[]): XmlSyntaxDiagnosticInfo;
        private GetLexemeOffsetFromPosition(position);
        protected static MakeError_4977(code: ErrorCode): SyntaxDiagnosticInfo;
        protected static MakeError_2338(code: ErrorCode, ...args: Object[]): SyntaxDiagnosticInfo;
        protected static MakeError_5849(code: XmlParseErrorCode): XmlSyntaxDiagnosticInfo;
        protected static MakeError_1869(code: XmlParseErrorCode, ...args: Object[]): XmlSyntaxDiagnosticInfo;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class BlendedNode implements IStruct {
        Node: CSharp.CSharpSyntaxNode;
        Token: SyntaxToken;
        Blender: Blender;
        ctor_1181(node: CSharp.CSharpSyntaxNode, token: SyntaxToken, blender: Blender): BlendedNode;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class Blender implements IStruct {
        lexer: Lexer;
        oldTreeCursor: Blender.Cursor;
        changes: System.Collections.Immutable.ImmutableStack<Text.TextChangeRange>;
        newPosition: number;
        changeDelta: number;
        newDirectives: DirectiveStack;
        oldDirectives: DirectiveStack;
        newLexerDrivenMode: LexerMode;
        ctor_1633(lexer: Lexer, oldTree: CSharp.CSharpSyntaxNode, changes: System.Collections.Generic.IEnumerable<Text.TextChangeRange>): Blender;
        ctor_7593(lexer: Lexer, oldTreeCursor: Blender.Cursor, changes: System.Collections.Immutable.ImmutableStack<Text.TextChangeRange>, newPosition: number, changeDelta: number, newDirectives: DirectiveStack, oldDirectives: DirectiveStack, newLexerDrivenMode: LexerMode): Blender;
        private static ExtendToAffectedRange(oldTree, changeRange);
        private static IsInsideInterpolation(oldTree, start);
        ReadNode(mode: LexerMode): BlendedNode;
        ReadToken(mode: LexerMode): BlendedNode;
        private ReadNodeOrToken(mode, asToken);
        constructor();
    }
    module Blender {
        class Cursor implements IStruct {
            CurrentNodeOrToken: SyntaxNodeOrToken;
            private indexInParent;
            ctor_2409(node: SyntaxNodeOrToken, indexInParent: number): Cursor;
            static FromRoot(node: CSharp.CSharpSyntaxNode): Cursor;
            IsFinished: boolean;
            private static IsNonZeroWidthOrIsEndOfFile(token);
            MoveToNextSibling(): Cursor;
            private MoveToParent();
            private static IndexOfNodeInParent(node);
            MoveToFirstChild(): Cursor;
            MoveToFirstToken(): Cursor;
            constructor();
        }
        class Reader implements IStruct {
            private lexer;
            private oldTreeCursor;
            private changes;
            private newPosition;
            private changeDelta;
            private newDirectives;
            private oldDirectives;
            private newLexerDrivenMode;
            ctor_4504(blender: Blender): Reader;
            ReadNodeOrToken(mode: LexerMode, asToken: boolean): BlendedNode;
            private SkipOldToken();
            private SkipPastChanges();
            private ReadNewToken(mode);
            private LexNewToken(mode);
            private TryTakeOldNodeOrToken(asToken, blendedNode);
            private CanReuse(nodeOrToken);
            private IntersectsNextChange(nodeOrToken);
            private static IsIncomplete(node);
            private static IsFabricatedToken(kind);
            private CreateBlendedNode(node, token);
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class SyntaxFacts {
        static IsKeywordKind(kind: SyntaxKind): boolean;
        static GetReservedKeywordKinds(): System.Collections.Generic.IEnumerable<SyntaxKind>;
        static GetKeywordKinds(): System.Collections.Generic.IEnumerable<SyntaxKind>;
        static IsReservedKeyword(kind: SyntaxKind): boolean;
        static IsAttributeTargetSpecifier(kind: SyntaxKind): boolean;
        static IsAccessibilityModifier(kind: SyntaxKind): boolean;
        static IsPreprocessorKeyword(kind: SyntaxKind): boolean;
        static IsPreprocessorContextualKeyword(kind: SyntaxKind): boolean;
        static GetPreprocessorKeywordKinds(): System.Collections.Generic.IEnumerable<SyntaxKind>;
        static IsPunctuation(kind: SyntaxKind): boolean;
        static IsLanguagePunctuation(kind: SyntaxKind): boolean;
        static IsPreprocessorPunctuation(kind: SyntaxKind): boolean;
        private static IsDebuggerSpecialPunctuation(kind);
        static GetPunctuationKinds(): System.Collections.Generic.IEnumerable<SyntaxKind>;
        static IsPunctuationOrKeyword(kind: SyntaxKind): boolean;
        static IsLiteral(kind: SyntaxKind): boolean;
        static IsAnyToken(kind: SyntaxKind): boolean;
        static IsTrivia(kind: SyntaxKind): boolean;
        static IsPreprocessorDirective(kind: SyntaxKind): boolean;
        static IsName(kind: SyntaxKind): boolean;
        static IsPredefinedType(kind: SyntaxKind): boolean;
        static IsTypeSyntax(kind: SyntaxKind): boolean;
        static IsTypeDeclaration(kind: SyntaxKind): boolean;
        static IsGlobalMemberDeclaration(kind: SyntaxKind): boolean;
        static IsNamespaceMemberDeclaration(kind: SyntaxKind): boolean;
        static IsAnyUnaryExpression(token: SyntaxKind): boolean;
        static IsPrefixUnaryExpression(token: SyntaxKind): boolean;
        static IsPrefixUnaryExpressionOperatorToken(token: SyntaxKind): boolean;
        static GetPrefixUnaryExpression(token: SyntaxKind): SyntaxKind;
        static IsPostfixUnaryExpression(token: SyntaxKind): boolean;
        static IsPostfixUnaryExpressionToken(token: SyntaxKind): boolean;
        static GetPostfixUnaryExpression(token: SyntaxKind): SyntaxKind;
        static IsUnaryOperatorDeclarationToken(token: SyntaxKind): boolean;
        static IsAnyOverloadableOperator(kind: SyntaxKind): boolean;
        static IsOverloadableBinaryOperator(kind: SyntaxKind): boolean;
        static IsOverloadableUnaryOperator(kind: SyntaxKind): boolean;
        static IsPrimaryFunction(keyword: SyntaxKind): boolean;
        static GetPrimaryFunction(keyword: SyntaxKind): SyntaxKind;
        static IsLiteralExpression(token: SyntaxKind): boolean;
        static GetLiteralExpression(token: SyntaxKind): SyntaxKind;
        static IsInstanceExpression(token: SyntaxKind): boolean;
        static GetInstanceExpression(token: SyntaxKind): SyntaxKind;
        static IsBinaryExpression(token: SyntaxKind): boolean;
        static IsBinaryExpressionOperatorToken(token: SyntaxKind): boolean;
        static GetBinaryExpression(token: SyntaxKind): SyntaxKind;
        static IsAssignmentExpression(kind: SyntaxKind): boolean;
        static IsAssignmentExpressionOperatorToken(token: SyntaxKind): boolean;
        static GetAssignmentExpression(token: SyntaxKind): SyntaxKind;
        static GetCheckStatement(keyword: SyntaxKind): SyntaxKind;
        static GetAccessorDeclarationKind(keyword: SyntaxKind): SyntaxKind;
        static IsAccessorDeclaration(kind: SyntaxKind): boolean;
        static IsAccessorDeclarationKeyword(keyword: SyntaxKind): boolean;
        static GetSwitchLabelKind(keyword: SyntaxKind): SyntaxKind;
        static GetBaseTypeDeclarationKind(kind: SyntaxKind): SyntaxKind;
        static GetTypeDeclarationKind(kind: SyntaxKind): SyntaxKind;
        static GetKeywordKind(text: string): SyntaxKind;
        static GetOperatorKind(operatorMetadataName: string): SyntaxKind;
        static GetPreprocessorKeywordKind(text: string): SyntaxKind;
        static GetContextualKeywordKinds(): System.Collections.Generic.IEnumerable<SyntaxKind>;
        static IsContextualKeyword(kind: SyntaxKind): boolean;
        static IsQueryContextualKeyword(kind: SyntaxKind): boolean;
        static GetContextualKeywordKind(text: string): SyntaxKind;
        static GetText_3915(kind: SyntaxKind): string;
        static IsTypeParameterVarianceKeyword(kind: SyntaxKind): boolean;
        static IsDocumentationCommentTrivia(kind: SyntaxKind): boolean;
        static IsHexDigit(c: string): boolean;
        static IsDecDigit(c: string): boolean;
        static HexValue(c: string): number;
        static DecValue(c: string): number;
        static IsWhitespace(ch: string): boolean;
        static IsNewLine(ch: string): boolean;
        static IsIdentifierStartCharacter(ch: string): boolean;
        static IsIdentifierPartCharacter(ch: string): boolean;
        static IsValidIdentifier(name: string): boolean;
        static ContainsDroppedIdentifierCharacters(name: string): boolean;
        static IsLetterChar(cat: System.Globalization.UnicodeCategory): boolean;
        static IsCombiningChar(cat: System.Globalization.UnicodeCategory): boolean;
        static IsDecimalDigitChar(cat: System.Globalization.UnicodeCategory): boolean;
        static IsConnectingChar(cat: System.Globalization.UnicodeCategory): boolean;
        static IsFormattingChar_1141(ch: string): boolean;
        static IsFormattingChar_2061(cat: System.Globalization.UnicodeCategory): boolean;
        static IsNonAsciiQuotationMark(ch: string): boolean;
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxParser implements System.IDisposable {
        protected lexer: Lexer;
        private isIncremental;
        private allowModeReset;
        protected cancellationToken: System.Threading.CancellationToken;
        private mode;
        private firstBlender;
        private currentNode;
        private currentToken;
        private lexedTokens;
        private prevTokenTrailingTrivia;
        private firstToken;
        private tokenOffset;
        private tokenCount;
        private resetCount;
        private resetStart;
        private static blendedNodesPool;
        private blendedTokens;
        ctor_2025(lexer: Lexer, mode: LexerMode, oldTree: CSharp.CSharpSyntaxNode, changes: System.Collections.Generic.IEnumerable<Text.TextChangeRange>, allowModeReset: boolean, preLexIfNotIncremental?: boolean, cancellationToken?: System.Threading.CancellationToken): SyntaxParser;
        Dispose(): void;
        protected ReInitialize(): void;
        protected IsIncremental: boolean;
        protected GetIsIncremental(): boolean;
        private PreLex();
        protected GetResetPoint(): SyntaxParser.ResetPoint;
        protected Reset(point: {
            refObj: SyntaxParser.ResetPoint;
        }): void;
        protected Release(point: {
            refObj: SyntaxParser.ResetPoint;
        }): void;
        Options: CSharpParseOptions;
        IsInteractive: boolean;
        IsScript: boolean;
        protected Mode: LexerMode;
        protected CurrentNode: CSharp.CSharpSyntaxNode;
        protected CurrentNodeKind: SyntaxKind;
        private ReadCurrentNode();
        protected EatNode(): GreenNode;
        protected CurrentToken: SyntaxToken;
        private FetchCurrentToken();
        private AddNewToken();
        private AddToken(tokenResult);
        private AddLexedToken(token);
        private AddTokenSlot();
        private AddLexedTokenSlot();
        protected PeekToken(n: number): SyntaxToken;
        protected EatToken_2098(): SyntaxToken;
        private MoveToNextToken();
        protected EatToken_1865(kind: SyntaxKind): SyntaxToken;
        private CreateMissingToken_3851(expected, actual, reportError);
        private CreateMissingToken_1324(expected, code, reportError);
        protected EatToken_1610(kind: SyntaxKind, reportError: boolean): SyntaxToken;
        protected EatToken_4938(kind: SyntaxKind, code: ErrorCode, reportError?: boolean): SyntaxToken;
        protected EatTokenWithPrejudice_1765(kind: SyntaxKind): SyntaxToken;
        protected EatTokenWithPrejudice_1392(errorCode: ErrorCode, ...args: Object[]): SyntaxToken;
        protected EatContextualToken_1786(kind: SyntaxKind, code: ErrorCode, reportError?: boolean): SyntaxToken;
        protected EatContextualToken_1181(kind: SyntaxKind, reportError?: boolean): SyntaxToken;
        protected GetExpectedTokenError_1077(expected: SyntaxKind, actual: SyntaxKind, offset: number, width: number): SyntaxDiagnosticInfo;
        protected GetExpectedTokenError_2124(expected: SyntaxKind, actual: SyntaxKind): SyntaxDiagnosticInfo;
        private static GetExpectedTokenErrorCode(expected, actual);
        protected GetDiagnosticSpanForMissingToken(offset: {
            refObj: number;
        }, width: {
            refObj: number;
        }): void;
        protected WithAdditionalDiagnostics<TNode extends CSharpSyntaxNode>(node: TNode, ...diagnostics: DiagnosticInfo[]): TNode;
        protected WithAdditionalDiagnostics_Arr<TNode extends CSharpSyntaxNode>(node: TNode, diagnostics: DiagnosticInfo[]): TNode;
        protected AddError_1357<TNode extends CSharpSyntaxNode>(node: TNode, code: ErrorCode): TNode;
        protected AddError_7870<TNode extends CSharpSyntaxNode>(node: TNode, code: ErrorCode, ...args: Object[]): TNode;
        protected AddError_1911<TNode extends CSharpSyntaxNode>(node: TNode, offset: number, length: number, code: ErrorCode, ...args: Object[]): TNode;
        protected AddError_7816<TNode extends CSharpSyntaxNode>(node: TNode, location: CSharpSyntaxNode, code: ErrorCode, ...args: Object[]): TNode;
        protected AddErrorToFirstToken_3098<TNode extends CSharpSyntaxNode>(node: TNode, code: ErrorCode): TNode;
        protected AddErrorToFirstToken_6118<TNode extends CSharpSyntaxNode>(node: TNode, code: ErrorCode, ...args: Object[]): TNode;
        protected AddErrorToLastToken_1417<TNode extends CSharpSyntaxNode>(node: TNode, code: ErrorCode): TNode;
        protected AddErrorToLastToken_2523<TNode extends CSharpSyntaxNode>(node: TNode, code: ErrorCode, ...args: Object[]): TNode;
        private static GetOffsetAndWidthForLastToken<TNode>(node, offset, width);
        protected static MakeError_1764(offset: number, width: number, code: ErrorCode): SyntaxDiagnosticInfo;
        protected static MakeError_1930(offset: number, width: number, code: ErrorCode, ...args: Object[]): SyntaxDiagnosticInfo;
        protected static MakeError_6690(node: CSharpSyntaxNode, code: ErrorCode, ...args: Object[]): SyntaxDiagnosticInfo;
        protected static MakeError_2338(code: ErrorCode, ...args: Object[]): SyntaxDiagnosticInfo;
        protected AddLeadingSkippedSyntax<TNode extends CSharpSyntaxNode>(node: TNode, skippedSyntax: CSharpSyntaxNode): TNode;
        protected AddTrailingSkippedSyntax<TNode extends CSharpSyntaxNode>(node: TNode, skippedSyntax: CSharpSyntaxNode): TNode;
        AddSkippedSyntax(target: SyntaxToken, skippedSyntax: CSharpSyntaxNode, trailing: boolean): SyntaxToken;
        private FindOffset(root, location, offset);
        protected static ConvertToKeyword(token: SyntaxToken): SyntaxToken;
        Directives: DirectiveStack;
        protected CheckFeatureAvailability<TNode extends CSharpSyntaxNode>(node: TNode, feature: MessageID, forceWarning?: boolean): TNode;
        protected IsFeatureEnabled(feature: MessageID): boolean;
        constructor();
    }
    module SyntaxParser {
        class ResetPoint implements IStruct {
            ResetCount: number;
            Mode: LexerMode;
            Position: number;
            PrevTokenTrailingTrivia: CSharpSyntaxNode;
            ctor_2078(resetCount: number, mode: LexerMode, position: number, prevTokenTrailingTrivia: CSharpSyntaxNode): ResetPoint;
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class DirectiveParser extends SyntaxParser {
        private static MAX_DIRECTIVE_IDENTIFIER_WIDTH;
        private context;
        ctor_9013(lexer: Lexer, context: DirectiveStack): DirectiveParser;
        ParseDirective(isActive: boolean, endIsActive: boolean, isAfterFirstTokenInFile: boolean, isAfterNonWhitespaceOnLine: boolean): CSharpSyntaxNode;
        private ParseIfDirective(hash, keyword, isActive);
        private ParseElifDirective(hash, keyword, isActive, endIsActive);
        private ParseElseDirective(hash, keyword, isActive, endIsActive);
        private ParseEndIfDirective(hash, keyword, isActive, endIsActive);
        private ParseRegionDirective(hash, keyword, isActive);
        private ParseEndRegionDirective(hash, keyword, isActive);
        private ParseDefineOrUndefDirective(hash, keyword, isActive, isFollowingToken);
        private ParseErrorOrWarningDirective(hash, keyword, isActive);
        private ParseLineDirective(hash, id, isActive);
        private ParseReferenceDirective(hash, keyword, isActive, isFollowingToken);
        private ParsePragmaDirective(hash, pragma, isActive);
        private ParseEndOfDirectiveWithOptionalPreprocessingMessage();
        private ParseEndOfDirective(ignoreErrors, afterPragma?, afterLineNumber?, afterReference?);
        private ParseExpression();
        private ParseLogicalOr();
        private ParseLogicalAnd();
        private ParseEquality();
        private ParseLogicalNot();
        private ParsePrimary();
        private static TruncateIdentifier(identifier);
        private EvaluateBool(expr);
        private Evaluate(expr);
        private IsDefined(id);
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class Directive implements IStruct {
        private node;
        ctor_8302(node: DirectiveTriviaSyntax): Directive;
        Kind: SyntaxKind;
        IncrementallyEquivalent(other: Directive): boolean;
        GetIdentifier(): string;
        IsActive: boolean;
        BranchTaken: boolean;
        constructor();
    }
    enum DefineState {
        Defined = 0,
        Undefined = 1,
        Unspecified = 2,
    }
    class DirectiveStack implements IStruct {
        static Empty: DirectiveStack;
        static Null: DirectiveStack;
        private directives;
        ctor_1074(directives: Roslyn.Utilities.ConsList<Directive>): DirectiveStack;
        IsNull: boolean;
        IsEmpty: boolean;
        IsDefined(id: string): DefineState;
        PreviousBranchTaken(): boolean;
        HasUnfinishedIf(): boolean;
        HasPreviousIfOrElif(): boolean;
        HasUnfinishedRegion(): boolean;
        Add(directive: Directive): DirectiveStack;
        private static CompleteIf(stack, include);
        private static CompleteRegion(stack);
        private static GetPreviousIf(directives);
        private static GetPreviousIfElifElseOrRegion(directives);
        private static GetPreviousRegion(directives);
        IncrementallyEquivalent(other: DirectiveStack): boolean;
        private static SkipInsignificantDirectives(directives);
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class DocumentationCommentParser extends SyntaxParser {
        private pool;
        private isDelimited;
        ctor_5488(lexer: Lexer, modeflags: LexerMode): DocumentationCommentParser;
        ReInitialize_Overload(modeflags: LexerMode): void;
        private SetMode(mode);
        private ResetMode(mode);
        ParseDocumentationComment(isTerminated: {
            refObj: boolean;
        }): DocumentationCommentTriviaSyntax;
        ParseRemainder(nodes: SyntaxListBuilder<XmlNodeSyntax>): void;
        private ParseXmlNodes(nodes);
        private ParseXmlNode();
        private IsXmlNodeStartOrStop();
        private ParseXmlText();
        private ParseXmlElement();
        private attributesSeen;
        private ParseXmlAttributes(elementName, attrs);
        private SkipBadTokens<T>(startNode, list, isNotExpectedFunction, abortFunction, error);
        private ParseXmlAttribute(elementName);
        private static XmlElementSupportsNameAttribute(elementName);
        private IsVerbatimCref();
        private ParseCrefAttribute(startQuote, cref, endQuote);
        private ParseNameAttribute(startQuote, identifier, endQuote);
        private ParseXmlAttributeText(startQuote, textTokens, endQuote);
        private ParseXmlAttributeStartQuote();
        private ParseXmlAttributeEndQuote(quoteKind);
        private SkipNonAsciiQuotationMark();
        private static IsNonAsciiQuotationMark(token);
        private ParseXmlName();
        private ParseXmlComment();
        private ParseXmlCDataSection();
        private ParseXmlProcessingInstruction();
        protected GetExpectedTokenError_1077(expected: SyntaxKind, actual: SyntaxKind, offset: number, length: number): SyntaxDiagnosticInfo;
        protected GetExpectedTokenError_2124(expected: SyntaxKind, actual: SyntaxKind): SyntaxDiagnosticInfo;
        private WithXmlParseError_9319<TNode>(node, code);
        private WithXmlParseError_7460<TNode>(node, code, ...args);
        private WithXmlParseError_1859<TNode>(node, code);
        private WithXmlParseError_3590(node, code, ...args);
        protected WithAdditionalDiagnostics<TNode extends CSharpSyntaxNode>(node: TNode, ...diagnostics: DiagnosticInfo[]): TNode;
        private ParseCrefAttributeValue();
        private ConsumeBadTokens();
        private ParseMemberCref();
        private ParseNameMemberCref();
        private ParseIndexerMemberCref();
        private ParseOperatorMemberCref();
        private ParseConversionOperatorMemberCref();
        private ParseCrefParameterList();
        private ParseBracketedCrefParameterList();
        private ParseBaseCrefParameterList(useSquareBrackets);
        private IsPossibleCrefParameter;
        private ParseCrefParameter();
        private ParseCrefName(typeArgumentsMustBeIdentifiers);
        private ParseCrefType(typeArgumentsMustBeIdentifiers, checkForMember?);
        private ParseCrefTypeHelper(typeArgumentsMustBeIdentifiers, checkForMember?);
        private ParseCrefTypeSuffix(type);
        private IsEndOfCrefAttribute;
        private InCref;
        private ParseNameAttributeValue();
        private IsEndOfNameAttribute;
        constructor();
    }
    module DocumentationCommentParser {
        enum SkipResult {
            Continue = 0,
            Abort = 1,
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxTrivia extends CSharpSyntaxNode {
        Text: string;
        ctor_C_1733(kind: SyntaxKind, text: string, diagnostics?: DiagnosticInfo[], annotations?: SyntaxAnnotation[]): SyntaxTrivia;
        ctor_5948(reader: Roslyn.Utilities.ObjectReader): SyntaxTrivia;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
        WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
        static Create(kind: SyntaxKind, text: string): SyntaxTrivia;
        ToFullString(): string;
        ToString(): string;
        GetSlot(index: number): GreenNode;
        Width: number;
        GetLeadingTriviaWidth(): number;
        GetTrailingTriviaWidth(): number;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        WriteTo_1077(writer: System.IO.TextWriter, leading: boolean, trailing: boolean): void;
        static op_Implicit_2041(trivia: SyntaxTrivia): Microsoft.CodeAnalysis.SyntaxTrivia;
        IsEquivalentTo(other: GreenNode): boolean;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxToken extends CSharpSyntaxNode {
        ctor_1731(kind: SyntaxKind): SyntaxToken;
        ctor_1947(kind: SyntaxKind, diagnostics: DiagnosticInfo[]): SyntaxToken;
        ctor_1741(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SyntaxToken;
        ctor_1992(kind: SyntaxKind, fullWidth: number): SyntaxToken;
        ctor_1368(kind: SyntaxKind, fullWidth: number, diagnostics: DiagnosticInfo[]): SyntaxToken;
        ctor_1822(kind: SyntaxKind, fullWidth: number, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SyntaxToken;
        ctor_2570(reader: Roslyn.Utilities.ObjectReader): SyntaxToken;
        GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
        IsToken: boolean;
        GetSlot(index: number): GreenNode;
        static Create_1552(kind: SyntaxKind): SyntaxToken;
        static Create_1118(kind: SyntaxKind, leading: CSharpSyntaxNode, trailing: CSharpSyntaxNode): SyntaxToken;
        static CreateMissing(kind: SyntaxKind, leading: CSharpSyntaxNode, trailing: CSharpSyntaxNode): SyntaxToken;
        static FirstTokenWithWellKnownText: SyntaxKind;
        static LastTokenWithWellKnownText: SyntaxKind;
        private static TokensWithNoTrivia;
        private static TokensWithElasticTrivia;
        private static TokensWithSingleTrailingSpace;
        private static TokensWithSingleTrailingCRLF;
        static static_constructor(): typeof SyntaxToken;
        static GetWellKnownTokens(): System.Collections.Generic.IEnumerable<SyntaxToken>;
        static Identifier_3961(text: string): SyntaxToken;
        static Identifier_2664(leading: CSharpSyntaxNode, text: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static Identifier_1121(contextualKind: SyntaxKind, leading: CSharpSyntaxNode, text: string, valueText: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static WithValue_9826<T>(kind: SyntaxKind, text: string, value: T): SyntaxToken;
        static WithValue_3998<T>(kind: SyntaxKind, leading: CSharpSyntaxNode, text: string, value: T, trailing: CSharpSyntaxNode): SyntaxToken;
        static StringLiteral_1704(text: string): SyntaxToken;
        static StringLiteral_1284(leading: CSharpSyntaxNode, text: string, trailing: CSharpSyntaxNode): SyntaxToken;
        ContextualKind: SyntaxKind;
        RawContextualKind: number;
        Text: string;
        ToString(): string;
        Value: Object;
        GetValue(): Object;
        ValueText: string;
        GetValueText(): string;
        Width: number;
        GetLeadingTriviaWidth(): number;
        GetTrailingTriviaWidth(): number;
        LeadingTrivia: SyntaxList<CSharpSyntaxNode>;
        TrailingTrivia: SyntaxList<CSharpSyntaxNode>;
        WithLeadingTrivia(trivia: GreenNode): GreenNode;
        WithLeadingTrivia_9638(trivia: CSharpSyntaxNode): SyntaxToken;
        WithTrailingTrivia(trivia: GreenNode): GreenNode;
        WithTrailingTrivia_9295(trivia: CSharpSyntaxNode): SyntaxToken;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        ApplyDirectives(stack: DirectiveStack): DirectiveStack;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        WriteTo_1077(writer: System.IO.TextWriter, leading: boolean, trailing: boolean): void;
        IsEquivalentTo(other: GreenNode): boolean;
        CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
        constructor();
    }
    module SyntaxToken {
        class SyntaxTokenWithTrivia extends SyntaxToken {
            protected LeadingField: CSharpSyntaxNode;
            protected TrailingField: CSharpSyntaxNode;
            ctor_1430(kind: SyntaxKind, leading: CSharpSyntaxNode, trailing: CSharpSyntaxNode): SyntaxTokenWithTrivia;
            ctor_1749(kind: SyntaxKind, leading: CSharpSyntaxNode, trailing: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SyntaxTokenWithTrivia;
            ctor_8843(reader: Roslyn.Utilities.ObjectReader): SyntaxTokenWithTrivia;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            GetLeadingTrivia(): CSharpSyntaxNode;
            GetTrailingTrivia(): CSharpSyntaxNode;
            WithLeadingTrivia_9638(trivia: CSharpSyntaxNode): SyntaxToken;
            WithTrailingTrivia_9295(trivia: CSharpSyntaxNode): SyntaxToken;
            SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
            SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
            constructor();
        }
        class MissingTokenWithTrivia extends SyntaxTokenWithTrivia {
            ctor_1083(kind: SyntaxKind, leading: CSharpSyntaxNode, trailing: CSharpSyntaxNode): MissingTokenWithTrivia;
            ctor_1242(kind: SyntaxKind, leading: CSharpSyntaxNode, trailing: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MissingTokenWithTrivia;
            ctor_3008(reader: Roslyn.Utilities.ObjectReader): MissingTokenWithTrivia;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            Text: string;
            Value: Object;
            WithLeadingTrivia_9638(trivia: CSharpSyntaxNode): SyntaxToken;
            WithTrailingTrivia_9295(trivia: CSharpSyntaxNode): SyntaxToken;
            SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
            SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
            constructor();
        }
        class SyntaxIdentifier extends SyntaxToken {
            protected TextField: string;
            ctor_2070(text: string): SyntaxIdentifier;
            ctor_6514(text: string, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SyntaxIdentifier;
            ctor_1332(reader: Roslyn.Utilities.ObjectReader): SyntaxIdentifier;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            Text: string;
            Value: Object;
            ValueText: string;
            WithLeadingTrivia_9638(trivia: CSharpSyntaxNode): SyntaxToken;
            WithTrailingTrivia_9295(trivia: CSharpSyntaxNode): SyntaxToken;
            SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
            SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
            constructor();
        }
        class SyntaxIdentifierExtended extends SyntaxIdentifier {
            protected contextualKind: SyntaxKind;
            protected valueText: string;
            ctor_6330(contextualKind: SyntaxKind, text: string, valueText: string): SyntaxIdentifierExtended;
            ctor_1916(contextualKind: SyntaxKind, text: string, valueText: string, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SyntaxIdentifierExtended;
            ctor_2220(reader: Roslyn.Utilities.ObjectReader): SyntaxIdentifierExtended;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            ContextualKind: SyntaxKind;
            ValueText: string;
            Value: Object;
            WithLeadingTrivia_9638(trivia: CSharpSyntaxNode): SyntaxToken;
            WithTrailingTrivia_9295(trivia: CSharpSyntaxNode): SyntaxToken;
            SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
            SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
            constructor();
        }
        class SyntaxIdentifierWithTrailingTrivia extends SyntaxIdentifier {
            private trailing;
            ctor_1013(text: string, trailing: CSharpSyntaxNode): SyntaxIdentifierWithTrailingTrivia;
            ctor_2005(text: string, trailing: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SyntaxIdentifierWithTrailingTrivia;
            ctor_3728(reader: Roslyn.Utilities.ObjectReader): SyntaxIdentifierWithTrailingTrivia;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            GetTrailingTrivia(): CSharpSyntaxNode;
            WithLeadingTrivia_9638(trivia: CSharpSyntaxNode): SyntaxToken;
            WithTrailingTrivia_9295(trivia: CSharpSyntaxNode): SyntaxToken;
            SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
            SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
            constructor();
        }
        class SyntaxIdentifierWithTrivia extends SyntaxIdentifierExtended {
            private leading;
            private trailing;
            ctor_6135(contextualKind: SyntaxKind, text: string, valueText: string, leading: CSharpSyntaxNode, trailing: CSharpSyntaxNode): SyntaxIdentifierWithTrivia;
            ctor_8319(contextualKind: SyntaxKind, text: string, valueText: string, leading: CSharpSyntaxNode, trailing: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SyntaxIdentifierWithTrivia;
            ctor_5359(reader: Roslyn.Utilities.ObjectReader): SyntaxIdentifierWithTrivia;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            GetLeadingTrivia(): CSharpSyntaxNode;
            GetTrailingTrivia(): CSharpSyntaxNode;
            WithLeadingTrivia_9638(trivia: CSharpSyntaxNode): SyntaxToken;
            WithTrailingTrivia_9295(trivia: CSharpSyntaxNode): SyntaxToken;
            SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
            SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
            constructor();
        }
        class SyntaxTokenWithValue<T> extends SyntaxToken {
            protected TextField: string;
            protected ValueField: T;
            ctor_1775(kind: SyntaxKind, text: string, value: T): SyntaxTokenWithValue<T>;
            ctor_7378(kind: SyntaxKind, text: string, value: T, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SyntaxTokenWithValue<T>;
            ctor_3744(reader: Roslyn.Utilities.ObjectReader): SyntaxTokenWithValue<T>;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            Text: string;
            Value: Object;
            ValueText: string;
            WithLeadingTrivia_9638(trivia: CSharpSyntaxNode): SyntaxToken;
            WithTrailingTrivia_9295(trivia: CSharpSyntaxNode): SyntaxToken;
            SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
            SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
            constructor();
        }
        class SyntaxTokenWithValueAndTrivia<T> extends SyntaxTokenWithValue<T> {
            private leading;
            private trailing;
            ctor_1855(kind: SyntaxKind, text: string, value: T, leading: CSharpSyntaxNode, trailing: CSharpSyntaxNode): SyntaxTokenWithValueAndTrivia<T>;
            ctor_6719(kind: SyntaxKind, text: string, value: T, leading: CSharpSyntaxNode, trailing: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SyntaxTokenWithValueAndTrivia<T>;
            ctor_4420(reader: Roslyn.Utilities.ObjectReader): SyntaxTokenWithValueAndTrivia<T>;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            GetLeadingTrivia(): CSharpSyntaxNode;
            GetTrailingTrivia(): CSharpSyntaxNode;
            WithLeadingTrivia_9638(trivia: CSharpSyntaxNode): SyntaxToken;
            WithTrailingTrivia_9295(trivia: CSharpSyntaxNode): SyntaxToken;
            SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
            SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxFactory {
        private static CrLf;
        static CarriageReturnLineFeed: SyntaxTrivia;
        static LineFeed: SyntaxTrivia;
        static CarriageReturn: SyntaxTrivia;
        static Space: SyntaxTrivia;
        static Tab: SyntaxTrivia;
        static ElasticCarriageReturnLineFeed: SyntaxTrivia;
        static ElasticLineFeed: SyntaxTrivia;
        static ElasticCarriageReturn: SyntaxTrivia;
        static ElasticSpace: SyntaxTrivia;
        static ElasticTab: SyntaxTrivia;
        static ElasticZeroSpace: SyntaxTrivia;
        private static xmlCarriageReturnLineFeed;
        private static XmlCarriageReturnLineFeed;
        static EndOfLine(text: string, elastic?: boolean): SyntaxTrivia;
        static Whitespace(text: string, elastic?: boolean): SyntaxTrivia;
        static Comment(text: string): SyntaxTrivia;
        static DisabledText(text: string): SyntaxTrivia;
        static PreprocessingMessage(text: string): SyntaxTrivia;
        static Token_1045(kind: SyntaxKind): SyntaxToken;
        static Token_1937(leading: CSharpSyntaxNode, kind: SyntaxKind, trailing: CSharpSyntaxNode): SyntaxToken;
        static Token_6067(leading: CSharpSyntaxNode, kind: SyntaxKind, text: string, valueText: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static MissingToken_7070(kind: SyntaxKind): SyntaxToken;
        static MissingToken_1287(leading: CSharpSyntaxNode, kind: SyntaxKind, trailing: CSharpSyntaxNode): SyntaxToken;
        static Identifier_3961(text: string): SyntaxToken;
        static Identifier_2664(leading: CSharpSyntaxNode, text: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static Identifier_1121(contextualKind: SyntaxKind, leading: CSharpSyntaxNode, text: string, valueText: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static Literal_2107(leading: CSharpSyntaxNode, text: string, value: number, trailing: CSharpSyntaxNode): SyntaxToken;
        static Literal_3278(leading: CSharpSyntaxNode, text: string, value: number, trailing: CSharpSyntaxNode): SyntaxToken;
        static Literal_1844(leading: CSharpSyntaxNode, text: string, value: number, trailing: CSharpSyntaxNode): SyntaxToken;
        static Literal_7516(leading: CSharpSyntaxNode, text: string, value: number, trailing: CSharpSyntaxNode): SyntaxToken;
        static Literal_1315(leading: CSharpSyntaxNode, text: string, value: number, trailing: CSharpSyntaxNode): SyntaxToken;
        static Literal_1908(leading: CSharpSyntaxNode, text: string, value: number, trailing: CSharpSyntaxNode): SyntaxToken;
        static Literal_2002(leading: CSharpSyntaxNode, text: string, value: number, trailing: CSharpSyntaxNode): SyntaxToken;
        static Literal_1989(leading: CSharpSyntaxNode, text: string, value: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static Literal_1924(leading: CSharpSyntaxNode, text: string, kind: SyntaxKind, value: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static Literal_7402(leading: CSharpSyntaxNode, text: string, value: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static BadToken(leading: CSharpSyntaxNode, text: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static XmlTextLiteral(leading: CSharpSyntaxNode, text: string, value: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static XmlTextNewLine_1815(leading: CSharpSyntaxNode, text: string, value: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static XmlTextNewLine_5561(text: string): SyntaxToken;
        static XmlEntity(leading: CSharpSyntaxNode, text: string, value: string, trailing: CSharpSyntaxNode): SyntaxToken;
        static DocumentationCommentExteriorTrivia(text: string): SyntaxTrivia;
        static List_1448<TNode extends CSharpSyntaxNode>(): SyntaxList<TNode>;
        static List_1131<TNode extends CSharpSyntaxNode>(node: TNode): SyntaxList<TNode>;
        static List_1083<TNode extends CSharpSyntaxNode>(node0: TNode, node1: TNode): SyntaxList<TNode>;
        static ListNode_3677(node0: CSharpSyntaxNode, node1: CSharpSyntaxNode): CSharpSyntaxNode;
        static List_2134<TNode extends CSharpSyntaxNode>(node0: TNode, node1: TNode, node2: TNode): SyntaxList<TNode>;
        static ListNode_1805(node0: CSharpSyntaxNode, node1: CSharpSyntaxNode, node2: CSharpSyntaxNode): CSharpSyntaxNode;
        static List_1447<TNode extends CSharpSyntaxNode>(...nodes: TNode[]): SyntaxList<TNode>;
        static ListNode_1606(...nodes: CSharpSyntaxNode[]): CSharpSyntaxNode;
        static SeparatedList_1556<TNode extends CSharpSyntaxNode>(node: TNode): SeparatedSyntaxList<TNode>;
        static SeparatedList_1383<TNode extends CSharpSyntaxNode>(token: SyntaxToken): SeparatedSyntaxList<TNode>;
        static SeparatedList_2711<TNode extends CSharpSyntaxNode>(node1: TNode, token: SyntaxToken, node2: TNode): SeparatedSyntaxList<TNode>;
        static SeparatedList_3486<TNode extends CSharpSyntaxNode>(...nodes: CSharpSyntaxNode[]): SeparatedSyntaxList<TNode>;
        static GetWellKnownTrivia(): System.Collections.Generic.IEnumerable<SyntaxTrivia>;
        static GetWellKnownTokens(): System.Collections.Generic.IEnumerable<SyntaxToken>;
        static IdentifierName(identifier: SyntaxToken): IdentifierNameSyntax;
        static QualifiedName(left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax): QualifiedNameSyntax;
        static GenericName(identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax): GenericNameSyntax;
        static TypeArgumentList(lessThanToken: SyntaxToken, arguments: SeparatedSyntaxList<TypeSyntax>, greaterThanToken: SyntaxToken): TypeArgumentListSyntax;
        static AliasQualifiedName(alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax): AliasQualifiedNameSyntax;
        static PredefinedType(keyword: SyntaxToken): PredefinedTypeSyntax;
        static ArrayType(elementType: TypeSyntax, rankSpecifiers: SyntaxList<ArrayRankSpecifierSyntax>): ArrayTypeSyntax;
        static ArrayRankSpecifier(openBracketToken: SyntaxToken, sizes: SeparatedSyntaxList<ExpressionSyntax>, closeBracketToken: SyntaxToken): ArrayRankSpecifierSyntax;
        static PointerType(elementType: TypeSyntax, asteriskToken: SyntaxToken): PointerTypeSyntax;
        static NullableType(elementType: TypeSyntax, questionToken: SyntaxToken): NullableTypeSyntax;
        static OmittedTypeArgument(omittedTypeArgumentToken: SyntaxToken): OmittedTypeArgumentSyntax;
        static ParenthesizedExpression(openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): ParenthesizedExpressionSyntax;
        static PrefixUnaryExpression(kind: SyntaxKind, operatorToken: SyntaxToken, operand: ExpressionSyntax): PrefixUnaryExpressionSyntax;
        static AwaitExpression(awaitKeyword: SyntaxToken, expression: ExpressionSyntax): AwaitExpressionSyntax;
        static PostfixUnaryExpression(kind: SyntaxKind, operand: ExpressionSyntax, operatorToken: SyntaxToken): PostfixUnaryExpressionSyntax;
        static MemberAccessExpression(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberAccessExpressionSyntax;
        static ConditionalAccessExpression(expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax): ConditionalAccessExpressionSyntax;
        static MemberBindingExpression(operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberBindingExpressionSyntax;
        static ElementBindingExpression(argumentList: BracketedArgumentListSyntax): ElementBindingExpressionSyntax;
        static ImplicitElementAccess(argumentList: BracketedArgumentListSyntax): ImplicitElementAccessSyntax;
        static BinaryExpression(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): BinaryExpressionSyntax;
        static AssignmentExpression(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): AssignmentExpressionSyntax;
        static ConditionalExpression(condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax): ConditionalExpressionSyntax;
        static ThisExpression(token: SyntaxToken): ThisExpressionSyntax;
        static BaseExpression(token: SyntaxToken): BaseExpressionSyntax;
        static LiteralExpression(kind: SyntaxKind, token: SyntaxToken): LiteralExpressionSyntax;
        static MakeRefExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): MakeRefExpressionSyntax;
        static RefTypeExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): RefTypeExpressionSyntax;
        static RefValueExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): RefValueExpressionSyntax;
        static CheckedExpression(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): CheckedExpressionSyntax;
        static DefaultExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): DefaultExpressionSyntax;
        static TypeOfExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): TypeOfExpressionSyntax;
        static SizeOfExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): SizeOfExpressionSyntax;
        static InvocationExpression(expression: ExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax;
        static ElementAccessExpression(expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax): ElementAccessExpressionSyntax;
        static ArgumentList(openParenToken: SyntaxToken, arguments: SeparatedSyntaxList<ArgumentSyntax>, closeParenToken: SyntaxToken): ArgumentListSyntax;
        static BracketedArgumentList(openBracketToken: SyntaxToken, arguments: SeparatedSyntaxList<ArgumentSyntax>, closeBracketToken: SyntaxToken): BracketedArgumentListSyntax;
        static Argument(nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax): ArgumentSyntax;
        static NameColon(name: IdentifierNameSyntax, colonToken: SyntaxToken): NameColonSyntax;
        static CastExpression(openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax): CastExpressionSyntax;
        static AnonymousMethodExpression(asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): AnonymousMethodExpressionSyntax;
        static SimpleLambdaExpression(asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): SimpleLambdaExpressionSyntax;
        static ParenthesizedLambdaExpression(asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): ParenthesizedLambdaExpressionSyntax;
        static InitializerExpression(kind: SyntaxKind, openBraceToken: SyntaxToken, expressions: SeparatedSyntaxList<ExpressionSyntax>, closeBraceToken: SyntaxToken): InitializerExpressionSyntax;
        static ObjectCreationExpression(newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax): ObjectCreationExpressionSyntax;
        static AnonymousObjectMemberDeclarator(nameEquals: NameEqualsSyntax, expression: ExpressionSyntax): AnonymousObjectMemberDeclaratorSyntax;
        static AnonymousObjectCreationExpression(newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>, closeBraceToken: SyntaxToken): AnonymousObjectCreationExpressionSyntax;
        static ArrayCreationExpression(newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax): ArrayCreationExpressionSyntax;
        static ImplicitArrayCreationExpression(newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: SyntaxList<SyntaxToken>, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax): ImplicitArrayCreationExpressionSyntax;
        static StackAllocArrayCreationExpression(stackAllocKeyword: SyntaxToken, type: TypeSyntax): StackAllocArrayCreationExpressionSyntax;
        static QueryExpression(fromClause: FromClauseSyntax, body: QueryBodySyntax): QueryExpressionSyntax;
        static QueryBody(clauses: SyntaxList<QueryClauseSyntax>, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax): QueryBodySyntax;
        static FromClause(fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax): FromClauseSyntax;
        static LetClause(letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax): LetClauseSyntax;
        static JoinClause(joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax): JoinClauseSyntax;
        static JoinIntoClause(intoKeyword: SyntaxToken, identifier: SyntaxToken): JoinIntoClauseSyntax;
        static WhereClause(whereKeyword: SyntaxToken, condition: ExpressionSyntax): WhereClauseSyntax;
        static OrderByClause(orderByKeyword: SyntaxToken, orderings: SeparatedSyntaxList<OrderingSyntax>): OrderByClauseSyntax;
        static Ordering(kind: SyntaxKind, expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken): OrderingSyntax;
        static SelectClause(selectKeyword: SyntaxToken, expression: ExpressionSyntax): SelectClauseSyntax;
        static GroupClause(groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax): GroupClauseSyntax;
        static QueryContinuation(intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax): QueryContinuationSyntax;
        static OmittedArraySizeExpression(omittedArraySizeExpressionToken: SyntaxToken): OmittedArraySizeExpressionSyntax;
        static GlobalStatement(statement: StatementSyntax): GlobalStatementSyntax;
        static Block(openBraceToken: SyntaxToken, statements: SyntaxList<StatementSyntax>, closeBraceToken: SyntaxToken): BlockSyntax;
        static LocalDeclarationStatement(modifiers: SyntaxList<SyntaxToken>, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): LocalDeclarationStatementSyntax;
        static VariableDeclaration(type: TypeSyntax, variables: SeparatedSyntaxList<VariableDeclaratorSyntax>): VariableDeclarationSyntax;
        static VariableDeclarator(identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax): VariableDeclaratorSyntax;
        static EqualsValueClause(equalsToken: SyntaxToken, value: ExpressionSyntax): EqualsValueClauseSyntax;
        static ExpressionStatement(expression: ExpressionSyntax, semicolonToken: SyntaxToken): ExpressionStatementSyntax;
        static EmptyStatement(semicolonToken: SyntaxToken): EmptyStatementSyntax;
        static LabeledStatement(identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax): LabeledStatementSyntax;
        static GotoStatement(kind: SyntaxKind, gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): GotoStatementSyntax;
        static BreakStatement(breakKeyword: SyntaxToken, semicolonToken: SyntaxToken): BreakStatementSyntax;
        static ContinueStatement(continueKeyword: SyntaxToken, semicolonToken: SyntaxToken): ContinueStatementSyntax;
        static ReturnStatement(returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ReturnStatementSyntax;
        static ThrowStatement(throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ThrowStatementSyntax;
        static YieldStatement(kind: SyntaxKind, yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): YieldStatementSyntax;
        static WhileStatement(whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): WhileStatementSyntax;
        static DoStatement(doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken): DoStatementSyntax;
        static ForStatement(forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: SeparatedSyntaxList<ExpressionSyntax>, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: SeparatedSyntaxList<ExpressionSyntax>, closeParenToken: SyntaxToken, statement: StatementSyntax): ForStatementSyntax;
        static ForEachStatement(forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): ForEachStatementSyntax;
        static UsingStatement(usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): UsingStatementSyntax;
        static FixedStatement(fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): FixedStatementSyntax;
        static CheckedStatement(kind: SyntaxKind, keyword: SyntaxToken, block: BlockSyntax): CheckedStatementSyntax;
        static UnsafeStatement(unsafeKeyword: SyntaxToken, block: BlockSyntax): UnsafeStatementSyntax;
        static LockStatement(lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): LockStatementSyntax;
        static IfStatement(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax): IfStatementSyntax;
        static ElseClause(elseKeyword: SyntaxToken, statement: StatementSyntax): ElseClauseSyntax;
        static SwitchStatement(switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: SyntaxList<SwitchSectionSyntax>, closeBraceToken: SyntaxToken): SwitchStatementSyntax;
        static SwitchSection(labels: SyntaxList<SwitchLabelSyntax>, statements: SyntaxList<StatementSyntax>): SwitchSectionSyntax;
        static CaseSwitchLabel(keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken): CaseSwitchLabelSyntax;
        static DefaultSwitchLabel(keyword: SyntaxToken, colonToken: SyntaxToken): DefaultSwitchLabelSyntax;
        static TryStatement(tryKeyword: SyntaxToken, block: BlockSyntax, catches: SyntaxList<CatchClauseSyntax>, $finally: FinallyClauseSyntax): TryStatementSyntax;
        static CatchClause(catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax): CatchClauseSyntax;
        static CatchDeclaration(openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken): CatchDeclarationSyntax;
        static CatchFilterClause(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken): CatchFilterClauseSyntax;
        static FinallyClause(finallyKeyword: SyntaxToken, block: BlockSyntax): FinallyClauseSyntax;
        static CompilationUnit(externs: SyntaxList<ExternAliasDirectiveSyntax>, usings: SyntaxList<UsingDirectiveSyntax>, attributeLists: SyntaxList<AttributeListSyntax>, members: SyntaxList<MemberDeclarationSyntax>, endOfFileToken: SyntaxToken): CompilationUnitSyntax;
        static ExternAliasDirective(externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken): ExternAliasDirectiveSyntax;
        static UsingDirective(usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken): UsingDirectiveSyntax;
        static NamespaceDeclaration(namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: SyntaxList<ExternAliasDirectiveSyntax>, usings: SyntaxList<UsingDirectiveSyntax>, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): NamespaceDeclarationSyntax;
        static AttributeList(openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: SeparatedSyntaxList<AttributeSyntax>, closeBracketToken: SyntaxToken): AttributeListSyntax;
        static AttributeTargetSpecifier(identifier: SyntaxToken, colonToken: SyntaxToken): AttributeTargetSpecifierSyntax;
        static Attribute(name: NameSyntax, argumentList: AttributeArgumentListSyntax): AttributeSyntax;
        static AttributeArgumentList(openParenToken: SyntaxToken, arguments: SeparatedSyntaxList<AttributeArgumentSyntax>, closeParenToken: SyntaxToken): AttributeArgumentListSyntax;
        static AttributeArgument(nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax): AttributeArgumentSyntax;
        static NameEquals(name: IdentifierNameSyntax, equalsToken: SyntaxToken): NameEqualsSyntax;
        static TypeParameterList(lessThanToken: SyntaxToken, parameters: SeparatedSyntaxList<TypeParameterSyntax>, greaterThanToken: SyntaxToken): TypeParameterListSyntax;
        static TypeParameter(attributeLists: SyntaxList<AttributeListSyntax>, varianceKeyword: SyntaxToken, identifier: SyntaxToken): TypeParameterSyntax;
        static ClassDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): ClassDeclarationSyntax;
        static StructDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): StructDeclarationSyntax;
        static InterfaceDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): InterfaceDeclarationSyntax;
        static EnumDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: SeparatedSyntaxList<EnumMemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): EnumDeclarationSyntax;
        static DelegateDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, semicolonToken: SyntaxToken): DelegateDeclarationSyntax;
        static EnumMemberDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax): EnumMemberDeclarationSyntax;
        static BaseList(colonToken: SyntaxToken, types: SeparatedSyntaxList<BaseTypeSyntax>): BaseListSyntax;
        static SimpleBaseType(type: TypeSyntax): SimpleBaseTypeSyntax;
        static TypeParameterConstraintClause(whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: SeparatedSyntaxList<TypeParameterConstraintSyntax>): TypeParameterConstraintClauseSyntax;
        static ConstructorConstraint(newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken): ConstructorConstraintSyntax;
        static ClassOrStructConstraint(kind: SyntaxKind, classOrStructKeyword: SyntaxToken): ClassOrStructConstraintSyntax;
        static TypeConstraint(type: TypeSyntax): TypeConstraintSyntax;
        static FieldDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): FieldDeclarationSyntax;
        static EventFieldDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): EventFieldDeclarationSyntax;
        static ExplicitInterfaceSpecifier(name: NameSyntax, dotToken: SyntaxToken): ExplicitInterfaceSpecifierSyntax;
        static MethodDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): MethodDeclarationSyntax;
        static OperatorDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): OperatorDeclarationSyntax;
        static ConversionOperatorDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): ConversionOperatorDeclarationSyntax;
        static ConstructorDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): ConstructorDeclarationSyntax;
        static ConstructorInitializer(kind: SyntaxKind, colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax): ConstructorInitializerSyntax;
        static DestructorDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): DestructorDeclarationSyntax;
        static PropertyDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken): PropertyDeclarationSyntax;
        static ArrowExpressionClause(arrowToken: SyntaxToken, expression: ExpressionSyntax): ArrowExpressionClauseSyntax;
        static EventDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax): EventDeclarationSyntax;
        static IndexerDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken): IndexerDeclarationSyntax;
        static AccessorList(openBraceToken: SyntaxToken, accessors: SyntaxList<AccessorDeclarationSyntax>, closeBraceToken: SyntaxToken): AccessorListSyntax;
        static AccessorDeclaration(kind: SyntaxKind, attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken): AccessorDeclarationSyntax;
        static ParameterList(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<ParameterSyntax>, closeParenToken: SyntaxToken): ParameterListSyntax;
        static BracketedParameterList(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<ParameterSyntax>, closeBracketToken: SyntaxToken): BracketedParameterListSyntax;
        static Parameter(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax): ParameterSyntax;
        static IncompleteMember(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax): IncompleteMemberSyntax;
        static SkippedTokensTrivia(tokens: SyntaxList<SyntaxToken>): SkippedTokensTriviaSyntax;
        static DocumentationCommentTrivia(kind: SyntaxKind, content: SyntaxList<XmlNodeSyntax>, endOfComment: SyntaxToken): DocumentationCommentTriviaSyntax;
        static TypeCref(type: TypeSyntax): TypeCrefSyntax;
        static QualifiedCref(container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax): QualifiedCrefSyntax;
        static NameMemberCref(name: TypeSyntax, parameters: CrefParameterListSyntax): NameMemberCrefSyntax;
        static IndexerMemberCref(thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax): IndexerMemberCrefSyntax;
        static OperatorMemberCref(operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax): OperatorMemberCrefSyntax;
        static ConversionOperatorMemberCref(implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax): ConversionOperatorMemberCrefSyntax;
        static CrefParameterList(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<CrefParameterSyntax>, closeParenToken: SyntaxToken): CrefParameterListSyntax;
        static CrefBracketedParameterList(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<CrefParameterSyntax>, closeBracketToken: SyntaxToken): CrefBracketedParameterListSyntax;
        static CrefParameter(refOrOutKeyword: SyntaxToken, type: TypeSyntax): CrefParameterSyntax;
        static XmlElement(startTag: XmlElementStartTagSyntax, content: SyntaxList<XmlNodeSyntax>, endTag: XmlElementEndTagSyntax): XmlElementSyntax;
        static XmlElementStartTag(lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: SyntaxList<XmlAttributeSyntax>, greaterThanToken: SyntaxToken): XmlElementStartTagSyntax;
        static XmlElementEndTag(lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken): XmlElementEndTagSyntax;
        static XmlEmptyElement(lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: SyntaxList<XmlAttributeSyntax>, slashGreaterThanToken: SyntaxToken): XmlEmptyElementSyntax;
        static XmlName(prefix: XmlPrefixSyntax, localName: SyntaxToken): XmlNameSyntax;
        static XmlPrefix(prefix: SyntaxToken, colonToken: SyntaxToken): XmlPrefixSyntax;
        static XmlTextAttribute(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, endQuoteToken: SyntaxToken): XmlTextAttributeSyntax;
        static XmlCrefAttribute(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken): XmlCrefAttributeSyntax;
        static XmlNameAttribute(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken): XmlNameAttributeSyntax;
        static XmlText(textTokens: SyntaxList<SyntaxToken>): XmlTextSyntax;
        static XmlCDataSection(startCDataToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, endCDataToken: SyntaxToken): XmlCDataSectionSyntax;
        static XmlProcessingInstruction(startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: SyntaxList<SyntaxToken>, endProcessingInstructionToken: SyntaxToken): XmlProcessingInstructionSyntax;
        static XmlComment(lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, minusMinusGreaterThanToken: SyntaxToken): XmlCommentSyntax;
        static IfDirectiveTrivia(hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): IfDirectiveTriviaSyntax;
        static ElifDirectiveTrivia(hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): ElifDirectiveTriviaSyntax;
        static ElseDirectiveTrivia(hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean): ElseDirectiveTriviaSyntax;
        static EndIfDirectiveTrivia(hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndIfDirectiveTriviaSyntax;
        static RegionDirectiveTrivia(hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): RegionDirectiveTriviaSyntax;
        static EndRegionDirectiveTrivia(hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndRegionDirectiveTriviaSyntax;
        static ErrorDirectiveTrivia(hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ErrorDirectiveTriviaSyntax;
        static WarningDirectiveTrivia(hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): WarningDirectiveTriviaSyntax;
        static BadDirectiveTrivia(hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): BadDirectiveTriviaSyntax;
        static DefineDirectiveTrivia(hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): DefineDirectiveTriviaSyntax;
        static UndefDirectiveTrivia(hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): UndefDirectiveTriviaSyntax;
        static LineDirectiveTrivia(hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): LineDirectiveTriviaSyntax;
        static PragmaWarningDirectiveTrivia(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: SeparatedSyntaxList<ExpressionSyntax>, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaWarningDirectiveTriviaSyntax;
        static PragmaChecksumDirectiveTrivia(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaChecksumDirectiveTriviaSyntax;
        static ReferenceDirectiveTrivia(hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ReferenceDirectiveTriviaSyntax;
        static InterpolatedString(stringStart: SyntaxToken, interpolatedInserts: SeparatedSyntaxList<InterpolatedStringInsertSyntax>, stringEnd: SyntaxToken): InterpolatedStringSyntax;
        static InterpolatedStringInsert(expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken): InterpolatedStringInsertSyntax;
        static GetNodeTypes(): System.Collections.Generic.IEnumerable<System.Type>;
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class DocumentationCommentXmlTokens {
        private static seeToken;
        private static codeToken;
        private static listToken;
        private static paramToken;
        private static valueToken;
        private static exampleToken;
        private static includeToken;
        private static remarksToken;
        private static seealsoToken;
        private static summaryToken;
        private static exceptionToken;
        private static typeparamToken;
        private static permissionToken;
        private static typeparamrefToken;
        private static crefToken;
        private static fileToken;
        private static nameToken;
        private static pathToken;
        private static typeToken;
        private static Identifier(text);
        private static IdentifierWithLeadingSpace(text);
        private static IsSingleSpaceTrivia(syntax);
        static LookupToken(text: string, leading: SyntaxListBaseBuilder): SyntaxToken;
        private static LookupXmlElementTag(text);
        private static LookupXmlAttribute(text);
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxList<TNode extends CSharpSyntaxNode> implements System.IEquatable<SyntaxList<TNode>>, IStruct {
        private node;
        ctor_1319(node: CSharpSyntaxNode): SyntaxList<TNode>;
        Node: CSharpSyntaxNode;
        Count: number;
        $get$(index: number): TNode;
        Any_2111(): boolean;
        Any_1043(kind: SyntaxKind): boolean;
        private Nodes;
        GetEnumerator(): SyntaxList.Enumerator<TNode>;
        CopyTo(offset: number, array: ArrayElement<CSharpSyntaxNode>[], arrayOffset: number, count: number): void;
        op_Equality(right: SyntaxList<TNode>): boolean;
        op_Inequality(right: SyntaxList<TNode>): boolean;
        Equals_1466(other: SyntaxList<TNode>): boolean;
        Equals(obj: Object): boolean;
        GetHashCode(): number;
        AsSeparatedList<TOther extends CSharpSyntaxNode>(): SeparatedSyntaxList<TOther>;
        static op_Implicit_5999<TNode extends CSharpSyntaxNode>(node: TNode): SyntaxList<TNode>;
        static op_Implicit_8623<TNode extends CSharpSyntaxNode>(nodes: SyntaxList<CSharpSyntaxNode>): SyntaxList<TNode>;
        static op_Implicit_8343<TNode extends CSharpSyntaxNode>(nodes: SyntaxList<TNode>): SyntaxList<CSharpSyntaxNode>;
        constructor();
    }
    module SyntaxList {
        class Enumerator<TNode extends CSharpSyntaxNode> implements IStruct {
            private list;
            private index;
            ctor_4311(list: SyntaxList<TNode>): Enumerator<TNode>;
            MoveNext(): boolean;
            Current: TNode;
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxListBuilderExtensions {
        static ToTokenList(builder: SyntaxListBaseBuilder): SyntaxList<SyntaxToken>;
        static ToList_1673(builder: SyntaxListBaseBuilder): SyntaxList<CSharpSyntaxNode>;
        static ToList_1810<TNode extends CSharpSyntaxNode>(builder: SyntaxListBaseBuilder): SyntaxList<TNode>;
        static ToSeparatedList<TNode extends CSharpSyntaxNode>(builder: SyntaxListBaseBuilder): SeparatedSyntaxList<TNode>;
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxListBuilder<TNode extends CSharpSyntaxNode> implements IStruct {
        private builder;
        ctor_7707(size: number): SyntaxListBuilder<TNode>;
        ctor_1247(builder: SyntaxListBaseBuilder): SyntaxListBuilder<TNode>;
        IsNull: boolean;
        Count: number;
        $get$(index: number): TNode;
        $set$(index: number, value: TNode): void;
        Clear(): void;
        Add(node: TNode): SyntaxListBuilder<TNode>;
        AddRange_1628(items: TNode[], offset: number, length: number): void;
        AddRange_1067(nodes: SyntaxList<TNode>): void;
        AddRange_1900(nodes: SyntaxList<TNode>, offset: number, length: number): void;
        Any(kind: SyntaxKind): boolean;
        ToList(): SyntaxList<TNode>;
        ToListNode(): CSharpSyntaxNode;
        static op_Implicit_1734<TNode extends CSharpSyntaxNode>(builder: SyntaxListBuilder<TNode>): SyntaxListBaseBuilder;
        static op_Implicit_3485<TNode extends CSharpSyntaxNode>(builder: SyntaxListBuilder<TNode>): SyntaxList<TNode>;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class ContextAwareSyntax {
        private context;
        ctor_5769(context: SyntaxFactoryContext): ContextAwareSyntax;
        IdentifierName(identifier: SyntaxToken): IdentifierNameSyntax;
        QualifiedName(left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax): QualifiedNameSyntax;
        GenericName(identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax): GenericNameSyntax;
        TypeArgumentList(lessThanToken: SyntaxToken, arguments: SeparatedSyntaxList<TypeSyntax>, greaterThanToken: SyntaxToken): TypeArgumentListSyntax;
        AliasQualifiedName(alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax): AliasQualifiedNameSyntax;
        PredefinedType(keyword: SyntaxToken): PredefinedTypeSyntax;
        ArrayType(elementType: TypeSyntax, rankSpecifiers: SyntaxList<ArrayRankSpecifierSyntax>): ArrayTypeSyntax;
        ArrayRankSpecifier(openBracketToken: SyntaxToken, sizes: SeparatedSyntaxList<ExpressionSyntax>, closeBracketToken: SyntaxToken): ArrayRankSpecifierSyntax;
        PointerType(elementType: TypeSyntax, asteriskToken: SyntaxToken): PointerTypeSyntax;
        NullableType(elementType: TypeSyntax, questionToken: SyntaxToken): NullableTypeSyntax;
        OmittedTypeArgument(omittedTypeArgumentToken: SyntaxToken): OmittedTypeArgumentSyntax;
        ParenthesizedExpression(openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): ParenthesizedExpressionSyntax;
        PrefixUnaryExpression(kind: SyntaxKind, operatorToken: SyntaxToken, operand: ExpressionSyntax): PrefixUnaryExpressionSyntax;
        AwaitExpression(awaitKeyword: SyntaxToken, expression: ExpressionSyntax): AwaitExpressionSyntax;
        PostfixUnaryExpression(kind: SyntaxKind, operand: ExpressionSyntax, operatorToken: SyntaxToken): PostfixUnaryExpressionSyntax;
        MemberAccessExpression(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberAccessExpressionSyntax;
        ConditionalAccessExpression(expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax): ConditionalAccessExpressionSyntax;
        MemberBindingExpression(operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberBindingExpressionSyntax;
        ElementBindingExpression(argumentList: BracketedArgumentListSyntax): ElementBindingExpressionSyntax;
        ImplicitElementAccess(argumentList: BracketedArgumentListSyntax): ImplicitElementAccessSyntax;
        BinaryExpression(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): BinaryExpressionSyntax;
        AssignmentExpression(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): AssignmentExpressionSyntax;
        ConditionalExpression(condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax): ConditionalExpressionSyntax;
        ThisExpression(token: SyntaxToken): ThisExpressionSyntax;
        BaseExpression(token: SyntaxToken): BaseExpressionSyntax;
        LiteralExpression(kind: SyntaxKind, token: SyntaxToken): LiteralExpressionSyntax;
        MakeRefExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): MakeRefExpressionSyntax;
        RefTypeExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): RefTypeExpressionSyntax;
        RefValueExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): RefValueExpressionSyntax;
        CheckedExpression(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): CheckedExpressionSyntax;
        DefaultExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): DefaultExpressionSyntax;
        TypeOfExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): TypeOfExpressionSyntax;
        SizeOfExpression(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): SizeOfExpressionSyntax;
        InvocationExpression(expression: ExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax;
        ElementAccessExpression(expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax): ElementAccessExpressionSyntax;
        ArgumentList(openParenToken: SyntaxToken, arguments: SeparatedSyntaxList<ArgumentSyntax>, closeParenToken: SyntaxToken): ArgumentListSyntax;
        BracketedArgumentList(openBracketToken: SyntaxToken, arguments: SeparatedSyntaxList<ArgumentSyntax>, closeBracketToken: SyntaxToken): BracketedArgumentListSyntax;
        Argument(nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax): ArgumentSyntax;
        NameColon(name: IdentifierNameSyntax, colonToken: SyntaxToken): NameColonSyntax;
        CastExpression(openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax): CastExpressionSyntax;
        AnonymousMethodExpression(asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): AnonymousMethodExpressionSyntax;
        SimpleLambdaExpression(asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): SimpleLambdaExpressionSyntax;
        ParenthesizedLambdaExpression(asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): ParenthesizedLambdaExpressionSyntax;
        InitializerExpression(kind: SyntaxKind, openBraceToken: SyntaxToken, expressions: SeparatedSyntaxList<ExpressionSyntax>, closeBraceToken: SyntaxToken): InitializerExpressionSyntax;
        ObjectCreationExpression(newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax): ObjectCreationExpressionSyntax;
        AnonymousObjectMemberDeclarator(nameEquals: NameEqualsSyntax, expression: ExpressionSyntax): AnonymousObjectMemberDeclaratorSyntax;
        AnonymousObjectCreationExpression(newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>, closeBraceToken: SyntaxToken): AnonymousObjectCreationExpressionSyntax;
        ArrayCreationExpression(newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax): ArrayCreationExpressionSyntax;
        ImplicitArrayCreationExpression(newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: SyntaxList<SyntaxToken>, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax): ImplicitArrayCreationExpressionSyntax;
        StackAllocArrayCreationExpression(stackAllocKeyword: SyntaxToken, type: TypeSyntax): StackAllocArrayCreationExpressionSyntax;
        QueryExpression(fromClause: FromClauseSyntax, body: QueryBodySyntax): QueryExpressionSyntax;
        QueryBody(clauses: SyntaxList<QueryClauseSyntax>, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax): QueryBodySyntax;
        FromClause(fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax): FromClauseSyntax;
        LetClause(letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax): LetClauseSyntax;
        JoinClause(joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax): JoinClauseSyntax;
        JoinIntoClause(intoKeyword: SyntaxToken, identifier: SyntaxToken): JoinIntoClauseSyntax;
        WhereClause(whereKeyword: SyntaxToken, condition: ExpressionSyntax): WhereClauseSyntax;
        OrderByClause(orderByKeyword: SyntaxToken, orderings: SeparatedSyntaxList<OrderingSyntax>): OrderByClauseSyntax;
        Ordering(kind: SyntaxKind, expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken): OrderingSyntax;
        SelectClause(selectKeyword: SyntaxToken, expression: ExpressionSyntax): SelectClauseSyntax;
        GroupClause(groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax): GroupClauseSyntax;
        QueryContinuation(intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax): QueryContinuationSyntax;
        OmittedArraySizeExpression(omittedArraySizeExpressionToken: SyntaxToken): OmittedArraySizeExpressionSyntax;
        GlobalStatement(statement: StatementSyntax): GlobalStatementSyntax;
        Block(openBraceToken: SyntaxToken, statements: SyntaxList<StatementSyntax>, closeBraceToken: SyntaxToken): BlockSyntax;
        LocalDeclarationStatement(modifiers: SyntaxList<SyntaxToken>, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): LocalDeclarationStatementSyntax;
        VariableDeclaration(type: TypeSyntax, variables: SeparatedSyntaxList<VariableDeclaratorSyntax>): VariableDeclarationSyntax;
        VariableDeclarator(identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax): VariableDeclaratorSyntax;
        EqualsValueClause(equalsToken: SyntaxToken, value: ExpressionSyntax): EqualsValueClauseSyntax;
        ExpressionStatement(expression: ExpressionSyntax, semicolonToken: SyntaxToken): ExpressionStatementSyntax;
        EmptyStatement(semicolonToken: SyntaxToken): EmptyStatementSyntax;
        LabeledStatement(identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax): LabeledStatementSyntax;
        GotoStatement(kind: SyntaxKind, gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): GotoStatementSyntax;
        BreakStatement(breakKeyword: SyntaxToken, semicolonToken: SyntaxToken): BreakStatementSyntax;
        ContinueStatement(continueKeyword: SyntaxToken, semicolonToken: SyntaxToken): ContinueStatementSyntax;
        ReturnStatement(returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ReturnStatementSyntax;
        ThrowStatement(throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ThrowStatementSyntax;
        YieldStatement(kind: SyntaxKind, yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): YieldStatementSyntax;
        WhileStatement(whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): WhileStatementSyntax;
        DoStatement(doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken): DoStatementSyntax;
        ForStatement(forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: SeparatedSyntaxList<ExpressionSyntax>, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: SeparatedSyntaxList<ExpressionSyntax>, closeParenToken: SyntaxToken, statement: StatementSyntax): ForStatementSyntax;
        ForEachStatement(forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): ForEachStatementSyntax;
        UsingStatement(usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): UsingStatementSyntax;
        FixedStatement(fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): FixedStatementSyntax;
        CheckedStatement(kind: SyntaxKind, keyword: SyntaxToken, block: BlockSyntax): CheckedStatementSyntax;
        UnsafeStatement(unsafeKeyword: SyntaxToken, block: BlockSyntax): UnsafeStatementSyntax;
        LockStatement(lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): LockStatementSyntax;
        IfStatement(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax): IfStatementSyntax;
        ElseClause(elseKeyword: SyntaxToken, statement: StatementSyntax): ElseClauseSyntax;
        SwitchStatement(switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: SyntaxList<SwitchSectionSyntax>, closeBraceToken: SyntaxToken): SwitchStatementSyntax;
        SwitchSection(labels: SyntaxList<SwitchLabelSyntax>, statements: SyntaxList<StatementSyntax>): SwitchSectionSyntax;
        CaseSwitchLabel(keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken): CaseSwitchLabelSyntax;
        DefaultSwitchLabel(keyword: SyntaxToken, colonToken: SyntaxToken): DefaultSwitchLabelSyntax;
        TryStatement(tryKeyword: SyntaxToken, block: BlockSyntax, catches: SyntaxList<CatchClauseSyntax>, $finally: FinallyClauseSyntax): TryStatementSyntax;
        CatchClause(catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax): CatchClauseSyntax;
        CatchDeclaration(openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken): CatchDeclarationSyntax;
        CatchFilterClause(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken): CatchFilterClauseSyntax;
        FinallyClause(finallyKeyword: SyntaxToken, block: BlockSyntax): FinallyClauseSyntax;
        CompilationUnit(externs: SyntaxList<ExternAliasDirectiveSyntax>, usings: SyntaxList<UsingDirectiveSyntax>, attributeLists: SyntaxList<AttributeListSyntax>, members: SyntaxList<MemberDeclarationSyntax>, endOfFileToken: SyntaxToken): CompilationUnitSyntax;
        ExternAliasDirective(externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken): ExternAliasDirectiveSyntax;
        UsingDirective(usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken): UsingDirectiveSyntax;
        NamespaceDeclaration(namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: SyntaxList<ExternAliasDirectiveSyntax>, usings: SyntaxList<UsingDirectiveSyntax>, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): NamespaceDeclarationSyntax;
        AttributeList(openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: SeparatedSyntaxList<AttributeSyntax>, closeBracketToken: SyntaxToken): AttributeListSyntax;
        AttributeTargetSpecifier(identifier: SyntaxToken, colonToken: SyntaxToken): AttributeTargetSpecifierSyntax;
        Attribute(name: NameSyntax, argumentList: AttributeArgumentListSyntax): AttributeSyntax;
        AttributeArgumentList(openParenToken: SyntaxToken, arguments: SeparatedSyntaxList<AttributeArgumentSyntax>, closeParenToken: SyntaxToken): AttributeArgumentListSyntax;
        AttributeArgument(nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax): AttributeArgumentSyntax;
        NameEquals(name: IdentifierNameSyntax, equalsToken: SyntaxToken): NameEqualsSyntax;
        TypeParameterList(lessThanToken: SyntaxToken, parameters: SeparatedSyntaxList<TypeParameterSyntax>, greaterThanToken: SyntaxToken): TypeParameterListSyntax;
        TypeParameter(attributeLists: SyntaxList<AttributeListSyntax>, varianceKeyword: SyntaxToken, identifier: SyntaxToken): TypeParameterSyntax;
        ClassDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): ClassDeclarationSyntax;
        StructDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): StructDeclarationSyntax;
        InterfaceDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): InterfaceDeclarationSyntax;
        EnumDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: SeparatedSyntaxList<EnumMemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): EnumDeclarationSyntax;
        DelegateDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, semicolonToken: SyntaxToken): DelegateDeclarationSyntax;
        EnumMemberDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax): EnumMemberDeclarationSyntax;
        BaseList(colonToken: SyntaxToken, types: SeparatedSyntaxList<BaseTypeSyntax>): BaseListSyntax;
        SimpleBaseType(type: TypeSyntax): SimpleBaseTypeSyntax;
        TypeParameterConstraintClause(whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: SeparatedSyntaxList<TypeParameterConstraintSyntax>): TypeParameterConstraintClauseSyntax;
        ConstructorConstraint(newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken): ConstructorConstraintSyntax;
        ClassOrStructConstraint(kind: SyntaxKind, classOrStructKeyword: SyntaxToken): ClassOrStructConstraintSyntax;
        TypeConstraint(type: TypeSyntax): TypeConstraintSyntax;
        FieldDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): FieldDeclarationSyntax;
        EventFieldDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): EventFieldDeclarationSyntax;
        ExplicitInterfaceSpecifier(name: NameSyntax, dotToken: SyntaxToken): ExplicitInterfaceSpecifierSyntax;
        MethodDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): MethodDeclarationSyntax;
        OperatorDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): OperatorDeclarationSyntax;
        ConversionOperatorDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): ConversionOperatorDeclarationSyntax;
        ConstructorDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): ConstructorDeclarationSyntax;
        ConstructorInitializer(kind: SyntaxKind, colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax): ConstructorInitializerSyntax;
        DestructorDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): DestructorDeclarationSyntax;
        PropertyDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken): PropertyDeclarationSyntax;
        ArrowExpressionClause(arrowToken: SyntaxToken, expression: ExpressionSyntax): ArrowExpressionClauseSyntax;
        EventDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax): EventDeclarationSyntax;
        IndexerDeclaration(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken): IndexerDeclarationSyntax;
        AccessorList(openBraceToken: SyntaxToken, accessors: SyntaxList<AccessorDeclarationSyntax>, closeBraceToken: SyntaxToken): AccessorListSyntax;
        AccessorDeclaration(kind: SyntaxKind, attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken): AccessorDeclarationSyntax;
        ParameterList(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<ParameterSyntax>, closeParenToken: SyntaxToken): ParameterListSyntax;
        BracketedParameterList(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<ParameterSyntax>, closeBracketToken: SyntaxToken): BracketedParameterListSyntax;
        Parameter(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax): ParameterSyntax;
        IncompleteMember(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax): IncompleteMemberSyntax;
        SkippedTokensTrivia(tokens: SyntaxList<SyntaxToken>): SkippedTokensTriviaSyntax;
        DocumentationCommentTrivia(kind: SyntaxKind, content: SyntaxList<XmlNodeSyntax>, endOfComment: SyntaxToken): DocumentationCommentTriviaSyntax;
        TypeCref(type: TypeSyntax): TypeCrefSyntax;
        QualifiedCref(container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax): QualifiedCrefSyntax;
        NameMemberCref(name: TypeSyntax, parameters: CrefParameterListSyntax): NameMemberCrefSyntax;
        IndexerMemberCref(thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax): IndexerMemberCrefSyntax;
        OperatorMemberCref(operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax): OperatorMemberCrefSyntax;
        ConversionOperatorMemberCref(implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax): ConversionOperatorMemberCrefSyntax;
        CrefParameterList(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<CrefParameterSyntax>, closeParenToken: SyntaxToken): CrefParameterListSyntax;
        CrefBracketedParameterList(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<CrefParameterSyntax>, closeBracketToken: SyntaxToken): CrefBracketedParameterListSyntax;
        CrefParameter(refOrOutKeyword: SyntaxToken, type: TypeSyntax): CrefParameterSyntax;
        XmlElement(startTag: XmlElementStartTagSyntax, content: SyntaxList<XmlNodeSyntax>, endTag: XmlElementEndTagSyntax): XmlElementSyntax;
        XmlElementStartTag(lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: SyntaxList<XmlAttributeSyntax>, greaterThanToken: SyntaxToken): XmlElementStartTagSyntax;
        XmlElementEndTag(lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken): XmlElementEndTagSyntax;
        XmlEmptyElement(lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: SyntaxList<XmlAttributeSyntax>, slashGreaterThanToken: SyntaxToken): XmlEmptyElementSyntax;
        XmlName(prefix: XmlPrefixSyntax, localName: SyntaxToken): XmlNameSyntax;
        XmlPrefix(prefix: SyntaxToken, colonToken: SyntaxToken): XmlPrefixSyntax;
        XmlTextAttribute(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, endQuoteToken: SyntaxToken): XmlTextAttributeSyntax;
        XmlCrefAttribute(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken): XmlCrefAttributeSyntax;
        XmlNameAttribute(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken): XmlNameAttributeSyntax;
        XmlText(textTokens: SyntaxList<SyntaxToken>): XmlTextSyntax;
        XmlCDataSection(startCDataToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, endCDataToken: SyntaxToken): XmlCDataSectionSyntax;
        XmlProcessingInstruction(startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: SyntaxList<SyntaxToken>, endProcessingInstructionToken: SyntaxToken): XmlProcessingInstructionSyntax;
        XmlComment(lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, minusMinusGreaterThanToken: SyntaxToken): XmlCommentSyntax;
        IfDirectiveTrivia(hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): IfDirectiveTriviaSyntax;
        ElifDirectiveTrivia(hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): ElifDirectiveTriviaSyntax;
        ElseDirectiveTrivia(hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean): ElseDirectiveTriviaSyntax;
        EndIfDirectiveTrivia(hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndIfDirectiveTriviaSyntax;
        RegionDirectiveTrivia(hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): RegionDirectiveTriviaSyntax;
        EndRegionDirectiveTrivia(hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndRegionDirectiveTriviaSyntax;
        ErrorDirectiveTrivia(hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ErrorDirectiveTriviaSyntax;
        WarningDirectiveTrivia(hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): WarningDirectiveTriviaSyntax;
        BadDirectiveTrivia(hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): BadDirectiveTriviaSyntax;
        DefineDirectiveTrivia(hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): DefineDirectiveTriviaSyntax;
        UndefDirectiveTrivia(hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): UndefDirectiveTriviaSyntax;
        LineDirectiveTrivia(hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): LineDirectiveTriviaSyntax;
        PragmaWarningDirectiveTrivia(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: SeparatedSyntaxList<ExpressionSyntax>, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaWarningDirectiveTriviaSyntax;
        PragmaChecksumDirectiveTrivia(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaChecksumDirectiveTriviaSyntax;
        ReferenceDirectiveTrivia(hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ReferenceDirectiveTriviaSyntax;
        InterpolatedString(stringStart: SyntaxToken, interpolatedInserts: SeparatedSyntaxList<InterpolatedStringInsertSyntax>, stringEnd: SyntaxToken): InterpolatedStringSyntax;
        InterpolatedStringInsert(expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken): InterpolatedStringInsertSyntax;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class LanguageParser extends SyntaxParser {
        private static MaxUncheckedRecursionDepth;
        private static ensureSufficientExecutionStack;
        private pool;
        private syntaxFactoryContext;
        private syntaxFactory;
        private recursionDepth;
        private termState;
        private isInTry;
        ctor_1741(lexer: Lexer, oldTree: CSharp.CSharpSyntaxNode, changes: System.Collections.Generic.IEnumerable<Text.TextChangeRange>, lexerMode?: LexerMode, cancellationToken?: System.Threading.CancellationToken): LanguageParser;
        private static IsName(node, kind);
        private static IsNameGlobal(node);
        private static IsNameAssembly(node);
        private static IsNameModule(node);
        private static IsNameType(node);
        private static IsNameGet(node);
        private static IsNameSet(node);
        private static IsNameAdd(node);
        private static IsNameRemove(node);
        private static IsSomeWord(kind);
        static LastTerminatorState: number;
        private IsTerminator();
        private static GetOldParent(node);
        ParseCompilationUnit(): CompilationUnitSyntax;
        private CreateForInsufficientStack(state);
        private ParseNamespaceDeclaration();
        private ContainsAlias(name);
        private ContainsGeneric(name);
        private static IsPossibleStartOfTypeDeclaration(kind);
        private AddSkippedNamespaceText(openBrace, body, initialBadNodes, skippedSyntax);
        private ParseNamespaceBody(openBrace, body, initialBadNodes, parentKind);
        private static AddIncompleteMembers(incompleteMembers, body);
        private ReduceIncompleteMembers(incompleteMembers, openBrace, body, initialBadNodes);
        private IsPossibleNamespaceMemberDeclaration();
        private IsPartialInNamespaceMemberDeclaration();
        IsEndOfNamespace(): boolean;
        IsGobalAttributesTerminator(): boolean;
        private IsNamespaceMemberStartOrStop();
        private ScanExternAliasDirective();
        private ParseExternAliasDirective();
        private ParseNameEquals(warnOnGlobal?);
        private ParseUsingDirective();
        private IsPossibleGlobalAttributeDeclaration();
        private static IsGlobalAttributeTarget(token);
        private IsPossibleAttributeDeclaration();
        private ParseAttributeDeclarations(list, allowAttributes?);
        private IsAttributeDeclarationTerminator();
        private ParseAttributeDeclaration();
        private ParseAttributes(nodes);
        private SkipBadAttributeListTokens(list, expected);
        private IsPossibleAttribute();
        private ParseAttribute();
        ParseAttributeArgumentList(): AttributeArgumentListSyntax;
        private SkipBadAttributeArgumentTokens(openParen, list, expected);
        private IsPossibleAttributeArgument();
        private ParseAttributeArgument(shouldHaveName);
        private static AccessModifiers;
        private static GetModifier(token);
        private static GetFieldModifier(token);
        private IsPossibleModifier();
        private ParseModifiers(tokens);
        private ReportDuplicateModifiers(modTok, newMod, mods, seenNoDuplicates, seenNoAccessibilityDuplicates);
        private IsPartialType();
        private IsPartialMember();
        private IsPossibleMemberName();
        private static CanReuseTypeDeclaration(member);
        private ParseTypeDeclaration(attributes, modifiers);
        private static IsMissingName(name);
        private ParseClassOrStructOrInterfaceDeclaration(attributes, modifiers);
        private SkipBadMemberListTokens_9151(openBrace, members);
        private SkipBadMemberListTokens_1812(previousNode);
        private IsPossibleMemberStartOrStop();
        private IsPossibleAggregateClauseStartOrStop();
        private ParseBaseList();
        private SkipBadBaseListTokens(colon, list, expected);
        private IsPossibleTypeParameterConstraintClauseStart();
        private ParseTypeParameterConstraintClauses(isAllowed, list);
        private ParseTypeParameterConstraintClause();
        private IsPossibleTypeParameterConstraint();
        private ParseTypeParameterConstraint(isFirst, isStruct);
        private SkipBadTypeParameterConstraintTokens(list, expected);
        private ParseDeclarationType(isConstraint, parentIsParameter);
        private IsPossibleMemberStart();
        private static CanStartMember(kind);
        private static CanStartTypeDeclaration(kind);
        private static CanReuseMemberDeclaration(member, typeName);
        private ParseMemberDeclarationOrStatement(parentKind, typeName?);
        private ReconsiderTypeAsAsyncModifier(modifiers, type, explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt);
        private TypeArgumentFromTypeParameters(typeParameterList);
        private IsFieldDeclaration(isEvent);
        private IsOperatorKeyword();
        static IsComplete(node: CSharpSyntaxNode): boolean;
        private ParseConstructorDeclaration(typeName, attributes, modifiers);
        private ParseConstructorInitializer(name, isStatic);
        private ParseDestructorDeclaration(typeName, attributes, modifiers);
        private ParseBlockAndExpressionBodiesWithSemicolon(blockBody, expressionBody, semicolon);
        private CheckForBlockAndExpressionBody<T>(block, expression, syntax);
        private ParseBodyOrSemicolon(body, semicolon);
        private IsEndOfTypeParameterList();
        private IsEndOfMethodSignature();
        private IsEndOfNameInExplicitInterface();
        private ParseMethodDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifier, typeParameterList);
        private ParseReturnType();
        private IsEndOfReturnType();
        private ParseConversionOperatorDeclaration(attributes, modifiers);
        private ParseOperatorDeclaration(attributes, modifiers, type);
        private ParseIndexerDeclaration(attributes, modifiers, type, explicitInterfaceOpt, thisKeyword, typeParameterList);
        private ParsePropertyDeclaration(attributes, modifiers, type, explicitInterfaceOpt, identifier, typeParameterList);
        private ParseAccessorList(isEvent);
        private ParseArrowExpressionClause();
        private SkipBadAccessorListTokens(openBrace, list, error);
        private IsPossibleAccessor();
        private SkipBadSeparatedListTokensWithExpectedKind<T, TNode>(startToken, list, isNotExpectedFunction, abortFunction, expected);
        private SkipBadListTokensWithErrorCode<T, TNode>(startToken, list, isNotExpectedFunction, abortFunction, error);
        private SkipBadListTokensWithExpectedKindHelper(list, isNotExpectedFunction, abortFunction, expected, trailingTrivia);
        private SkipBadListTokensWithErrorCodeHelper<TNode>(list, isNotExpectedFunction, abortFunction, error, trailingTrivia);
        private SkipBadTokensWithExpectedKind(isNotExpectedFunction, abortFunction, expected, trailingTrivia);
        private SkipBadTokensWithErrorCode(isNotExpectedFunction, abortFunction, errorCode, trailingTrivia);
        private ParseAccessorDeclaration(isEvent, hasGetOrAdd, hasSetOrRemove);
        private CanReuseAccessorDeclaration(isEvent);
        ParseParenthesizedParameterList(allowThisKeyword: boolean, allowDefaults: boolean, allowAttributes: boolean): ParameterListSyntax;
        ParseBracketedParameterList(allowDefaults?: boolean): BracketedParameterListSyntax;
        private static CanReuseParameterList(list);
        private static CanReuseBracketedParameterList(list);
        private ParseParameterList(open, nodes, close, openKind, closeKind, allowThisKeyword, allowDefaults, allowAttributes);
        private IsEndOfParameterList();
        private SkipBadParameterListTokens(open, list, expected, closeKind, allowThisKeyword);
        private IsPossibleParameter(allowThisKeyword);
        private static CanReuseParameter_6813(parameter, attributes, modifiers);
        private static CanReuseParameter_9004(parameter);
        private ParseParameter(attributes, modifiers, allowThisKeyword, allowDefaults, allowAttributes);
        private static IsParameterModifier(kind, allowThisKeyword);
        private static GetParamFlags(kind, allowThisKeyword);
        private ParseParameterModifiers(modifiers, allowThisKeyword);
        private ParseFixedSizeBufferDeclaration(attributes, modifiers, parentKind);
        private ParseEventDeclaration(attributes, modifiers, parentKind);
        private ParseEventDeclarationWithAccessors(attributes, modifiers, eventToken, type);
        private EatUnexpectedTrailingSemicolon<TNode>(decl);
        private ParseNormalFieldDeclaration(attributes, modifiers, type, parentKind);
        private ParseEventFieldDeclaration(attributes, modifiers, eventToken, type, parentKind);
        private IsEndOfFieldDeclaration();
        private ParseVariableDeclarators_1538(type, flags, variables, parentKind);
        private ParseVariableDeclarators_9514(type, flags, variables, variableDeclarationsExpected);
        private SkipBadVariableListTokens(list, expected);
        private static GetOriginalModifiers(decl);
        private static WasFirstVariable(variable);
        private static GetOriginalVariableFlags(old);
        private static CanReuseVariableDeclarator(old, flags, isFirst);
        private ParseVariableDeclarator(parentType, flags, isFirst, isExpressionContext?);
        private IsPossibleEndOfVariableDeclaration();
        private ParseVariableInitializer(allowStackAlloc);
        private IsPossibleVariableInitializer(allowStack);
        private ParseConstantFieldDeclaration(attributes, modifiers, parentKind);
        private ParseDelegateDeclaration(attributes, modifiers);
        private ParseEnumDeclaration(attributes, modifiers);
        private ParseEnumMemberDeclarations(openBrace, members);
        private SkipBadEnumMemberListTokens(openBrace, list, expected);
        private ParseEnumMemberDeclaration();
        private IsPossibleEnumMemberDeclaration();
        private IsDotOrColonColon();
        ParseName(): NameSyntax;
        private CreateMissingIdentifierName();
        private static CreateMissingIdentifierToken();
        private IsTrueIdentifier();
        private ParseIdentifierName();
        private ParseIdentifierToken();
        private IsCurrentTokenQueryKeywordInQuery();
        private IsCurrentTokenPartialKeywordOfPartialMethodOrType();
        private ParseTypeParameterList(allowVariance);
        private SkipBadTypeParameterListTokens(list, expected);
        private ParseTypeParameter(allowVariance);
        private ParseSimpleName(options?);
        private ScanTypeArgumentList(inExpression);
        private ScanPossibleTypeArgumentList_1851();
        private ScanPossibleTypeArgumentList_1988(lastTokenOfList);
        private ParseTypeArgumentList(open, types, close);
        private SkipBadTypeArgumentListTokens(list, expected);
        private ParseTypeArgument();
        private IsEndOfTypeArgumentList();
        private IsOpenName();
        private ParseMemberName(explicitInterfaceOpt, identifierOrThisOpt, typeParameterListOpt, isEvent);
        private ParseAliasQualifiedName(allowedParts?);
        private ParseQualifiedName(options?);
        private ParseQualifiedNameRight(options, left, separator);
        private ConvertToMissingWithTrailingTrivia(token, expectedKind);
        private IsPossibleType();
        private IsPossibleName();
        private ScanType_7309();
        private ScanType_7346(lastTokenOfType);
        private ScanNamedTypePart_1670();
        private ScanNamedTypePart_1461(lastTokenOfType);
        private ScanNonArrayType_1055();
        private ScanNonArrayType_1475(lastTokenOfType);
        private static IsPredefinedType(keyword);
        ParseTypeName(): TypeSyntax;
        private ParseTypeOrVoid();
        private ParseType(parentIsParameter);
        private IsTerm();
        private ParseTypeCore(parentIsParameter, isOrAs, expectSizes, isArrayCreation);
        private IsPossibleRankAndDimensionSpecifier();
        private ParseArrayRankSpecifier(isArrayCreation, expectSizes, sawNonOmittedSize);
        private SkipBadArrayRankSpecifierTokens(openBracket, list, expected);
        private ParseUnderlyingType(parentIsParameter);
        private ParsePointerTypeMods(type);
        ParseStatement(): StatementSyntax;
        private ParsePossibleBadAwaitStatement_1460();
        private ParsePossibleBadAwaitStatement_1438(resetPointBeforeStatement);
        private ParseStatementNoDeclaration(allowAnyExpression);
        private IsPossibleLabeledStatement();
        private IsPossibleYieldStatement();
        private IsPossibleLocalDeclarationStatement(allowAnyExpression);
        private IsPossibleDeclarationStatementFollowingNullableType();
        private IsPossibleFieldDeclarationFollowingNullableType();
        private IsPossibleMethodDeclarationFollowingNullableType();
        private IsPossibleNewExpression();
        private static IsPossibleTypedIdentifierStart(current, next, allowThisKeyword);
        private ParseBlock(isMethodBody?, isAccessorBody?);
        private static IsLargeEnoughNonEmptyStatementList(statements);
        private ParseStatements(previousNode, statements, stopOnSwitchSections);
        private IsPossibleStatementStartOrStop();
        private SkipBadStatementListTokens(statements, expected, trailingTrivia);
        private IsPossibleStatement();
        private ParseFixedStatement();
        private IsEndOfFixedStatement();
        private ParseEmbeddedStatement(complexCheck);
        private ParseBreakStatement();
        private ParseContinueStatement();
        private ParseTryStatement();
        private IsEndOfTryBlock();
        private ParseCatchClause(hasCatchAll);
        private IsEndOfCatchClause();
        private IsEndOfFilterClause();
        private IsEndOfCatchBlock();
        private ParseClassType();
        private ParseCheckedStatement();
        private ParseDoStatement();
        private IsEndOfDoWhileExpression();
        private ParseForOrForEachStatement();
        private ParseForStatement();
        private IsEndOfForStatementArgument();
        private ParseForStatementExpressionList(startToken, list);
        private SkipBadForStatementExpressionListTokens(startToken, list, expected);
        private ParseForEachStatement();
        private ParseGotoStatement();
        private ParseIfStatement();
        private ParseLockStatement();
        private ParseReturnStatement();
        private ParseYieldStatement();
        private ParseSwitchStatement();
        private IsPossibleSwitchSection();
        private ParseSwitchSection();
        private ParseThrowStatement();
        private ParseUnsafeStatement();
        private ParseUsingStatement();
        private ParseUsingExpression(declaration, expression, resetPoint);
        private IsUsingStatementVariableDeclaration(st);
        private ParseWhileStatement();
        private ParseLabeledStatement();
        private ParseLocalDeclarationStatement();
        private ParseDeclaration(isConst, type, variables);
        private IsEndOfDeclarationClause();
        private ParseDeclarationModifiers(list);
        private static IsDeclarationModifier(kind);
        private ParseExpressionStatement_1651();
        private ParseExpressionStatement_1863(expression);
        ParseExpression(): ExpressionSyntax;
        private IsPossibleExpression();
        private static IsInvalidSubExpression(kind);
        static IsRightAssociative(op: SyntaxKind): boolean;
        private static GetPrecedence(op);
        private static IsExpectedPrefixUnaryOperator(kind);
        private static IsExpectedBinaryOperator(kind);
        private static IsExpectedAssignmentOperator(kind);
        private IsPossibleAwaitExpressionStatement();
        private IsAwaitExpression();
        private ParseSubExpression(precedence);
        private ParseTerm(precedence);
        private IsPossibleLambdaExpression(precedence);
        private ParsePostFixExpression(expr);
        private CanStartConsequenceExpression(kind);
        ParseConsequenceSyntax(): ExpressionSyntax;
        ParseParenthesizedArgumentList(): ArgumentListSyntax;
        ParseBracketedArgumentList(): BracketedArgumentListSyntax;
        private ParseArgumentList(openToken, arguments, closeToken, openKind, closeKind);
        private SkipBadArgumentListTokens(open, list, expected, closeKind);
        private IsEndOfArgumentList();
        private IsPossibleArgumentExpression();
        private ParseArgumentExpression(isIndexer);
        private ParseTypeOfExpression();
        private ParseDefaultExpression();
        private ParseSizeOfExpression();
        private ParseMakeRefExpression();
        private ParseRefTypeExpression();
        private ParseCheckedOrUncheckedExpression();
        private ParseRefValueExpression();
        private ScanParenthesizedImplicitlyTypedLambda(precedence);
        private ScanExplicitlyTypedLambda(precedence);
        private ParseCastOrParenExpressionOrLambda(precedence);
        private ScanCast();
        private ScanAsyncLambda(precedence);
        private static CanFollowCast(kind);
        private ParseNewExpression();
        private IsAnonymousType();
        private ParseAnonymousTypeExpression();
        private ParseAnonymousTypeMemberInitializers(openBrace, list);
        private ParseAnonymousTypeMemberInitializer();
        private IsAnonymousTypeMemberExpression(expr);
        private IsInitializerMember();
        private IsComplexElementInitializer();
        private IsNamedAssignment();
        private IsDictionaryInitializer();
        private ParseArrayOrObjectCreationExpression();
        private static GetNumberOfNonOmittedArraySizes(rankSpec);
        private IsPossibleArrayCreationExpression();
        private ParseObjectOrCollectionInitializer();
        private ParseObjectOrCollectionInitializerMembers(startToken, list, isObjectInitializer);
        private ParseObjectOrCollectionInitializerMember(isObjectInitializer);
        private SkipBadInitializerListTokens<T>(startToken, list, expected);
        private ParseObjectInitializerNamedAssignment();
        private ParseDictionaryInitializer();
        private ParseComplexElementInitializer();
        private ParseExpressionsForComplexElementInitializer(openBrace, list, closeBraceError);
        private ParseElementInitializer();
        private IsImplicitlyTypedArray();
        private ParseImplicitlyTypedArrayCreation();
        private ParseArrayInitializer();
        private SkipBadArrayInitializerTokens(openBrace, list, expected);
        private ParseStackAllocExpression();
        private ParseAnonymousMethodExpression();
        private static LambdaPrecedence;
        private ParseLambdaExpression();
        private ParseLambdaParameterList();
        private IsPossibleLambdaParameter();
        private SkipBadLambdaParameterListTokens(openParen, list, expected, closeKind);
        private ParseLambdaParameter(isFirst, hasTypes);
        private IsCurrentTokenQueryContextualKeyword;
        private static IsTokenQueryContextualKeyword(token);
        private static IsTokenStartOfNewQueryClause(token);
        private IsQueryExpression(mayBeVariableDeclaration, mayBeMemberDeclaration);
        private IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);
        private ParseQueryExpression();
        private ParseQueryBody();
        private ParseFromClause();
        private ParseJoinClause();
        private ParseLetClause();
        private ParseWhereClause();
        private ParseOrderByClause();
        private SkipBadOrderingListTokens(list, expected);
        private ParseOrdering();
        private ParseSelectClause();
        private ParseGroupClause();
        private ParseQueryContinuation();
        private IsIncrementalAndFactoryContextMatches;
        static MatchesFactoryContext(green: GreenNode, context: SyntaxFactoryContext): boolean;
        private IsInAsync;
        private IsInQuery;
        private EnterQuery();
        private LeaveQuery();
        private GetResetPoint_LanguageParser();
        private Reset_LanguageParser(state);
        private Release_LanguageParser(state);
        ConsumeUnexpectedTokens<TNode extends CSharpSyntaxNode>(node: TNode): TNode;
        private Substring(s, first, last);
        private ParseInterpolatedStringToken();
        MakeStringToken(text: string, bodyText: string, isVerbatim: boolean, kind: SyntaxKind): SyntaxToken;
        private ParseInterpolationStart(expr, commaToken, alignmentExpression);
        constructor();
    }
    module LanguageParser {
        enum TerminatorState {
            EndOfFile = 0,
            IsNamespaceMemberStartOrStop,
            IsAttributeDeclarationTerminator,
            IsPossibleAggregateClauseStartOrStop,
            IsPossibleMemberStartOrStop,
            IsEndOfReturnType,
            IsEndOfParameterList,
            IsEndOfFieldDeclaration,
            IsPossibleEndOfVariableDeclaration,
            IsEndOfTypeArgumentList,
            IsPossibleStatementStartOrStop,
            IsEndOfFixedStatement,
            IsEndOfTryBlock,
            IsEndOfCatchClause,
            IsEndOfilterClause,
            IsEndOfCatchBlock,
            IsEndOfDoWhileExpression,
            IsEndOfForStatementArgument,
            IsEndOfDeclarationClause,
            IsEndOfArgumentList,
            IsSwitchSectionStart,
            IsEndOfTypeParameterList,
            IsEndOfMethodSignature,
            IsEndOfNameInExplicitInterface,
        }
    }
    module LanguageParser {
        class NamespaceBodyBuilder implements IStruct {
            Externs: SyntaxListBuilder<ExternAliasDirectiveSyntax>;
            Usings: SyntaxListBuilder<UsingDirectiveSyntax>;
            Attributes: SyntaxListBuilder<AttributeListSyntax>;
            Members: SyntaxListBuilder<MemberDeclarationSyntax>;
            ctor_2673(pool: SyntaxListPool): NamespaceBodyBuilder;
            Free(pool: SyntaxListPool): void;
            constructor();
        }
    }
    module LanguageParser {
        enum NamespaceParts {
            None = 0,
            ExternAliases = 1,
            Usings = 2,
            GlobalAttributes = 3,
            MembersAndStatements = 4,
        }
    }
    module LanguageParser {
        enum SyntaxModifier {
            None = 0,
            Public = 1,
            Internal = 2,
            Protected = 4,
            Private = 8,
            Sealed = 16,
            Abstract = 32,
            Static = 64,
            Virtual = 128,
            Extern = 256,
            New = 512,
            Override = 1024,
            ReadOnly = 2048,
            Volatile = 4096,
            Unsafe = 8192,
            Partial = 16384,
            Async = 32768,
        }
    }
    module LanguageParser {
        enum PostSkipAction {
            Continue = 0,
            Abort = 1,
        }
    }
    module LanguageParser {
        enum ParamFlags {
            None = 0,
            This = 1,
            Ref = 2,
            Out = 4,
            Params = 8,
        }
    }
    module LanguageParser {
        enum VariableFlags {
            Fixed = 1,
            Const = 2,
            Local = 4,
        }
    }
    module LanguageParser {
        enum NameOptions {
            None = 0,
            InExpression,
            InTypeList,
        }
    }
    module LanguageParser {
        enum ScanTypeArgumentListKind {
            NotTypeArgumentList = 0,
            PossibleTypeArgumentList = 1,
            DefiniteTypeArgumentList = 2,
        }
    }
    module LanguageParser {
        enum ScanTypeFlags {
            NotType = 0,
            MustBeType = 1,
            GenericTypeOrMethod = 2,
            GenericTypeOrExpression = 3,
            NonGenericTypeOrExpression = 4,
            AliasQualifiedName = 5,
            NullableType = 6,
            PointerOrMultiplication = 7,
        }
    }
    module LanguageParser {
        class ResetPointLanguageParser implements IStruct {
            BaseResetPoint: SyntaxParser.ResetPoint;
            TerminatorState: TerminatorState;
            IsInTry: boolean;
            IsInAsync: boolean;
            QueryDepth: number;
            ctor_1108(resetPoint: SyntaxParser.ResetPoint, terminatorState: TerminatorState, isInTry: boolean, isInAsync: boolean, queryDepth: number): ResetPointLanguageParser;
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxListBaseBuilder {
        private nodes;
        Count: number;
        ctor_1860(size: number): SyntaxListBaseBuilder;
        Clear(): void;
        $get$(index: number): CSharpSyntaxNode;
        $set$(index: number, value: CSharpSyntaxNode): void;
        Add(item: CSharpSyntaxNode): void;
        AddRange_4255(items: CSharpSyntaxNode[]): void;
        AddRange_1279(items: CSharpSyntaxNode[], offset: number, length: number): void;
        private Validate(start, end);
        AddRange_4610(list: SyntaxList<CSharpSyntaxNode>): void;
        AddRange_5295(list: SyntaxList<CSharpSyntaxNode>, offset: number, length: number): void;
        AddRange_2002<TNode extends CSharpSyntaxNode>(list: SyntaxList<TNode>): void;
        AddRange_4324<TNode extends CSharpSyntaxNode>(list: SyntaxList<TNode>, offset: number, length: number): void;
        RemoveLast(): void;
        private EnsureAdditionalCapacity(additionalCount);
        Any(kind: SyntaxKind): boolean;
        ToArray(): CSharpSyntaxNode[];
        ToListNode(): CSharpSyntaxNode;
        static op_Implicit_1214(builder: SyntaxListBaseBuilder): SyntaxList<CSharpSyntaxNode>;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    enum SyntaxKind {
        None = 0,
        List,
        TildeToken = 8193,
        ExclamationToken = 8194,
        DollarToken = 8195,
        PercentToken = 8196,
        CaretToken = 8197,
        AmpersandToken = 8198,
        AsteriskToken = 8199,
        OpenParenToken = 8200,
        CloseParenToken = 8201,
        MinusToken = 8202,
        PlusToken = 8203,
        EqualsToken = 8204,
        OpenBraceToken = 8205,
        CloseBraceToken = 8206,
        OpenBracketToken = 8207,
        CloseBracketToken = 8208,
        BarToken = 8209,
        BackslashToken = 8210,
        ColonToken = 8211,
        SemicolonToken = 8212,
        DoubleQuoteToken = 8213,
        SingleQuoteToken = 8214,
        LessThanToken = 8215,
        CommaToken = 8216,
        GreaterThanToken = 8217,
        DotToken = 8218,
        QuestionToken = 8219,
        HashToken = 8220,
        SlashToken = 8221,
        SlashGreaterThanToken = 8232,
        LessThanSlashToken = 8233,
        XmlCommentStartToken = 8234,
        XmlCommentEndToken = 8235,
        XmlCDataStartToken = 8236,
        XmlCDataEndToken = 8237,
        XmlProcessingInstructionStartToken = 8238,
        XmlProcessingInstructionEndToken = 8239,
        BarBarToken = 8260,
        AmpersandAmpersandToken = 8261,
        MinusMinusToken = 8262,
        PlusPlusToken = 8263,
        ColonColonToken = 8264,
        QuestionQuestionToken = 8265,
        MinusGreaterThanToken = 8266,
        ExclamationEqualsToken = 8267,
        EqualsEqualsToken = 8268,
        EqualsGreaterThanToken = 8269,
        LessThanEqualsToken = 8270,
        LessThanLessThanToken = 8271,
        LessThanLessThanEqualsToken = 8272,
        GreaterThanEqualsToken = 8273,
        GreaterThanGreaterThanToken = 8274,
        GreaterThanGreaterThanEqualsToken = 8275,
        SlashEqualsToken = 8276,
        AsteriskEqualsToken = 8277,
        BarEqualsToken = 8278,
        AmpersandEqualsToken = 8279,
        PlusEqualsToken = 8280,
        MinusEqualsToken = 8281,
        CaretEqualsToken = 8282,
        PercentEqualsToken = 8283,
        BoolKeyword = 8304,
        ByteKeyword = 8305,
        SByteKeyword = 8306,
        ShortKeyword = 8307,
        UShortKeyword = 8308,
        IntKeyword = 8309,
        UIntKeyword = 8310,
        LongKeyword = 8311,
        ULongKeyword = 8312,
        DoubleKeyword = 8313,
        FloatKeyword = 8314,
        DecimalKeyword = 8315,
        StringKeyword = 8316,
        CharKeyword = 8317,
        VoidKeyword = 8318,
        ObjectKeyword = 8319,
        TypeOfKeyword = 8320,
        SizeOfKeyword = 8321,
        NullKeyword = 8322,
        TrueKeyword = 8323,
        FalseKeyword = 8324,
        IfKeyword = 8325,
        ElseKeyword = 8326,
        WhileKeyword = 8327,
        ForKeyword = 8328,
        ForEachKeyword = 8329,
        DoKeyword = 8330,
        SwitchKeyword = 8331,
        CaseKeyword = 8332,
        DefaultKeyword = 8333,
        TryKeyword = 8334,
        CatchKeyword = 8335,
        FinallyKeyword = 8336,
        LockKeyword = 8337,
        GotoKeyword = 8338,
        BreakKeyword = 8339,
        ContinueKeyword = 8340,
        ReturnKeyword = 8341,
        ThrowKeyword = 8342,
        PublicKeyword = 8343,
        PrivateKeyword = 8344,
        InternalKeyword = 8345,
        ProtectedKeyword = 8346,
        StaticKeyword = 8347,
        ReadOnlyKeyword = 8348,
        SealedKeyword = 8349,
        ConstKeyword = 8350,
        FixedKeyword = 8351,
        StackAllocKeyword = 8352,
        VolatileKeyword = 8353,
        NewKeyword = 8354,
        OverrideKeyword = 8355,
        AbstractKeyword = 8356,
        VirtualKeyword = 8357,
        EventKeyword = 8358,
        ExternKeyword = 8359,
        RefKeyword = 8360,
        OutKeyword = 8361,
        InKeyword = 8362,
        IsKeyword = 8363,
        AsKeyword = 8364,
        ParamsKeyword = 8365,
        ArgListKeyword = 8366,
        MakeRefKeyword = 8367,
        RefTypeKeyword = 8368,
        RefValueKeyword = 8369,
        ThisKeyword = 8370,
        BaseKeyword = 8371,
        NamespaceKeyword = 8372,
        UsingKeyword = 8373,
        ClassKeyword = 8374,
        StructKeyword = 8375,
        InterfaceKeyword = 8376,
        EnumKeyword = 8377,
        DelegateKeyword = 8378,
        CheckedKeyword = 8379,
        UncheckedKeyword = 8380,
        UnsafeKeyword = 8381,
        OperatorKeyword = 8382,
        ExplicitKeyword = 8383,
        ImplicitKeyword = 8384,
        YieldKeyword = 8405,
        PartialKeyword = 8406,
        AliasKeyword = 8407,
        GlobalKeyword = 8408,
        AssemblyKeyword = 8409,
        ModuleKeyword = 8410,
        TypeKeyword = 8411,
        FieldKeyword = 8412,
        MethodKeyword = 8413,
        ParamKeyword = 8414,
        PropertyKeyword = 8415,
        TypeVarKeyword = 8416,
        GetKeyword = 8417,
        SetKeyword = 8418,
        AddKeyword = 8419,
        RemoveKeyword = 8420,
        WhereKeyword = 8421,
        FromKeyword = 8422,
        GroupKeyword = 8423,
        JoinKeyword = 8424,
        IntoKeyword = 8425,
        LetKeyword = 8426,
        ByKeyword = 8427,
        SelectKeyword = 8428,
        OrderByKeyword = 8429,
        OnKeyword = 8430,
        EqualsKeyword = 8431,
        AscendingKeyword = 8432,
        DescendingKeyword = 8433,
        NameOfKeyword = 8434,
        AsyncKeyword = 8435,
        AwaitKeyword = 8436,
        ElifKeyword = 8467,
        EndIfKeyword = 8468,
        RegionKeyword = 8469,
        EndRegionKeyword = 8470,
        DefineKeyword = 8471,
        UndefKeyword = 8472,
        WarningKeyword = 8473,
        ErrorKeyword = 8474,
        LineKeyword = 8475,
        PragmaKeyword = 8476,
        HiddenKeyword = 8477,
        ChecksumKeyword = 8478,
        DisableKeyword = 8479,
        RestoreKeyword = 8480,
        ReferenceKeyword = 8481,
        OmittedTypeArgumentToken = 8492,
        OmittedArraySizeExpressionToken = 8493,
        EndOfDirectiveToken = 8494,
        EndOfDocumentationCommentToken = 8495,
        EndOfFileToken = 8496,
        BadToken = 8507,
        IdentifierToken = 8508,
        NumericLiteralToken = 8509,
        CharacterLiteralToken = 8510,
        StringLiteralToken = 8511,
        XmlEntityLiteralToken = 8512,
        XmlTextLiteralToken = 8513,
        XmlTextLiteralNewLineToken = 8514,
        InterpolatedStringToken = 8515,
        InterpolatedStringStartToken = 8516,
        InterpolatedStringMidToken = 8517,
        InterpolatedStringEndToken = 8518,
        EndOfLineTrivia = 8539,
        WhitespaceTrivia = 8540,
        SingleLineCommentTrivia = 8541,
        MultiLineCommentTrivia = 8542,
        DocumentationCommentExteriorTrivia = 8543,
        SingleLineDocumentationCommentTrivia = 8544,
        MultiLineDocumentationCommentTrivia = 8545,
        DisabledTextTrivia = 8546,
        PreprocessingMessageTrivia = 8547,
        IfDirectiveTrivia = 8548,
        ElifDirectiveTrivia = 8549,
        ElseDirectiveTrivia = 8550,
        EndIfDirectiveTrivia = 8551,
        RegionDirectiveTrivia = 8552,
        EndRegionDirectiveTrivia = 8553,
        DefineDirectiveTrivia = 8554,
        UndefDirectiveTrivia = 8555,
        ErrorDirectiveTrivia = 8556,
        WarningDirectiveTrivia = 8557,
        LineDirectiveTrivia = 8558,
        PragmaWarningDirectiveTrivia = 8559,
        PragmaChecksumDirectiveTrivia = 8560,
        ReferenceDirectiveTrivia = 8561,
        BadDirectiveTrivia = 8562,
        SkippedTokensTrivia = 8563,
        XmlElement = 8574,
        XmlElementStartTag = 8575,
        XmlElementEndTag = 8576,
        XmlEmptyElement = 8577,
        XmlTextAttribute = 8578,
        XmlCrefAttribute = 8579,
        XmlNameAttribute = 8580,
        XmlName = 8581,
        XmlPrefix = 8582,
        XmlText = 8583,
        XmlCDataSection = 8584,
        XmlComment = 8585,
        XmlProcessingInstruction = 8586,
        TypeCref = 8597,
        QualifiedCref = 8598,
        NameMemberCref = 8599,
        IndexerMemberCref = 8600,
        OperatorMemberCref = 8601,
        ConversionOperatorMemberCref = 8602,
        CrefParameterList = 8603,
        CrefBracketedParameterList = 8604,
        CrefParameter = 8605,
        IdentifierName = 8616,
        QualifiedName = 8617,
        GenericName = 8618,
        TypeArgumentList = 8619,
        AliasQualifiedName = 8620,
        PredefinedType = 8621,
        ArrayType = 8622,
        ArrayRankSpecifier = 8623,
        PointerType = 8624,
        NullableType = 8625,
        OmittedTypeArgument = 8626,
        ParenthesizedExpression = 8632,
        ConditionalExpression = 8633,
        InvocationExpression = 8634,
        ElementAccessExpression = 8635,
        ArgumentList = 8636,
        BracketedArgumentList = 8637,
        Argument = 8638,
        NameColon = 8639,
        CastExpression = 8640,
        AnonymousMethodExpression = 8641,
        SimpleLambdaExpression = 8642,
        ParenthesizedLambdaExpression = 8643,
        ObjectInitializerExpression = 8644,
        CollectionInitializerExpression = 8645,
        ArrayInitializerExpression = 8646,
        AnonymousObjectMemberDeclarator = 8647,
        ComplexElementInitializerExpression = 8648,
        ObjectCreationExpression = 8649,
        AnonymousObjectCreationExpression = 8650,
        ArrayCreationExpression = 8651,
        ImplicitArrayCreationExpression = 8652,
        StackAllocArrayCreationExpression = 8653,
        OmittedArraySizeExpression = 8654,
        InterpolatedString = 8655,
        ImplicitElementAccess = 8656,
        AddExpression = 8668,
        SubtractExpression = 8669,
        MultiplyExpression = 8670,
        DivideExpression = 8671,
        ModuloExpression = 8672,
        LeftShiftExpression = 8673,
        RightShiftExpression = 8674,
        LogicalOrExpression = 8675,
        LogicalAndExpression = 8676,
        BitwiseOrExpression = 8677,
        BitwiseAndExpression = 8678,
        ExclusiveOrExpression = 8679,
        EqualsExpression = 8680,
        NotEqualsExpression = 8681,
        LessThanExpression = 8682,
        LessThanOrEqualExpression = 8683,
        GreaterThanExpression = 8684,
        GreaterThanOrEqualExpression = 8685,
        IsExpression = 8686,
        AsExpression = 8687,
        CoalesceExpression = 8688,
        SimpleMemberAccessExpression = 8689,
        PointerMemberAccessExpression = 8690,
        ConditionalAccessExpression = 8691,
        MemberBindingExpression = 8707,
        ElementBindingExpression = 8708,
        SimpleAssignmentExpression = 8714,
        AddAssignmentExpression = 8715,
        SubtractAssignmentExpression = 8716,
        MultiplyAssignmentExpression = 8717,
        DivideAssignmentExpression = 8718,
        ModuloAssignmentExpression = 8719,
        AndAssignmentExpression = 8720,
        ExclusiveOrAssignmentExpression = 8721,
        OrAssignmentExpression = 8722,
        LeftShiftAssignmentExpression = 8723,
        RightShiftAssignmentExpression = 8724,
        UnaryPlusExpression = 8730,
        UnaryMinusExpression = 8731,
        BitwiseNotExpression = 8732,
        LogicalNotExpression = 8733,
        PreIncrementExpression = 8734,
        PreDecrementExpression = 8735,
        PointerIndirectionExpression = 8736,
        AddressOfExpression = 8737,
        PostIncrementExpression = 8738,
        PostDecrementExpression = 8739,
        AwaitExpression = 8740,
        ThisExpression = 8746,
        BaseExpression = 8747,
        ArgListExpression = 8748,
        NumericLiteralExpression = 8749,
        StringLiteralExpression = 8750,
        CharacterLiteralExpression = 8751,
        TrueLiteralExpression = 8752,
        FalseLiteralExpression = 8753,
        NullLiteralExpression = 8754,
        TypeOfExpression = 8760,
        SizeOfExpression = 8761,
        CheckedExpression = 8762,
        UncheckedExpression = 8763,
        DefaultExpression = 8764,
        MakeRefExpression = 8765,
        RefValueExpression = 8766,
        RefTypeExpression = 8767,
        QueryExpression = 8774,
        QueryBody = 8775,
        FromClause = 8776,
        LetClause = 8777,
        JoinClause = 8778,
        JoinIntoClause = 8779,
        WhereClause = 8780,
        OrderByClause = 8781,
        AscendingOrdering = 8782,
        DescendingOrdering = 8783,
        SelectClause = 8784,
        GroupClause = 8785,
        QueryContinuation = 8786,
        Block = 8792,
        LocalDeclarationStatement = 8793,
        VariableDeclaration = 8794,
        VariableDeclarator = 8795,
        EqualsValueClause = 8796,
        ExpressionStatement = 8797,
        EmptyStatement = 8798,
        LabeledStatement = 8799,
        GotoStatement = 8800,
        GotoCaseStatement = 8801,
        GotoDefaultStatement = 8802,
        BreakStatement = 8803,
        ContinueStatement = 8804,
        ReturnStatement = 8805,
        YieldReturnStatement = 8806,
        YieldBreakStatement = 8807,
        ThrowStatement = 8808,
        WhileStatement = 8809,
        DoStatement = 8810,
        ForStatement = 8811,
        ForEachStatement = 8812,
        UsingStatement = 8813,
        FixedStatement = 8814,
        CheckedStatement = 8815,
        UncheckedStatement = 8816,
        UnsafeStatement = 8817,
        LockStatement = 8818,
        IfStatement = 8819,
        ElseClause = 8820,
        SwitchStatement = 8821,
        SwitchSection = 8822,
        CaseSwitchLabel = 8823,
        DefaultSwitchLabel = 8824,
        TryStatement = 8825,
        CatchClause = 8826,
        CatchDeclaration = 8827,
        CatchFilterClause = 8828,
        FinallyClause = 8829,
        CompilationUnit = 8840,
        GlobalStatement = 8841,
        NamespaceDeclaration = 8842,
        UsingDirective = 8843,
        ExternAliasDirective = 8844,
        AttributeList = 8847,
        AttributeTargetSpecifier = 8848,
        Attribute = 8849,
        AttributeArgumentList = 8850,
        AttributeArgument = 8851,
        NameEquals = 8852,
        ClassDeclaration = 8855,
        StructDeclaration = 8856,
        InterfaceDeclaration = 8857,
        EnumDeclaration = 8858,
        DelegateDeclaration = 8859,
        BaseList = 8864,
        SimpleBaseType = 8865,
        TypeParameterConstraintClause = 8866,
        ConstructorConstraint = 8867,
        ClassConstraint = 8868,
        StructConstraint = 8869,
        TypeConstraint = 8870,
        ExplicitInterfaceSpecifier = 8871,
        EnumMemberDeclaration = 8872,
        FieldDeclaration = 8873,
        EventFieldDeclaration = 8874,
        MethodDeclaration = 8875,
        OperatorDeclaration = 8876,
        ConversionOperatorDeclaration = 8877,
        ConstructorDeclaration = 8878,
        BaseConstructorInitializer = 8889,
        ThisConstructorInitializer = 8890,
        DestructorDeclaration = 8891,
        PropertyDeclaration = 8892,
        EventDeclaration = 8893,
        IndexerDeclaration = 8894,
        AccessorList = 8895,
        GetAccessorDeclaration = 8896,
        SetAccessorDeclaration = 8897,
        AddAccessorDeclaration = 8898,
        RemoveAccessorDeclaration = 8899,
        UnknownAccessorDeclaration = 8900,
        ParameterList = 8906,
        BracketedParameterList = 8907,
        Parameter = 8908,
        TypeParameterList = 8909,
        TypeParameter = 8910,
        IncompleteMember = 8916,
        ArrowExpressionClause = 8917,
        InterpolatedStringInsert = 8918,
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxListBase extends CSharpSyntaxNode {
        ctor_2679(): SyntaxListBase;
        ctor_1542(reader: Roslyn.Utilities.ObjectReader): SyntaxListBase;
        static List_7470(child: CSharpSyntaxNode): CSharpSyntaxNode;
        static List_1257(child0: CSharpSyntaxNode, child1: CSharpSyntaxNode): SyntaxListBase.WithTwoChildren;
        static List_1258(child0: CSharpSyntaxNode, child1: CSharpSyntaxNode, child2: CSharpSyntaxNode): SyntaxListBase.WithThreeChildren;
        static List_2130(nodes: CSharpSyntaxNode[]): CSharpSyntaxNode;
        static List_8641(nodes: CSharpSyntaxNode[], count: number): CSharpSyntaxNode;
        static List_2015(children: CSharpSyntaxNode[]): SyntaxListBase;
        static List_1405(builder: SyntaxListBaseBuilder): CSharpSyntaxNode;
        CopyTo(array: CSharpSyntaxNode[], offset: number): void;
        static Concat(left: CSharpSyntaxNode, right: CSharpSyntaxNode): CSharpSyntaxNode;
        SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode;
        SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode;
        constructor();
    }
    module SyntaxListBase {
        class WithManyChildrenBase extends SyntaxListBase {
            children: CSharpSyntaxNode[];
            ctor_1434(children: CSharpSyntaxNode[]): WithManyChildrenBase;
            private InitializeChildren();
            ctor_9311(reader: Roslyn.Utilities.ObjectReader): WithManyChildrenBase;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            protected GetSlotCount(): number;
            GetSlot(index: number): GreenNode;
            CopyTo(array: CSharpSyntaxNode[], offset: number): void;
            CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
            private HasNodeTokenPattern();
            Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
            Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
            constructor();
        }
    }
    module SyntaxListBase {
        class WithManyChildren extends WithManyChildrenBase {
            ctor_6732(children: CSharpSyntaxNode[]): WithManyChildren;
            ctor_1296(reader: Roslyn.Utilities.ObjectReader): WithManyChildren;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            constructor();
        }
    }
    module SyntaxListBase {
        class WithLotsOfChildren extends WithManyChildrenBase {
            private childOffsets;
            ctor_6338(children: CSharpSyntaxNode[]): WithLotsOfChildren;
            ctor_6590(reader: Roslyn.Utilities.ObjectReader): WithLotsOfChildren;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            GetSlotOffset(index: number): number;
            private static CalculateOffsets(children);
            constructor();
        }
    }
    module SyntaxListBase {
        class WithThreeChildren extends SyntaxListBase {
            private child0;
            private child1;
            private child2;
            ctor_1749(child0: CSharpSyntaxNode, child1: CSharpSyntaxNode, child2: CSharpSyntaxNode): WithThreeChildren;
            ctor_1600(reader: Roslyn.Utilities.ObjectReader): WithThreeChildren;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            GetSlot(index: number): GreenNode;
            CopyTo(array: CSharpSyntaxNode[], offset: number): void;
            CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
            Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
            Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
            constructor();
        }
    }
    module SyntaxListBase {
        class WithTwoChildren extends SyntaxListBase {
            private child0;
            private child1;
            ctor_1839(child0: CSharpSyntaxNode, child1: CSharpSyntaxNode): WithTwoChildren;
            ctor_1505(reader: Roslyn.Utilities.ObjectReader): WithTwoChildren;
            WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void;
            GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object;
            GetSlot(index: number): GreenNode;
            CopyTo(array: CSharpSyntaxNode[], offset: number): void;
            CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode;
            Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
            Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    enum LexerMode {
        Syntax = 1,
        DebuggerSyntax = 2,
        Directive = 4,
        XmlDocComment = 8,
        XmlElementTag = 16,
        XmlAttributeTextQuote = 32,
        XmlAttributeTextDoubleQuote = 64,
        XmlCrefQuote = 128,
        XmlCrefDoubleQuote = 256,
        XmlNameQuote = 512,
        XmlNameDoubleQuote = 1024,
        XmlCDataSectionText = 2048,
        XmlCommentText = 4096,
        XmlProcessingInstructionText = 8192,
        XmlCharacter = 16384,
        MaskLexMode = 65535,
        XmlDocCommentLocationStart = 0,
        XmlDocCommentLocationInterior = 65536,
        XmlDocCommentLocationExterior = 131072,
        XmlDocCommentLocationEnd = 262144,
        MaskXmlDocCommentLocation = 983040,
        XmlDocCommentStyleSingleLine = 0,
        XmlDocCommentStyleDelimited = 1048576,
        MaskXmlDocCommentStyle = 3145728,
        None = 0,
    }
    enum XmlDocCommentLocation {
        Start = 0,
        Interior = 1,
        Exterior = 2,
        End = 4,
    }
    enum XmlDocCommentStyle {
        SingleLine = 0,
        Delimited = 1,
    }
    class Lexer extends AbstractLexer {
        private static TriviaListInitialCapacity;
        private options;
        private mode;
        private builder;
        private identBuffer;
        private identLen;
        private directives;
        private cache;
        private allowPreprocessorDirectives;
        ctor_1061(text: Text.SourceText, options: CSharpParseOptions, allowPreprocessorDirectives?: boolean): Lexer;
        Dispose(): void;
        SuppressDocumentationCommentParse: boolean;
        Options: CSharpParseOptions;
        Directives: DirectiveStack;
        Reset(position: number, directives: DirectiveStack): void;
        private static ModeOf(mode);
        private ModeIs(mode);
        private static LocationOf(mode);
        private LocationIs(location);
        private MutateLocation(location);
        private static StyleOf(mode);
        private StyleIs(style);
        private InDocumentationComment;
        Lex_5670_R(mode: {
            refObj: LexerMode;
        }): SyntaxToken;
        static TokensLexed: number;
        Lex_5670(mode: LexerMode): SyntaxToken;
        private leadingTriviaCache;
        private trailingTriviaCache;
        private static GetFullWidth(builder);
        private LexSyntaxToken();
        LexSyntaxLeadingTrivia(): SyntaxTriviaList;
        LexSyntaxTrailingTrivia(): SyntaxTriviaList;
        private Create(info, leading, trailing, errors);
        private ScanSyntaxToken(info);
        private CheckFeatureAvailability(feature);
        private ScanInteger();
        private ScanNumericLiteral(info);
        private GetValueInt32(text, isHex);
        private GetValueUInt64(text, isHex);
        private GetValueDouble(text);
        private GetValueSingle(text);
        private GetValueDecimal(text, start, end);
        private ResetIdentBuffer();
        private AddIdentChar(ch);
        private GrowIdentBuffer();
        private ScanIdentifier(info);
        private ScanIdentifier_FastPath(info);
        private ScanIdentifier_SlowPath(info);
        private static IsValidHexDigit(c);
        private ScanIdentifier_CrefSlowPath(info);
        private ScanIdentifierOrKeyword(info);
        private LexSyntaxTrivia(afterFirstToken, isTrailing, triviaList);
        private AddTrivia(trivia, list);
        private ScanMultiLineComment(isTerminated);
        private ScanToEndOfLine();
        private ScanEndOfLine();
        private ScanWhitespace();
        private createWhitespaceTriviaFunction;
        private CreateWhitespaceTrivia();
        private LexDirectiveAndExcludedTrivia(afterFirstToken, afterNonWhitespaceOnLine, triviaList);
        private LexExcludedDirectivesAndTrivia(endIsActive, triviaList);
        private LexSingleDirective(isActive, endIsActive, afterFirstToken, afterNonWhitespaceOnLine, triviaList);
        private LexDisabledText(followedByDirective);
        private LexDirectiveToken();
        private ScanDirectiveToken(info);
        private LexDirectiveTrailingTrivia(includeEndOfLine);
        private LexDirectiveTrivia();
        private xmlParser;
        private LexXmlDocComment(style);
        private LexXmlToken();
        private ScanXmlToken(info);
        private ScanXmlTagStart(info);
        private ScanXmlEntity(info);
        private static MatchesProductionForXmlChar(charValue);
        private ScanXmlText(info);
        private LexXmlElementTagToken();
        private ScanXmlElementTagToken(info);
        private ScanXmlName(info);
        private static IsXmlNameStartChar(ch);
        private static IsXmlNameChar(ch);
        private LexXmlAttributeTextToken();
        private ScanXmlAttributeTextToken(info);
        private ScanXmlAttributeText(info);
        private LexXmlCharacter();
        private ScanXmlCharacter(info);
        private LexXmlCrefOrNameToken();
        private ScanXmlCrefToken(info);
        private AdvanceIfMatches(ch);
        private InXmlCrefOrNameAttributeValue;
        private InXmlNameAttributeValue;
        private AddCrefError_6981(code, ...args);
        private AddCrefError_2347(info);
        private LexXmlCDataSectionTextToken();
        private ScanXmlCDataSectionTextToken(info);
        private ScanXmlCDataSectionText(info);
        private LexXmlCommentTextToken();
        private ScanXmlCommentTextToken(info);
        private ScanXmlCommentText(info);
        private LexXmlProcessingInstructionTextToken();
        private ScanXmlProcessingInstructionTextToken(info);
        private ScanXmlProcessingInstructionText(info);
        private LexXmlDocCommentLeadingTrivia(trivia);
        private LexXmlDocCommentLeadingTriviaWithWhitespace(trivia);
        private LexXmlWhitespaceAndNewLineTrivia(trivia);
        constructor();
        ScanStringLiteral(info: {
            refObj: Lexer.TokenInfo;
        }, allowEscapes?: boolean): void;
        ScanEscapeSequence(surrogateCharacter: {
            refObj: string;
        }): string;
        ScanVerbatimStringLiteral(info: {
            refObj: Lexer.TokenInfo;
        }, allowNewlines?: boolean): void;
        private ScanInterpolatedStringLiteral(isVerbatim, info);
        ScanInterpolatedStringLiteralTop(interpolations: ArrayBuilder<Lexer.Interpolation>, isVerbatim: boolean, info: {
            refObj: Lexer.TokenInfo;
        }, error: {
            refObj: SyntaxDiagnosticInfo;
        }): void;
        static RescanInterpolatedString(interpolatedString: InterpolatedStringSyntax): SyntaxToken;
        private static MaxCachedTokenSize;
        private static stateTransitions;
        private QuickScanSyntaxToken();
        private createQuickTokenFunction;
        private CreateQuickToken();
        private static charProperties;
    }
    module Lexer {
        class TokenInfo implements IStruct {
            Kind: SyntaxKind;
            ContextualKind: SyntaxKind;
            Text: string;
            ValueKind: SpecialType;
            RequiresTextForXmlEntity: boolean;
            HasIdentifierEscapeSequence: boolean;
            StringValue: string;
            CharValue: string;
            IntValue: number;
            UintValue: number;
            LongValue: number;
            UlongValue: number;
            FloatValue: number;
            DoubleValue: number;
            DecimalValue: number;
            IsVerbatim: boolean;
            constructor();
        }
        class Interpolation implements IStruct {
            Start: number;
            Colon: number;
            End: number;
            ctor_1605(start: number, colon: number, end: number): Interpolation;
            constructor();
        }
    }
    module Lexer {
        class InterpolatedStringScanner {
            lexer: Lexer;
            isVerbatim: boolean;
            allowNewlines: boolean;
            error: SyntaxDiagnosticInfo;
            ctor_1728(lexer: Lexer, isVerbatim: boolean): InterpolatedStringScanner;
            IsAtEnd_5911(): boolean;
            private IsAtEnd_1079(allowNewline);
            ScanInterpolatedStringLiteralTop(interpolations: ArrayBuilder<Interpolation>, info: {
                refObj: TokenInfo;
            }): void;
            private ScanInterpolatedStringLiteralContents(interpolations);
            private ScanFormatSpecifier();
            private ScanInterpolatedStringLiteralHoleBalancedText(endingChar, isHole, colonPosition);
            private ScanInterpolatedStringLiteralNestedComment();
            private ScanInterpolatedStringLiteralNestedString(quote);
            private ScanInterpolatedStringLiteralNestedVerbatimString();
            private ScanInterpolatedStringLiteralHoleBracketed(start, end);
            constructor();
        }
        enum CharFlags {
            White = 0,
            CR = 1,
            LF = 2,
            Letter = 3,
            Digit = 4,
            Punct = 5,
            Dot = 6,
            CompoundPunctStart = 7,
            Slash = 8,
            Complex = 9,
            EndOfFile = 10,
        }
        enum QuickScanState {
            Initial = 0,
            FollowingWhite = 1,
            FollowingCR = 2,
            Ident = 3,
            Number = 4,
            Punctuation = 5,
            Dot = 6,
            CompoundPunctStart = 7,
            DoneAfterNext = 8,
            Done = 9,
            Bad = 10,
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class LexerCache {
        private static keywordKindPool;
        private triviaMap;
        private tokenMap;
        private keywordKindMap;
        static MaxKeywordLength: number;
        constructor();
        Free(): void;
        TryGetKeywordKind(key: string, kind: {
            refObj: SyntaxKind;
        }): boolean;
        LookupTrivia(textBuffer: string[], keyStart: number, keyLength: number, hashCode: number, createTriviaFunction: () => SyntaxTrivia): SyntaxTrivia;
        LookupToken(textBuffer: string[], keyStart: number, keyLength: number, hashCode: number, createTokenFunction: () => SyntaxToken): SyntaxToken;
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SlidingTextWindow implements System.IDisposable {
        static InvalidCharacter: string;
        private static DefaultWindowLength;
        private text;
        private basis;
        private offset;
        private textEnd;
        private characterWindow;
        private characterWindowCount;
        private lexemeStart;
        private strings;
        private static windowPool;
        ctor_9238(text: Text.SourceText): SlidingTextWindow;
        Dispose(): void;
        Text: Text.SourceText;
        Position: number;
        Offset: number;
        CharacterWindow: string[];
        LexemeRelativeStart: number;
        CharacterWindowCount: number;
        LexemeStartPosition: number;
        Width: number;
        Start(): void;
        Reset(position: number): void;
        private MoreChars();
        IsReallyAtEnd(): boolean;
        AdvanceChar_1426(): void;
        AdvanceChar_5713(n: number): void;
        NextChar(): string;
        PeekChar_2423(): string;
        PeekChar_4867(delta: number): string;
        IsUnicodeEscape(): boolean;
        PeekCharOrUnicodeEscape(surrogateCharacter: {
            refObj: string;
        }): string;
        PeekUnicodeEscape(surrogateCharacter: {
            refObj: string;
        }): string;
        NextCharOrUnicodeEscape(surrogateCharacter: {
            refObj: string;
        }, info: {
            refObj: SyntaxDiagnosticInfo;
        }): string;
        NextUnicodeEscape(surrogateCharacter: {
            refObj: string;
        }, info: {
            refObj: SyntaxDiagnosticInfo;
        }): string;
        private ScanUnicodeEscape(peek, surrogateCharacter, info);
        TryScanXmlEntity(ch: {
            refObj: string;
        }, surrogate: {
            refObj: string;
        }): boolean;
        private AdvanceIfMatches(desired);
        private CreateIllegalEscapeDiagnostic(start);
        Intern_1886(text: System.Text.StringBuilder): string;
        Intern_1831(array: string[], start: number, length: number): string;
        GetInternedText(): string;
        GetText_5693(intern: boolean): string;
        GetText_2126(position: number, length: number, intern: boolean): string;
        static GetCharsFromUtf32(codepoint: number, lowSurrogate: {
            refObj: string;
        }): string;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxFactoryContext {
        IsInAsync: boolean;
        QueryDepth: number;
        IsInQuery: boolean;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SeparatedSyntaxListBuilder<TNode extends CSharpSyntaxNode> implements IStruct {
        private builder;
        ctor_8478(size: number): SeparatedSyntaxListBuilder<TNode>;
        static Create<TNode extends CSharpSyntaxNode>(): SeparatedSyntaxListBuilder<TNode>;
        ctor_1989(builder: SyntaxListBaseBuilder): SeparatedSyntaxListBuilder<TNode>;
        IsNull: boolean;
        Count: number;
        $get$(index: number): CSharpSyntaxNode;
        $set$(index: number, value: CSharpSyntaxNode): void;
        Clear(): void;
        Add(node: TNode): SeparatedSyntaxListBuilder<TNode>;
        AddSeparator(separatorToken: SyntaxToken): void;
        AddRange_1628(items: TNode[], offset: number, length: number): void;
        AddRange_1969(nodes: SeparatedSyntaxList<TNode>): void;
        Any(kind: SyntaxKind): boolean;
        ToList(): SeparatedSyntaxList<TNode>;
        UnderlyingBuilder: SyntaxListBaseBuilder;
        static op_Implicit_4181<TNode extends CSharpSyntaxNode>(builder: SeparatedSyntaxListBuilder<TNode>): SeparatedSyntaxList<TNode>;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxListPool {
        private freeList;
        private freeIndex;
        private allocated;
        ctor_8047(): SyntaxListPool;
        AllocateBase(): SyntaxListBaseBuilder;
        Allocate<TNode extends CSharpSyntaxNode>(): SyntaxListBuilder<TNode>;
        AllocateSeparated<TNode extends CSharpSyntaxNode>(): SeparatedSyntaxListBuilder<TNode>;
        Free_2078<TNode extends CSharpSyntaxNode>(item: SeparatedSyntaxListBuilder<TNode>): void;
        Free_1631(item: SyntaxListBaseBuilder): void;
        private Grow();
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class ObjectDisplay {
        static FormatPrimitive(obj: Object, options: ObjectDisplayOptions): string;
        static NullLiteral: string;
        static FormatLiteral_1325(value: boolean): string;
        static FormatString(str: string, quote: string, escapeNonPrintable: boolean): string;
        static FormatLiteral_1258(value: string, options: ObjectDisplayOptions): string;
        static FormatLiteral_1513(c: string, options: ObjectDisplayOptions): string;
        static FormatLiteral_7314(value: number, options: ObjectDisplayOptions): string;
        static FormatLiteral_3219(value: number, options: ObjectDisplayOptions): string;
        static FormatLiteral_3560(value: number, options: ObjectDisplayOptions): string;
        static FormatLiteral_1078(value: number, options: ObjectDisplayOptions): string;
        static FormatLiteral_6182(value: number, options: ObjectDisplayOptions): string;
        static FormatLiteral_8940(value: number, options: ObjectDisplayOptions): string;
        static FormatLiteral_2865(value: number, options: ObjectDisplayOptions): string;
        static FormatLiteral_5056(value: number, options: ObjectDisplayOptions): string;
        static FormatLiteral_1188(value: number, options: ObjectDisplayOptions): string;
        static FormatLiteral_1087(value: number, options: ObjectDisplayOptions): string;
        static FormatLiteral_8649(value: number, options: ObjectDisplayOptions): string;
        private static ValidateOptions(options);
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class SymbolDisplay {
        static FormatLiteral(value: string, quote: boolean): string;
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Symbols {
    enum AttributeLocation {
        None = 0,
        Assembly,
        Module,
        Type,
        Method,
        Field,
        Property,
        Event,
        Parameter,
        Return,
        TypeParameter,
        Unknown,
    }
    class AttributeLocationExtensions {
        static ToDisplayString(locations: AttributeLocation): string;
        static ToAttributeLocation_8655(token: SyntaxToken): AttributeLocation;
        static ToAttributeLocation_8655_NS(token: Syntax.InternalSyntax.SyntaxToken): AttributeLocation;
        private static ToAttributeLocation_9582(text);
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class GreenNodeExtensions {
        static ToGreenList_1391<T extends Syntax.InternalSyntax.CSharpSyntaxNode>(node: SyntaxNode): Syntax.InternalSyntax.SyntaxList<T>;
        static ToGreenSeparatedList<T extends Syntax.InternalSyntax.CSharpSyntaxNode>(node: SyntaxNode): Syntax.InternalSyntax.SeparatedSyntaxList<T>;
        static ToGreenList_6072<T extends Syntax.InternalSyntax.CSharpSyntaxNode>(node: GreenNode): Syntax.InternalSyntax.SyntaxList<T>;
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class CompilationUnitSyntax extends CSharpSyntaxNode {
        GetReferenceDirectives_1524(): System.Collections.Generic.IList<ReferenceDirectiveTriviaSyntax>;
        GetReferenceDirectives_2073(filter: (_: ReferenceDirectiveTriviaSyntax) => boolean): System.Collections.Generic.IList<ReferenceDirectiveTriviaSyntax>;
        GetConditionalDirectivesStack(): Syntax.InternalSyntax.DirectiveStack;
        private static IsActiveConditionalDirective(directive);
        private externs;
        private usings;
        private attributeLists;
        private members;
        ctor_7453(green: Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode, parent: SyntaxNode, position: number): CompilationUnitSyntax;
        Externs: SyntaxList<ExternAliasDirectiveSyntax>;
        Usings: SyntaxList<UsingDirectiveSyntax>;
        AttributeLists: SyntaxList<AttributeListSyntax>;
        Members: SyntaxList<MemberDeclarationSyntax>;
        EndOfFileToken: SyntaxToken;
        GetNodeSlot(index: number): SyntaxNode;
        GetCachedSlot(index: number): SyntaxNode;
        Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
        Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
        Update(externs: SyntaxList<ExternAliasDirectiveSyntax>, usings: SyntaxList<UsingDirectiveSyntax>, attributeLists: SyntaxList<AttributeListSyntax>, members: SyntaxList<MemberDeclarationSyntax>, endOfFileToken: SyntaxToken): CompilationUnitSyntax;
        WithExterns(externs: SyntaxList<ExternAliasDirectiveSyntax>): CompilationUnitSyntax;
        WithUsings(usings: SyntaxList<UsingDirectiveSyntax>): CompilationUnitSyntax;
        WithAttributeLists(attributeLists: SyntaxList<AttributeListSyntax>): CompilationUnitSyntax;
        WithMembers(members: SyntaxList<MemberDeclarationSyntax>): CompilationUnitSyntax;
        WithEndOfFileToken(endOfFileToken: SyntaxToken): CompilationUnitSyntax;
        AddExterns(...items: ExternAliasDirectiveSyntax[]): CompilationUnitSyntax;
        AddUsings(...items: UsingDirectiveSyntax[]): CompilationUnitSyntax;
        AddAttributeLists(...items: AttributeListSyntax[]): CompilationUnitSyntax;
        AddMembers(...items: MemberDeclarationSyntax[]): CompilationUnitSyntax;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class CSharpLineDirectiveMap extends LineDirectiveMap<DirectiveTriviaSyntax> {
        ctor_1559(syntaxTree: SyntaxTree): CSharpLineDirectiveMap;
        protected ShouldAddDirective(directive: DirectiveTriviaSyntax): boolean;
        protected GetEntry(directiveNode: DirectiveTriviaSyntax, sourceText: Text.SourceText, previous: LineDirectiveMap.LineMappingEntry): LineDirectiveMap.LineMappingEntry;
        protected InitializeFirstEntry(): LineDirectiveMap.LineMappingEntry;
        GetLineVisibility(sourceText: Text.SourceText, position: number): LineVisibility;
        TranslateSpanAndVisibility(sourceText: Text.SourceText, treeFilePath: string, span: Text.TextSpan, isHiddenPosition: {
            refObj: boolean;
        }): FileLinePositionSpan;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class CSharpPragmaWarningStateMap extends CodeAnalysis.Syntax.AbstractWarningStateMap {
        ctor_1595(syntaxTree: SyntaxTree): CSharpPragmaWarningStateMap;
        protected CreateWarningStateMapEntries(syntaxTree: SyntaxTree): CodeAnalysis.Syntax.AbstractWarningStateMap.WarningStateMapEntry[];
        private static GetAllPragmaWarningDirectives(syntaxTree, directiveList);
        private static CreatePragmaWarningStateEntries(directiveList);
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class CSharpSyntaxVisitor<TResult> {
        Visit(node: SyntaxNode): TResult;
        DefaultVisit(node: SyntaxNode): TResult;
        VisitIdentifierName(node: Syntax.IdentifierNameSyntax): TResult;
        VisitQualifiedName(node: Syntax.QualifiedNameSyntax): TResult;
        VisitGenericName(node: Syntax.GenericNameSyntax): TResult;
        VisitTypeArgumentList(node: Syntax.TypeArgumentListSyntax): TResult;
        VisitAliasQualifiedName(node: Syntax.AliasQualifiedNameSyntax): TResult;
        VisitPredefinedType(node: Syntax.PredefinedTypeSyntax): TResult;
        VisitArrayType(node: Syntax.ArrayTypeSyntax): TResult;
        VisitArrayRankSpecifier(node: Syntax.ArrayRankSpecifierSyntax): TResult;
        VisitPointerType(node: Syntax.PointerTypeSyntax): TResult;
        VisitNullableType(node: Syntax.NullableTypeSyntax): TResult;
        VisitOmittedTypeArgument(node: Syntax.OmittedTypeArgumentSyntax): TResult;
        VisitParenthesizedExpression(node: Syntax.ParenthesizedExpressionSyntax): TResult;
        VisitPrefixUnaryExpression(node: Syntax.PrefixUnaryExpressionSyntax): TResult;
        VisitAwaitExpression(node: Syntax.AwaitExpressionSyntax): TResult;
        VisitPostfixUnaryExpression(node: Syntax.PostfixUnaryExpressionSyntax): TResult;
        VisitMemberAccessExpression(node: Syntax.MemberAccessExpressionSyntax): TResult;
        VisitConditionalAccessExpression(node: Syntax.ConditionalAccessExpressionSyntax): TResult;
        VisitMemberBindingExpression(node: Syntax.MemberBindingExpressionSyntax): TResult;
        VisitElementBindingExpression(node: Syntax.ElementBindingExpressionSyntax): TResult;
        VisitImplicitElementAccess(node: Syntax.ImplicitElementAccessSyntax): TResult;
        VisitBinaryExpression(node: Syntax.BinaryExpressionSyntax): TResult;
        VisitAssignmentExpression(node: Syntax.AssignmentExpressionSyntax): TResult;
        VisitConditionalExpression(node: Syntax.ConditionalExpressionSyntax): TResult;
        VisitThisExpression(node: Syntax.ThisExpressionSyntax): TResult;
        VisitBaseExpression(node: Syntax.BaseExpressionSyntax): TResult;
        VisitLiteralExpression(node: Syntax.LiteralExpressionSyntax): TResult;
        VisitMakeRefExpression(node: Syntax.MakeRefExpressionSyntax): TResult;
        VisitRefTypeExpression(node: Syntax.RefTypeExpressionSyntax): TResult;
        VisitRefValueExpression(node: Syntax.RefValueExpressionSyntax): TResult;
        VisitCheckedExpression(node: Syntax.CheckedExpressionSyntax): TResult;
        VisitDefaultExpression(node: Syntax.DefaultExpressionSyntax): TResult;
        VisitTypeOfExpression(node: Syntax.TypeOfExpressionSyntax): TResult;
        VisitSizeOfExpression(node: Syntax.SizeOfExpressionSyntax): TResult;
        VisitInvocationExpression(node: Syntax.InvocationExpressionSyntax): TResult;
        VisitElementAccessExpression(node: Syntax.ElementAccessExpressionSyntax): TResult;
        VisitArgumentList(node: Syntax.ArgumentListSyntax): TResult;
        VisitBracketedArgumentList(node: Syntax.BracketedArgumentListSyntax): TResult;
        VisitArgument(node: Syntax.ArgumentSyntax): TResult;
        VisitNameColon(node: Syntax.NameColonSyntax): TResult;
        VisitCastExpression(node: Syntax.CastExpressionSyntax): TResult;
        VisitAnonymousMethodExpression(node: Syntax.AnonymousMethodExpressionSyntax): TResult;
        VisitSimpleLambdaExpression(node: Syntax.SimpleLambdaExpressionSyntax): TResult;
        VisitParenthesizedLambdaExpression(node: Syntax.ParenthesizedLambdaExpressionSyntax): TResult;
        VisitInitializerExpression(node: Syntax.InitializerExpressionSyntax): TResult;
        VisitObjectCreationExpression(node: Syntax.ObjectCreationExpressionSyntax): TResult;
        VisitAnonymousObjectMemberDeclarator(node: Syntax.AnonymousObjectMemberDeclaratorSyntax): TResult;
        VisitAnonymousObjectCreationExpression(node: Syntax.AnonymousObjectCreationExpressionSyntax): TResult;
        VisitArrayCreationExpression(node: Syntax.ArrayCreationExpressionSyntax): TResult;
        VisitImplicitArrayCreationExpression(node: Syntax.ImplicitArrayCreationExpressionSyntax): TResult;
        VisitStackAllocArrayCreationExpression(node: Syntax.StackAllocArrayCreationExpressionSyntax): TResult;
        VisitQueryExpression(node: Syntax.QueryExpressionSyntax): TResult;
        VisitQueryBody(node: Syntax.QueryBodySyntax): TResult;
        VisitFromClause(node: Syntax.FromClauseSyntax): TResult;
        VisitLetClause(node: Syntax.LetClauseSyntax): TResult;
        VisitJoinClause(node: Syntax.JoinClauseSyntax): TResult;
        VisitJoinIntoClause(node: Syntax.JoinIntoClauseSyntax): TResult;
        VisitWhereClause(node: Syntax.WhereClauseSyntax): TResult;
        VisitOrderByClause(node: Syntax.OrderByClauseSyntax): TResult;
        VisitOrdering(node: Syntax.OrderingSyntax): TResult;
        VisitSelectClause(node: Syntax.SelectClauseSyntax): TResult;
        VisitGroupClause(node: Syntax.GroupClauseSyntax): TResult;
        VisitQueryContinuation(node: Syntax.QueryContinuationSyntax): TResult;
        VisitOmittedArraySizeExpression(node: Syntax.OmittedArraySizeExpressionSyntax): TResult;
        VisitGlobalStatement(node: Syntax.GlobalStatementSyntax): TResult;
        VisitBlock(node: Syntax.BlockSyntax): TResult;
        VisitLocalDeclarationStatement(node: Syntax.LocalDeclarationStatementSyntax): TResult;
        VisitVariableDeclaration(node: Syntax.VariableDeclarationSyntax): TResult;
        VisitVariableDeclarator(node: Syntax.VariableDeclaratorSyntax): TResult;
        VisitEqualsValueClause(node: Syntax.EqualsValueClauseSyntax): TResult;
        VisitExpressionStatement(node: Syntax.ExpressionStatementSyntax): TResult;
        VisitEmptyStatement(node: Syntax.EmptyStatementSyntax): TResult;
        VisitLabeledStatement(node: Syntax.LabeledStatementSyntax): TResult;
        VisitGotoStatement(node: Syntax.GotoStatementSyntax): TResult;
        VisitBreakStatement(node: Syntax.BreakStatementSyntax): TResult;
        VisitContinueStatement(node: Syntax.ContinueStatementSyntax): TResult;
        VisitReturnStatement(node: Syntax.ReturnStatementSyntax): TResult;
        VisitThrowStatement(node: Syntax.ThrowStatementSyntax): TResult;
        VisitYieldStatement(node: Syntax.YieldStatementSyntax): TResult;
        VisitWhileStatement(node: Syntax.WhileStatementSyntax): TResult;
        VisitDoStatement(node: Syntax.DoStatementSyntax): TResult;
        VisitForStatement(node: Syntax.ForStatementSyntax): TResult;
        VisitForEachStatement(node: Syntax.ForEachStatementSyntax): TResult;
        VisitUsingStatement(node: Syntax.UsingStatementSyntax): TResult;
        VisitFixedStatement(node: Syntax.FixedStatementSyntax): TResult;
        VisitCheckedStatement(node: Syntax.CheckedStatementSyntax): TResult;
        VisitUnsafeStatement(node: Syntax.UnsafeStatementSyntax): TResult;
        VisitLockStatement(node: Syntax.LockStatementSyntax): TResult;
        VisitIfStatement(node: Syntax.IfStatementSyntax): TResult;
        VisitElseClause(node: Syntax.ElseClauseSyntax): TResult;
        VisitSwitchStatement(node: Syntax.SwitchStatementSyntax): TResult;
        VisitSwitchSection(node: Syntax.SwitchSectionSyntax): TResult;
        VisitCaseSwitchLabel(node: Syntax.CaseSwitchLabelSyntax): TResult;
        VisitDefaultSwitchLabel(node: Syntax.DefaultSwitchLabelSyntax): TResult;
        VisitTryStatement(node: Syntax.TryStatementSyntax): TResult;
        VisitCatchClause(node: Syntax.CatchClauseSyntax): TResult;
        VisitCatchDeclaration(node: Syntax.CatchDeclarationSyntax): TResult;
        VisitCatchFilterClause(node: Syntax.CatchFilterClauseSyntax): TResult;
        VisitFinallyClause(node: Syntax.FinallyClauseSyntax): TResult;
        VisitCompilationUnit(node: Syntax.CompilationUnitSyntax): TResult;
        VisitExternAliasDirective(node: Syntax.ExternAliasDirectiveSyntax): TResult;
        VisitUsingDirective(node: Syntax.UsingDirectiveSyntax): TResult;
        VisitNamespaceDeclaration(node: Syntax.NamespaceDeclarationSyntax): TResult;
        VisitAttributeList(node: Syntax.AttributeListSyntax): TResult;
        VisitAttributeTargetSpecifier(node: Syntax.AttributeTargetSpecifierSyntax): TResult;
        VisitAttribute(node: Syntax.AttributeSyntax): TResult;
        VisitAttributeArgumentList(node: Syntax.AttributeArgumentListSyntax): TResult;
        VisitAttributeArgument(node: Syntax.AttributeArgumentSyntax): TResult;
        VisitNameEquals(node: Syntax.NameEqualsSyntax): TResult;
        VisitTypeParameterList(node: Syntax.TypeParameterListSyntax): TResult;
        VisitTypeParameter(node: Syntax.TypeParameterSyntax): TResult;
        VisitClassDeclaration(node: Syntax.ClassDeclarationSyntax): TResult;
        VisitStructDeclaration(node: Syntax.StructDeclarationSyntax): TResult;
        VisitInterfaceDeclaration(node: Syntax.InterfaceDeclarationSyntax): TResult;
        VisitEnumDeclaration(node: Syntax.EnumDeclarationSyntax): TResult;
        VisitDelegateDeclaration(node: Syntax.DelegateDeclarationSyntax): TResult;
        VisitEnumMemberDeclaration(node: Syntax.EnumMemberDeclarationSyntax): TResult;
        VisitBaseList(node: Syntax.BaseListSyntax): TResult;
        VisitSimpleBaseType(node: Syntax.SimpleBaseTypeSyntax): TResult;
        VisitTypeParameterConstraintClause(node: Syntax.TypeParameterConstraintClauseSyntax): TResult;
        VisitConstructorConstraint(node: Syntax.ConstructorConstraintSyntax): TResult;
        VisitClassOrStructConstraint(node: Syntax.ClassOrStructConstraintSyntax): TResult;
        VisitTypeConstraint(node: Syntax.TypeConstraintSyntax): TResult;
        VisitFieldDeclaration(node: Syntax.FieldDeclarationSyntax): TResult;
        VisitEventFieldDeclaration(node: Syntax.EventFieldDeclarationSyntax): TResult;
        VisitExplicitInterfaceSpecifier(node: Syntax.ExplicitInterfaceSpecifierSyntax): TResult;
        VisitMethodDeclaration(node: Syntax.MethodDeclarationSyntax): TResult;
        VisitOperatorDeclaration(node: Syntax.OperatorDeclarationSyntax): TResult;
        VisitConversionOperatorDeclaration(node: Syntax.ConversionOperatorDeclarationSyntax): TResult;
        VisitConstructorDeclaration(node: Syntax.ConstructorDeclarationSyntax): TResult;
        VisitConstructorInitializer(node: Syntax.ConstructorInitializerSyntax): TResult;
        VisitDestructorDeclaration(node: Syntax.DestructorDeclarationSyntax): TResult;
        VisitPropertyDeclaration(node: Syntax.PropertyDeclarationSyntax): TResult;
        VisitArrowExpressionClause(node: Syntax.ArrowExpressionClauseSyntax): TResult;
        VisitEventDeclaration(node: Syntax.EventDeclarationSyntax): TResult;
        VisitIndexerDeclaration(node: Syntax.IndexerDeclarationSyntax): TResult;
        VisitAccessorList(node: Syntax.AccessorListSyntax): TResult;
        VisitAccessorDeclaration(node: Syntax.AccessorDeclarationSyntax): TResult;
        VisitParameterList(node: Syntax.ParameterListSyntax): TResult;
        VisitBracketedParameterList(node: Syntax.BracketedParameterListSyntax): TResult;
        VisitParameter(node: Syntax.ParameterSyntax): TResult;
        VisitIncompleteMember(node: Syntax.IncompleteMemberSyntax): TResult;
        VisitSkippedTokensTrivia(node: Syntax.SkippedTokensTriviaSyntax): TResult;
        VisitDocumentationCommentTrivia(node: Syntax.DocumentationCommentTriviaSyntax): TResult;
        VisitTypeCref(node: Syntax.TypeCrefSyntax): TResult;
        VisitQualifiedCref(node: Syntax.QualifiedCrefSyntax): TResult;
        VisitNameMemberCref(node: Syntax.NameMemberCrefSyntax): TResult;
        VisitIndexerMemberCref(node: Syntax.IndexerMemberCrefSyntax): TResult;
        VisitOperatorMemberCref(node: Syntax.OperatorMemberCrefSyntax): TResult;
        VisitConversionOperatorMemberCref(node: Syntax.ConversionOperatorMemberCrefSyntax): TResult;
        VisitCrefParameterList(node: Syntax.CrefParameterListSyntax): TResult;
        VisitCrefBracketedParameterList(node: Syntax.CrefBracketedParameterListSyntax): TResult;
        VisitCrefParameter(node: Syntax.CrefParameterSyntax): TResult;
        VisitXmlElement(node: Syntax.XmlElementSyntax): TResult;
        VisitXmlElementStartTag(node: Syntax.XmlElementStartTagSyntax): TResult;
        VisitXmlElementEndTag(node: Syntax.XmlElementEndTagSyntax): TResult;
        VisitXmlEmptyElement(node: Syntax.XmlEmptyElementSyntax): TResult;
        VisitXmlName(node: Syntax.XmlNameSyntax): TResult;
        VisitXmlPrefix(node: Syntax.XmlPrefixSyntax): TResult;
        VisitXmlTextAttribute(node: Syntax.XmlTextAttributeSyntax): TResult;
        VisitXmlCrefAttribute(node: Syntax.XmlCrefAttributeSyntax): TResult;
        VisitXmlNameAttribute(node: Syntax.XmlNameAttributeSyntax): TResult;
        VisitXmlText(node: Syntax.XmlTextSyntax): TResult;
        VisitXmlCDataSection(node: Syntax.XmlCDataSectionSyntax): TResult;
        VisitXmlProcessingInstruction(node: Syntax.XmlProcessingInstructionSyntax): TResult;
        VisitXmlComment(node: Syntax.XmlCommentSyntax): TResult;
        VisitIfDirectiveTrivia(node: Syntax.IfDirectiveTriviaSyntax): TResult;
        VisitElifDirectiveTrivia(node: Syntax.ElifDirectiveTriviaSyntax): TResult;
        VisitElseDirectiveTrivia(node: Syntax.ElseDirectiveTriviaSyntax): TResult;
        VisitEndIfDirectiveTrivia(node: Syntax.EndIfDirectiveTriviaSyntax): TResult;
        VisitRegionDirectiveTrivia(node: Syntax.RegionDirectiveTriviaSyntax): TResult;
        VisitEndRegionDirectiveTrivia(node: Syntax.EndRegionDirectiveTriviaSyntax): TResult;
        VisitErrorDirectiveTrivia(node: Syntax.ErrorDirectiveTriviaSyntax): TResult;
        VisitWarningDirectiveTrivia(node: Syntax.WarningDirectiveTriviaSyntax): TResult;
        VisitBadDirectiveTrivia(node: Syntax.BadDirectiveTriviaSyntax): TResult;
        VisitDefineDirectiveTrivia(node: Syntax.DefineDirectiveTriviaSyntax): TResult;
        VisitUndefDirectiveTrivia(node: Syntax.UndefDirectiveTriviaSyntax): TResult;
        VisitLineDirectiveTrivia(node: Syntax.LineDirectiveTriviaSyntax): TResult;
        VisitPragmaWarningDirectiveTrivia(node: Syntax.PragmaWarningDirectiveTriviaSyntax): TResult;
        VisitPragmaChecksumDirectiveTrivia(node: Syntax.PragmaChecksumDirectiveTriviaSyntax): TResult;
        VisitReferenceDirectiveTrivia(node: Syntax.ReferenceDirectiveTriviaSyntax): TResult;
        VisitInterpolatedString(node: Syntax.InterpolatedStringSyntax): TResult;
        VisitInterpolatedStringInsert(node: Syntax.InterpolatedStringInsertSyntax): TResult;
        constructor();
    }
    class CSharpSyntaxVisitorBase {
        Visit(node: SyntaxNode): void;
        DefaultVisit(node: SyntaxNode): void;
        VisitIdentifierName(node: Syntax.IdentifierNameSyntax): void;
        VisitQualifiedName(node: Syntax.QualifiedNameSyntax): void;
        VisitGenericName(node: Syntax.GenericNameSyntax): void;
        VisitTypeArgumentList(node: Syntax.TypeArgumentListSyntax): void;
        VisitAliasQualifiedName(node: Syntax.AliasQualifiedNameSyntax): void;
        VisitPredefinedType(node: Syntax.PredefinedTypeSyntax): void;
        VisitArrayType(node: Syntax.ArrayTypeSyntax): void;
        VisitArrayRankSpecifier(node: Syntax.ArrayRankSpecifierSyntax): void;
        VisitPointerType(node: Syntax.PointerTypeSyntax): void;
        VisitNullableType(node: Syntax.NullableTypeSyntax): void;
        VisitOmittedTypeArgument(node: Syntax.OmittedTypeArgumentSyntax): void;
        VisitParenthesizedExpression(node: Syntax.ParenthesizedExpressionSyntax): void;
        VisitPrefixUnaryExpression(node: Syntax.PrefixUnaryExpressionSyntax): void;
        VisitAwaitExpression(node: Syntax.AwaitExpressionSyntax): void;
        VisitPostfixUnaryExpression(node: Syntax.PostfixUnaryExpressionSyntax): void;
        VisitMemberAccessExpression(node: Syntax.MemberAccessExpressionSyntax): void;
        VisitConditionalAccessExpression(node: Syntax.ConditionalAccessExpressionSyntax): void;
        VisitMemberBindingExpression(node: Syntax.MemberBindingExpressionSyntax): void;
        VisitElementBindingExpression(node: Syntax.ElementBindingExpressionSyntax): void;
        VisitImplicitElementAccess(node: Syntax.ImplicitElementAccessSyntax): void;
        VisitBinaryExpression(node: Syntax.BinaryExpressionSyntax): void;
        VisitAssignmentExpression(node: Syntax.AssignmentExpressionSyntax): void;
        VisitConditionalExpression(node: Syntax.ConditionalExpressionSyntax): void;
        VisitThisExpression(node: Syntax.ThisExpressionSyntax): void;
        VisitBaseExpression(node: Syntax.BaseExpressionSyntax): void;
        VisitLiteralExpression(node: Syntax.LiteralExpressionSyntax): void;
        VisitMakeRefExpression(node: Syntax.MakeRefExpressionSyntax): void;
        VisitRefTypeExpression(node: Syntax.RefTypeExpressionSyntax): void;
        VisitRefValueExpression(node: Syntax.RefValueExpressionSyntax): void;
        VisitCheckedExpression(node: Syntax.CheckedExpressionSyntax): void;
        VisitDefaultExpression(node: Syntax.DefaultExpressionSyntax): void;
        VisitTypeOfExpression(node: Syntax.TypeOfExpressionSyntax): void;
        VisitSizeOfExpression(node: Syntax.SizeOfExpressionSyntax): void;
        VisitInvocationExpression(node: Syntax.InvocationExpressionSyntax): void;
        VisitElementAccessExpression(node: Syntax.ElementAccessExpressionSyntax): void;
        VisitArgumentList(node: Syntax.ArgumentListSyntax): void;
        VisitBracketedArgumentList(node: Syntax.BracketedArgumentListSyntax): void;
        VisitArgument(node: Syntax.ArgumentSyntax): void;
        VisitNameColon(node: Syntax.NameColonSyntax): void;
        VisitCastExpression(node: Syntax.CastExpressionSyntax): void;
        VisitAnonymousMethodExpression(node: Syntax.AnonymousMethodExpressionSyntax): void;
        VisitSimpleLambdaExpression(node: Syntax.SimpleLambdaExpressionSyntax): void;
        VisitParenthesizedLambdaExpression(node: Syntax.ParenthesizedLambdaExpressionSyntax): void;
        VisitInitializerExpression(node: Syntax.InitializerExpressionSyntax): void;
        VisitObjectCreationExpression(node: Syntax.ObjectCreationExpressionSyntax): void;
        VisitAnonymousObjectMemberDeclarator(node: Syntax.AnonymousObjectMemberDeclaratorSyntax): void;
        VisitAnonymousObjectCreationExpression(node: Syntax.AnonymousObjectCreationExpressionSyntax): void;
        VisitArrayCreationExpression(node: Syntax.ArrayCreationExpressionSyntax): void;
        VisitImplicitArrayCreationExpression(node: Syntax.ImplicitArrayCreationExpressionSyntax): void;
        VisitStackAllocArrayCreationExpression(node: Syntax.StackAllocArrayCreationExpressionSyntax): void;
        VisitQueryExpression(node: Syntax.QueryExpressionSyntax): void;
        VisitQueryBody(node: Syntax.QueryBodySyntax): void;
        VisitFromClause(node: Syntax.FromClauseSyntax): void;
        VisitLetClause(node: Syntax.LetClauseSyntax): void;
        VisitJoinClause(node: Syntax.JoinClauseSyntax): void;
        VisitJoinIntoClause(node: Syntax.JoinIntoClauseSyntax): void;
        VisitWhereClause(node: Syntax.WhereClauseSyntax): void;
        VisitOrderByClause(node: Syntax.OrderByClauseSyntax): void;
        VisitOrdering(node: Syntax.OrderingSyntax): void;
        VisitSelectClause(node: Syntax.SelectClauseSyntax): void;
        VisitGroupClause(node: Syntax.GroupClauseSyntax): void;
        VisitQueryContinuation(node: Syntax.QueryContinuationSyntax): void;
        VisitOmittedArraySizeExpression(node: Syntax.OmittedArraySizeExpressionSyntax): void;
        VisitGlobalStatement(node: Syntax.GlobalStatementSyntax): void;
        VisitBlock(node: Syntax.BlockSyntax): void;
        VisitLocalDeclarationStatement(node: Syntax.LocalDeclarationStatementSyntax): void;
        VisitVariableDeclaration(node: Syntax.VariableDeclarationSyntax): void;
        VisitVariableDeclarator(node: Syntax.VariableDeclaratorSyntax): void;
        VisitEqualsValueClause(node: Syntax.EqualsValueClauseSyntax): void;
        VisitExpressionStatement(node: Syntax.ExpressionStatementSyntax): void;
        VisitEmptyStatement(node: Syntax.EmptyStatementSyntax): void;
        VisitLabeledStatement(node: Syntax.LabeledStatementSyntax): void;
        VisitGotoStatement(node: Syntax.GotoStatementSyntax): void;
        VisitBreakStatement(node: Syntax.BreakStatementSyntax): void;
        VisitContinueStatement(node: Syntax.ContinueStatementSyntax): void;
        VisitReturnStatement(node: Syntax.ReturnStatementSyntax): void;
        VisitThrowStatement(node: Syntax.ThrowStatementSyntax): void;
        VisitYieldStatement(node: Syntax.YieldStatementSyntax): void;
        VisitWhileStatement(node: Syntax.WhileStatementSyntax): void;
        VisitDoStatement(node: Syntax.DoStatementSyntax): void;
        VisitForStatement(node: Syntax.ForStatementSyntax): void;
        VisitForEachStatement(node: Syntax.ForEachStatementSyntax): void;
        VisitUsingStatement(node: Syntax.UsingStatementSyntax): void;
        VisitFixedStatement(node: Syntax.FixedStatementSyntax): void;
        VisitCheckedStatement(node: Syntax.CheckedStatementSyntax): void;
        VisitUnsafeStatement(node: Syntax.UnsafeStatementSyntax): void;
        VisitLockStatement(node: Syntax.LockStatementSyntax): void;
        VisitIfStatement(node: Syntax.IfStatementSyntax): void;
        VisitElseClause(node: Syntax.ElseClauseSyntax): void;
        VisitSwitchStatement(node: Syntax.SwitchStatementSyntax): void;
        VisitSwitchSection(node: Syntax.SwitchSectionSyntax): void;
        VisitCaseSwitchLabel(node: Syntax.CaseSwitchLabelSyntax): void;
        VisitDefaultSwitchLabel(node: Syntax.DefaultSwitchLabelSyntax): void;
        VisitTryStatement(node: Syntax.TryStatementSyntax): void;
        VisitCatchClause(node: Syntax.CatchClauseSyntax): void;
        VisitCatchDeclaration(node: Syntax.CatchDeclarationSyntax): void;
        VisitCatchFilterClause(node: Syntax.CatchFilterClauseSyntax): void;
        VisitFinallyClause(node: Syntax.FinallyClauseSyntax): void;
        VisitCompilationUnit(node: Syntax.CompilationUnitSyntax): void;
        VisitExternAliasDirective(node: Syntax.ExternAliasDirectiveSyntax): void;
        VisitUsingDirective(node: Syntax.UsingDirectiveSyntax): void;
        VisitNamespaceDeclaration(node: Syntax.NamespaceDeclarationSyntax): void;
        VisitAttributeList(node: Syntax.AttributeListSyntax): void;
        VisitAttributeTargetSpecifier(node: Syntax.AttributeTargetSpecifierSyntax): void;
        VisitAttribute(node: Syntax.AttributeSyntax): void;
        VisitAttributeArgumentList(node: Syntax.AttributeArgumentListSyntax): void;
        VisitAttributeArgument(node: Syntax.AttributeArgumentSyntax): void;
        VisitNameEquals(node: Syntax.NameEqualsSyntax): void;
        VisitTypeParameterList(node: Syntax.TypeParameterListSyntax): void;
        VisitTypeParameter(node: Syntax.TypeParameterSyntax): void;
        VisitClassDeclaration(node: Syntax.ClassDeclarationSyntax): void;
        VisitStructDeclaration(node: Syntax.StructDeclarationSyntax): void;
        VisitInterfaceDeclaration(node: Syntax.InterfaceDeclarationSyntax): void;
        VisitEnumDeclaration(node: Syntax.EnumDeclarationSyntax): void;
        VisitDelegateDeclaration(node: Syntax.DelegateDeclarationSyntax): void;
        VisitEnumMemberDeclaration(node: Syntax.EnumMemberDeclarationSyntax): void;
        VisitBaseList(node: Syntax.BaseListSyntax): void;
        VisitSimpleBaseType(node: Syntax.SimpleBaseTypeSyntax): void;
        VisitTypeParameterConstraintClause(node: Syntax.TypeParameterConstraintClauseSyntax): void;
        VisitConstructorConstraint(node: Syntax.ConstructorConstraintSyntax): void;
        VisitClassOrStructConstraint(node: Syntax.ClassOrStructConstraintSyntax): void;
        VisitTypeConstraint(node: Syntax.TypeConstraintSyntax): void;
        VisitFieldDeclaration(node: Syntax.FieldDeclarationSyntax): void;
        VisitEventFieldDeclaration(node: Syntax.EventFieldDeclarationSyntax): void;
        VisitExplicitInterfaceSpecifier(node: Syntax.ExplicitInterfaceSpecifierSyntax): void;
        VisitMethodDeclaration(node: Syntax.MethodDeclarationSyntax): void;
        VisitOperatorDeclaration(node: Syntax.OperatorDeclarationSyntax): void;
        VisitConversionOperatorDeclaration(node: Syntax.ConversionOperatorDeclarationSyntax): void;
        VisitConstructorDeclaration(node: Syntax.ConstructorDeclarationSyntax): void;
        VisitConstructorInitializer(node: Syntax.ConstructorInitializerSyntax): void;
        VisitDestructorDeclaration(node: Syntax.DestructorDeclarationSyntax): void;
        VisitPropertyDeclaration(node: Syntax.PropertyDeclarationSyntax): void;
        VisitArrowExpressionClause(node: Syntax.ArrowExpressionClauseSyntax): void;
        VisitEventDeclaration(node: Syntax.EventDeclarationSyntax): void;
        VisitIndexerDeclaration(node: Syntax.IndexerDeclarationSyntax): void;
        VisitAccessorList(node: Syntax.AccessorListSyntax): void;
        VisitAccessorDeclaration(node: Syntax.AccessorDeclarationSyntax): void;
        VisitParameterList(node: Syntax.ParameterListSyntax): void;
        VisitBracketedParameterList(node: Syntax.BracketedParameterListSyntax): void;
        VisitParameter(node: Syntax.ParameterSyntax): void;
        VisitIncompleteMember(node: Syntax.IncompleteMemberSyntax): void;
        VisitSkippedTokensTrivia(node: Syntax.SkippedTokensTriviaSyntax): void;
        VisitDocumentationCommentTrivia(node: Syntax.DocumentationCommentTriviaSyntax): void;
        VisitTypeCref(node: Syntax.TypeCrefSyntax): void;
        VisitQualifiedCref(node: Syntax.QualifiedCrefSyntax): void;
        VisitNameMemberCref(node: Syntax.NameMemberCrefSyntax): void;
        VisitIndexerMemberCref(node: Syntax.IndexerMemberCrefSyntax): void;
        VisitOperatorMemberCref(node: Syntax.OperatorMemberCrefSyntax): void;
        VisitConversionOperatorMemberCref(node: Syntax.ConversionOperatorMemberCrefSyntax): void;
        VisitCrefParameterList(node: Syntax.CrefParameterListSyntax): void;
        VisitCrefBracketedParameterList(node: Syntax.CrefBracketedParameterListSyntax): void;
        VisitCrefParameter(node: Syntax.CrefParameterSyntax): void;
        VisitXmlElement(node: Syntax.XmlElementSyntax): void;
        VisitXmlElementStartTag(node: Syntax.XmlElementStartTagSyntax): void;
        VisitXmlElementEndTag(node: Syntax.XmlElementEndTagSyntax): void;
        VisitXmlEmptyElement(node: Syntax.XmlEmptyElementSyntax): void;
        VisitXmlName(node: Syntax.XmlNameSyntax): void;
        VisitXmlPrefix(node: Syntax.XmlPrefixSyntax): void;
        VisitXmlTextAttribute(node: Syntax.XmlTextAttributeSyntax): void;
        VisitXmlCrefAttribute(node: Syntax.XmlCrefAttributeSyntax): void;
        VisitXmlNameAttribute(node: Syntax.XmlNameAttributeSyntax): void;
        VisitXmlText(node: Syntax.XmlTextSyntax): void;
        VisitXmlCDataSection(node: Syntax.XmlCDataSectionSyntax): void;
        VisitXmlProcessingInstruction(node: Syntax.XmlProcessingInstructionSyntax): void;
        VisitXmlComment(node: Syntax.XmlCommentSyntax): void;
        VisitIfDirectiveTrivia(node: Syntax.IfDirectiveTriviaSyntax): void;
        VisitElifDirectiveTrivia(node: Syntax.ElifDirectiveTriviaSyntax): void;
        VisitElseDirectiveTrivia(node: Syntax.ElseDirectiveTriviaSyntax): void;
        VisitEndIfDirectiveTrivia(node: Syntax.EndIfDirectiveTriviaSyntax): void;
        VisitRegionDirectiveTrivia(node: Syntax.RegionDirectiveTriviaSyntax): void;
        VisitEndRegionDirectiveTrivia(node: Syntax.EndRegionDirectiveTriviaSyntax): void;
        VisitErrorDirectiveTrivia(node: Syntax.ErrorDirectiveTriviaSyntax): void;
        VisitWarningDirectiveTrivia(node: Syntax.WarningDirectiveTriviaSyntax): void;
        VisitBadDirectiveTrivia(node: Syntax.BadDirectiveTriviaSyntax): void;
        VisitDefineDirectiveTrivia(node: Syntax.DefineDirectiveTriviaSyntax): void;
        VisitUndefDirectiveTrivia(node: Syntax.UndefDirectiveTriviaSyntax): void;
        VisitLineDirectiveTrivia(node: Syntax.LineDirectiveTriviaSyntax): void;
        VisitPragmaWarningDirectiveTrivia(node: Syntax.PragmaWarningDirectiveTriviaSyntax): void;
        VisitPragmaChecksumDirectiveTrivia(node: Syntax.PragmaChecksumDirectiveTriviaSyntax): void;
        VisitReferenceDirectiveTrivia(node: Syntax.ReferenceDirectiveTriviaSyntax): void;
        VisitInterpolatedString(node: Syntax.InterpolatedStringSyntax): void;
        VisitInterpolatedStringInsert(node: Syntax.InterpolatedStringInsertSyntax): void;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class CSharpSyntaxRewriter extends CSharpSyntaxVisitor<SyntaxNode> {
        private visitIntoStructuredTrivia;
        ctor_2068(visitIntoStructuredTrivia?: boolean): CSharpSyntaxRewriter;
        VisitIntoStructuredTrivia: boolean;
        VisitToken(token: SyntaxToken): SyntaxToken;
        VisitTrivia(trivia: SyntaxTrivia): SyntaxTrivia;
        VisitList_1459<TNode extends SyntaxNode>(list: SyntaxList<TNode>): SyntaxList<TNode>;
        VisitListElement_1414<TNode extends SyntaxNode>(node: TNode): TNode;
        VisitList_2124<TNode extends SyntaxNode>(list: SeparatedSyntaxList<TNode>): SeparatedSyntaxList<TNode>;
        VisitListSeparator(separator: SyntaxToken): SyntaxToken;
        VisitList_2127(list: SyntaxTokenList): SyntaxTokenList;
        VisitList_8614(list: SyntaxTriviaList): SyntaxTriviaList;
        VisitListElement_1457(element: SyntaxTrivia): SyntaxTrivia;
        VisitIdentifierName(node: Syntax.IdentifierNameSyntax): SyntaxNode;
        VisitQualifiedName(node: Syntax.QualifiedNameSyntax): SyntaxNode;
        VisitGenericName(node: Syntax.GenericNameSyntax): SyntaxNode;
        VisitTypeArgumentList(node: Syntax.TypeArgumentListSyntax): SyntaxNode;
        VisitAliasQualifiedName(node: Syntax.AliasQualifiedNameSyntax): SyntaxNode;
        VisitPredefinedType(node: Syntax.PredefinedTypeSyntax): SyntaxNode;
        VisitArrayType(node: Syntax.ArrayTypeSyntax): SyntaxNode;
        VisitArrayRankSpecifier(node: Syntax.ArrayRankSpecifierSyntax): SyntaxNode;
        VisitPointerType(node: Syntax.PointerTypeSyntax): SyntaxNode;
        VisitNullableType(node: Syntax.NullableTypeSyntax): SyntaxNode;
        VisitOmittedTypeArgument(node: Syntax.OmittedTypeArgumentSyntax): SyntaxNode;
        VisitParenthesizedExpression(node: Syntax.ParenthesizedExpressionSyntax): SyntaxNode;
        VisitPrefixUnaryExpression(node: Syntax.PrefixUnaryExpressionSyntax): SyntaxNode;
        VisitAwaitExpression(node: Syntax.AwaitExpressionSyntax): SyntaxNode;
        VisitPostfixUnaryExpression(node: Syntax.PostfixUnaryExpressionSyntax): SyntaxNode;
        VisitMemberAccessExpression(node: Syntax.MemberAccessExpressionSyntax): SyntaxNode;
        VisitConditionalAccessExpression(node: Syntax.ConditionalAccessExpressionSyntax): SyntaxNode;
        VisitMemberBindingExpression(node: Syntax.MemberBindingExpressionSyntax): SyntaxNode;
        VisitElementBindingExpression(node: Syntax.ElementBindingExpressionSyntax): SyntaxNode;
        VisitImplicitElementAccess(node: Syntax.ImplicitElementAccessSyntax): SyntaxNode;
        VisitBinaryExpression(node: Syntax.BinaryExpressionSyntax): SyntaxNode;
        VisitAssignmentExpression(node: Syntax.AssignmentExpressionSyntax): SyntaxNode;
        VisitConditionalExpression(node: Syntax.ConditionalExpressionSyntax): SyntaxNode;
        VisitThisExpression(node: Syntax.ThisExpressionSyntax): SyntaxNode;
        VisitBaseExpression(node: Syntax.BaseExpressionSyntax): SyntaxNode;
        VisitLiteralExpression(node: Syntax.LiteralExpressionSyntax): SyntaxNode;
        VisitMakeRefExpression(node: Syntax.MakeRefExpressionSyntax): SyntaxNode;
        VisitRefTypeExpression(node: Syntax.RefTypeExpressionSyntax): SyntaxNode;
        VisitRefValueExpression(node: Syntax.RefValueExpressionSyntax): SyntaxNode;
        VisitCheckedExpression(node: Syntax.CheckedExpressionSyntax): SyntaxNode;
        VisitDefaultExpression(node: Syntax.DefaultExpressionSyntax): SyntaxNode;
        VisitTypeOfExpression(node: Syntax.TypeOfExpressionSyntax): SyntaxNode;
        VisitSizeOfExpression(node: Syntax.SizeOfExpressionSyntax): SyntaxNode;
        VisitInvocationExpression(node: Syntax.InvocationExpressionSyntax): SyntaxNode;
        VisitElementAccessExpression(node: Syntax.ElementAccessExpressionSyntax): SyntaxNode;
        VisitArgumentList(node: Syntax.ArgumentListSyntax): SyntaxNode;
        VisitBracketedArgumentList(node: Syntax.BracketedArgumentListSyntax): SyntaxNode;
        VisitArgument(node: Syntax.ArgumentSyntax): SyntaxNode;
        VisitNameColon(node: Syntax.NameColonSyntax): SyntaxNode;
        VisitCastExpression(node: Syntax.CastExpressionSyntax): SyntaxNode;
        VisitAnonymousMethodExpression(node: Syntax.AnonymousMethodExpressionSyntax): SyntaxNode;
        VisitSimpleLambdaExpression(node: Syntax.SimpleLambdaExpressionSyntax): SyntaxNode;
        VisitParenthesizedLambdaExpression(node: Syntax.ParenthesizedLambdaExpressionSyntax): SyntaxNode;
        VisitInitializerExpression(node: Syntax.InitializerExpressionSyntax): SyntaxNode;
        VisitObjectCreationExpression(node: Syntax.ObjectCreationExpressionSyntax): SyntaxNode;
        VisitAnonymousObjectMemberDeclarator(node: Syntax.AnonymousObjectMemberDeclaratorSyntax): SyntaxNode;
        VisitAnonymousObjectCreationExpression(node: Syntax.AnonymousObjectCreationExpressionSyntax): SyntaxNode;
        VisitArrayCreationExpression(node: Syntax.ArrayCreationExpressionSyntax): SyntaxNode;
        VisitImplicitArrayCreationExpression(node: Syntax.ImplicitArrayCreationExpressionSyntax): SyntaxNode;
        VisitStackAllocArrayCreationExpression(node: Syntax.StackAllocArrayCreationExpressionSyntax): SyntaxNode;
        VisitQueryExpression(node: Syntax.QueryExpressionSyntax): SyntaxNode;
        VisitQueryBody(node: Syntax.QueryBodySyntax): SyntaxNode;
        VisitFromClause(node: Syntax.FromClauseSyntax): SyntaxNode;
        VisitLetClause(node: Syntax.LetClauseSyntax): SyntaxNode;
        VisitJoinClause(node: Syntax.JoinClauseSyntax): SyntaxNode;
        VisitJoinIntoClause(node: Syntax.JoinIntoClauseSyntax): SyntaxNode;
        VisitWhereClause(node: Syntax.WhereClauseSyntax): SyntaxNode;
        VisitOrderByClause(node: Syntax.OrderByClauseSyntax): SyntaxNode;
        VisitOrdering(node: Syntax.OrderingSyntax): SyntaxNode;
        VisitSelectClause(node: Syntax.SelectClauseSyntax): SyntaxNode;
        VisitGroupClause(node: Syntax.GroupClauseSyntax): SyntaxNode;
        VisitQueryContinuation(node: Syntax.QueryContinuationSyntax): SyntaxNode;
        VisitOmittedArraySizeExpression(node: Syntax.OmittedArraySizeExpressionSyntax): SyntaxNode;
        VisitGlobalStatement(node: Syntax.GlobalStatementSyntax): SyntaxNode;
        VisitBlock(node: Syntax.BlockSyntax): SyntaxNode;
        VisitLocalDeclarationStatement(node: Syntax.LocalDeclarationStatementSyntax): SyntaxNode;
        VisitVariableDeclaration(node: Syntax.VariableDeclarationSyntax): SyntaxNode;
        VisitVariableDeclarator(node: Syntax.VariableDeclaratorSyntax): SyntaxNode;
        VisitEqualsValueClause(node: Syntax.EqualsValueClauseSyntax): SyntaxNode;
        VisitExpressionStatement(node: Syntax.ExpressionStatementSyntax): SyntaxNode;
        VisitEmptyStatement(node: Syntax.EmptyStatementSyntax): SyntaxNode;
        VisitLabeledStatement(node: Syntax.LabeledStatementSyntax): SyntaxNode;
        VisitGotoStatement(node: Syntax.GotoStatementSyntax): SyntaxNode;
        VisitBreakStatement(node: Syntax.BreakStatementSyntax): SyntaxNode;
        VisitContinueStatement(node: Syntax.ContinueStatementSyntax): SyntaxNode;
        VisitReturnStatement(node: Syntax.ReturnStatementSyntax): SyntaxNode;
        VisitThrowStatement(node: Syntax.ThrowStatementSyntax): SyntaxNode;
        VisitYieldStatement(node: Syntax.YieldStatementSyntax): SyntaxNode;
        VisitWhileStatement(node: Syntax.WhileStatementSyntax): SyntaxNode;
        VisitDoStatement(node: Syntax.DoStatementSyntax): SyntaxNode;
        VisitForStatement(node: Syntax.ForStatementSyntax): SyntaxNode;
        VisitForEachStatement(node: Syntax.ForEachStatementSyntax): SyntaxNode;
        VisitUsingStatement(node: Syntax.UsingStatementSyntax): SyntaxNode;
        VisitFixedStatement(node: Syntax.FixedStatementSyntax): SyntaxNode;
        VisitCheckedStatement(node: Syntax.CheckedStatementSyntax): SyntaxNode;
        VisitUnsafeStatement(node: Syntax.UnsafeStatementSyntax): SyntaxNode;
        VisitLockStatement(node: Syntax.LockStatementSyntax): SyntaxNode;
        VisitIfStatement(node: Syntax.IfStatementSyntax): SyntaxNode;
        VisitElseClause(node: Syntax.ElseClauseSyntax): SyntaxNode;
        VisitSwitchStatement(node: Syntax.SwitchStatementSyntax): SyntaxNode;
        VisitSwitchSection(node: Syntax.SwitchSectionSyntax): SyntaxNode;
        VisitCaseSwitchLabel(node: Syntax.CaseSwitchLabelSyntax): SyntaxNode;
        VisitDefaultSwitchLabel(node: Syntax.DefaultSwitchLabelSyntax): SyntaxNode;
        VisitTryStatement(node: Syntax.TryStatementSyntax): SyntaxNode;
        VisitCatchClause(node: Syntax.CatchClauseSyntax): SyntaxNode;
        VisitCatchDeclaration(node: Syntax.CatchDeclarationSyntax): SyntaxNode;
        VisitCatchFilterClause(node: Syntax.CatchFilterClauseSyntax): SyntaxNode;
        VisitFinallyClause(node: Syntax.FinallyClauseSyntax): SyntaxNode;
        VisitCompilationUnit(node: Syntax.CompilationUnitSyntax): SyntaxNode;
        VisitExternAliasDirective(node: Syntax.ExternAliasDirectiveSyntax): SyntaxNode;
        VisitUsingDirective(node: Syntax.UsingDirectiveSyntax): SyntaxNode;
        VisitNamespaceDeclaration(node: Syntax.NamespaceDeclarationSyntax): SyntaxNode;
        VisitAttributeList(node: Syntax.AttributeListSyntax): SyntaxNode;
        VisitAttributeTargetSpecifier(node: Syntax.AttributeTargetSpecifierSyntax): SyntaxNode;
        VisitAttribute(node: Syntax.AttributeSyntax): SyntaxNode;
        VisitAttributeArgumentList(node: Syntax.AttributeArgumentListSyntax): SyntaxNode;
        VisitAttributeArgument(node: Syntax.AttributeArgumentSyntax): SyntaxNode;
        VisitNameEquals(node: Syntax.NameEqualsSyntax): SyntaxNode;
        VisitTypeParameterList(node: Syntax.TypeParameterListSyntax): SyntaxNode;
        VisitTypeParameter(node: Syntax.TypeParameterSyntax): SyntaxNode;
        VisitClassDeclaration(node: Syntax.ClassDeclarationSyntax): SyntaxNode;
        VisitStructDeclaration(node: Syntax.StructDeclarationSyntax): SyntaxNode;
        VisitInterfaceDeclaration(node: Syntax.InterfaceDeclarationSyntax): SyntaxNode;
        VisitEnumDeclaration(node: Syntax.EnumDeclarationSyntax): SyntaxNode;
        VisitDelegateDeclaration(node: Syntax.DelegateDeclarationSyntax): SyntaxNode;
        VisitEnumMemberDeclaration(node: Syntax.EnumMemberDeclarationSyntax): SyntaxNode;
        VisitBaseList(node: Syntax.BaseListSyntax): SyntaxNode;
        VisitSimpleBaseType(node: Syntax.SimpleBaseTypeSyntax): SyntaxNode;
        VisitTypeParameterConstraintClause(node: Syntax.TypeParameterConstraintClauseSyntax): SyntaxNode;
        VisitConstructorConstraint(node: Syntax.ConstructorConstraintSyntax): SyntaxNode;
        VisitClassOrStructConstraint(node: Syntax.ClassOrStructConstraintSyntax): SyntaxNode;
        VisitTypeConstraint(node: Syntax.TypeConstraintSyntax): SyntaxNode;
        VisitFieldDeclaration(node: Syntax.FieldDeclarationSyntax): SyntaxNode;
        VisitEventFieldDeclaration(node: Syntax.EventFieldDeclarationSyntax): SyntaxNode;
        VisitExplicitInterfaceSpecifier(node: Syntax.ExplicitInterfaceSpecifierSyntax): SyntaxNode;
        VisitMethodDeclaration(node: Syntax.MethodDeclarationSyntax): SyntaxNode;
        VisitOperatorDeclaration(node: Syntax.OperatorDeclarationSyntax): SyntaxNode;
        VisitConversionOperatorDeclaration(node: Syntax.ConversionOperatorDeclarationSyntax): SyntaxNode;
        VisitConstructorDeclaration(node: Syntax.ConstructorDeclarationSyntax): SyntaxNode;
        VisitConstructorInitializer(node: Syntax.ConstructorInitializerSyntax): SyntaxNode;
        VisitDestructorDeclaration(node: Syntax.DestructorDeclarationSyntax): SyntaxNode;
        VisitPropertyDeclaration(node: Syntax.PropertyDeclarationSyntax): SyntaxNode;
        VisitArrowExpressionClause(node: Syntax.ArrowExpressionClauseSyntax): SyntaxNode;
        VisitEventDeclaration(node: Syntax.EventDeclarationSyntax): SyntaxNode;
        VisitIndexerDeclaration(node: Syntax.IndexerDeclarationSyntax): SyntaxNode;
        VisitAccessorList(node: Syntax.AccessorListSyntax): SyntaxNode;
        VisitAccessorDeclaration(node: Syntax.AccessorDeclarationSyntax): SyntaxNode;
        VisitParameterList(node: Syntax.ParameterListSyntax): SyntaxNode;
        VisitBracketedParameterList(node: Syntax.BracketedParameterListSyntax): SyntaxNode;
        VisitParameter(node: Syntax.ParameterSyntax): SyntaxNode;
        VisitIncompleteMember(node: Syntax.IncompleteMemberSyntax): SyntaxNode;
        VisitSkippedTokensTrivia(node: Syntax.SkippedTokensTriviaSyntax): SyntaxNode;
        VisitDocumentationCommentTrivia(node: Syntax.DocumentationCommentTriviaSyntax): SyntaxNode;
        VisitTypeCref(node: Syntax.TypeCrefSyntax): SyntaxNode;
        VisitQualifiedCref(node: Syntax.QualifiedCrefSyntax): SyntaxNode;
        VisitNameMemberCref(node: Syntax.NameMemberCrefSyntax): SyntaxNode;
        VisitIndexerMemberCref(node: Syntax.IndexerMemberCrefSyntax): SyntaxNode;
        VisitOperatorMemberCref(node: Syntax.OperatorMemberCrefSyntax): SyntaxNode;
        VisitConversionOperatorMemberCref(node: Syntax.ConversionOperatorMemberCrefSyntax): SyntaxNode;
        VisitCrefParameterList(node: Syntax.CrefParameterListSyntax): SyntaxNode;
        VisitCrefBracketedParameterList(node: Syntax.CrefBracketedParameterListSyntax): SyntaxNode;
        VisitCrefParameter(node: Syntax.CrefParameterSyntax): SyntaxNode;
        VisitXmlElement(node: Syntax.XmlElementSyntax): SyntaxNode;
        VisitXmlElementStartTag(node: Syntax.XmlElementStartTagSyntax): SyntaxNode;
        VisitXmlElementEndTag(node: Syntax.XmlElementEndTagSyntax): SyntaxNode;
        VisitXmlEmptyElement(node: Syntax.XmlEmptyElementSyntax): SyntaxNode;
        VisitXmlName(node: Syntax.XmlNameSyntax): SyntaxNode;
        VisitXmlPrefix(node: Syntax.XmlPrefixSyntax): SyntaxNode;
        VisitXmlTextAttribute(node: Syntax.XmlTextAttributeSyntax): SyntaxNode;
        VisitXmlCrefAttribute(node: Syntax.XmlCrefAttributeSyntax): SyntaxNode;
        VisitXmlNameAttribute(node: Syntax.XmlNameAttributeSyntax): SyntaxNode;
        VisitXmlText(node: Syntax.XmlTextSyntax): SyntaxNode;
        VisitXmlCDataSection(node: Syntax.XmlCDataSectionSyntax): SyntaxNode;
        VisitXmlProcessingInstruction(node: Syntax.XmlProcessingInstructionSyntax): SyntaxNode;
        VisitXmlComment(node: Syntax.XmlCommentSyntax): SyntaxNode;
        VisitIfDirectiveTrivia(node: Syntax.IfDirectiveTriviaSyntax): SyntaxNode;
        VisitElifDirectiveTrivia(node: Syntax.ElifDirectiveTriviaSyntax): SyntaxNode;
        VisitElseDirectiveTrivia(node: Syntax.ElseDirectiveTriviaSyntax): SyntaxNode;
        VisitEndIfDirectiveTrivia(node: Syntax.EndIfDirectiveTriviaSyntax): SyntaxNode;
        VisitRegionDirectiveTrivia(node: Syntax.RegionDirectiveTriviaSyntax): SyntaxNode;
        VisitEndRegionDirectiveTrivia(node: Syntax.EndRegionDirectiveTriviaSyntax): SyntaxNode;
        VisitErrorDirectiveTrivia(node: Syntax.ErrorDirectiveTriviaSyntax): SyntaxNode;
        VisitWarningDirectiveTrivia(node: Syntax.WarningDirectiveTriviaSyntax): SyntaxNode;
        VisitBadDirectiveTrivia(node: Syntax.BadDirectiveTriviaSyntax): SyntaxNode;
        VisitDefineDirectiveTrivia(node: Syntax.DefineDirectiveTriviaSyntax): SyntaxNode;
        VisitUndefDirectiveTrivia(node: Syntax.UndefDirectiveTriviaSyntax): SyntaxNode;
        VisitLineDirectiveTrivia(node: Syntax.LineDirectiveTriviaSyntax): SyntaxNode;
        VisitPragmaWarningDirectiveTrivia(node: Syntax.PragmaWarningDirectiveTriviaSyntax): SyntaxNode;
        VisitPragmaChecksumDirectiveTrivia(node: Syntax.PragmaChecksumDirectiveTriviaSyntax): SyntaxNode;
        VisitReferenceDirectiveTrivia(node: Syntax.ReferenceDirectiveTriviaSyntax): SyntaxNode;
        VisitInterpolatedString(node: Syntax.InterpolatedStringSyntax): SyntaxNode;
        VisitInterpolatedStringInsert(node: Syntax.InterpolatedStringInsertSyntax): SyntaxNode;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class SyntaxFactory {
        static CarriageReturnLineFeed: SyntaxTrivia;
        static LineFeed: SyntaxTrivia;
        static CarriageReturn: SyntaxTrivia;
        static Space: SyntaxTrivia;
        static Tab: SyntaxTrivia;
        static ElasticCarriageReturnLineFeed: SyntaxTrivia;
        static ElasticLineFeed: SyntaxTrivia;
        static ElasticCarriageReturn: SyntaxTrivia;
        static ElasticSpace: SyntaxTrivia;
        static ElasticTab: SyntaxTrivia;
        static ElasticMarker: SyntaxTrivia;
        static EndOfLine(text: string, elastic?: boolean): SyntaxTrivia;
        static Whitespace(text: string, elastic?: boolean): SyntaxTrivia;
        static Comment(text: string): SyntaxTrivia;
        static DisabledText(text: string): SyntaxTrivia;
        static PreprocessingMessage(text: string): SyntaxTrivia;
        static SyntaxTrivia(kind: SyntaxKind, text: string): SyntaxTrivia;
        static Token_1045(kind: SyntaxKind): SyntaxToken;
        static Token_1123(leading: SyntaxTriviaList, kind: SyntaxKind, trailing: SyntaxTriviaList): SyntaxToken;
        static Token_1359(leading: SyntaxTriviaList, kind: SyntaxKind, text: string, valueText: string, trailing: SyntaxTriviaList): SyntaxToken;
        static MissingToken_7070(kind: SyntaxKind): SyntaxToken;
        static MissingToken_5237(leading: SyntaxTriviaList, kind: SyntaxKind, trailing: SyntaxTriviaList): SyntaxToken;
        static Identifier_3961(text: string): SyntaxToken;
        static Identifier_1392(leading: SyntaxTriviaList, text: string, trailing: SyntaxTriviaList): SyntaxToken;
        static VerbatimIdentifier(leading: SyntaxTriviaList, text: string, valueText: string, trailing: SyntaxTriviaList): SyntaxToken;
        static Identifier_1456(leading: SyntaxTriviaList, contextualKind: SyntaxKind, text: string, valueText: string, trailing: SyntaxTriviaList): SyntaxToken;
        static Literal_1132(value: number): SyntaxToken;
        static Literal_2119(text: string, value: number): SyntaxToken;
        static Literal_1342(leading: SyntaxTriviaList, text: string, value: number, trailing: SyntaxTriviaList): SyntaxToken;
        static Literal_1612(value: number): SyntaxToken;
        static Literal_4691(text: string, value: number): SyntaxToken;
        static Literal_1062(leading: SyntaxTriviaList, text: string, value: number, trailing: SyntaxTriviaList): SyntaxToken;
        static Literal_5880(value: number): SyntaxToken;
        static Literal_9280(text: string, value: number): SyntaxToken;
        static Literal_1300(leading: SyntaxTriviaList, text: string, value: number, trailing: SyntaxTriviaList): SyntaxToken;
        static Literal_1611(value: number): SyntaxToken;
        static Literal_4687(text: string, value: number): SyntaxToken;
        static Literal_1715(leading: SyntaxTriviaList, text: string, value: number, trailing: SyntaxTriviaList): SyntaxToken;
        static Literal_7513(value: number): SyntaxToken;
        static Literal_2138(text: string, value: number): SyntaxToken;
        static Literal_1609(leading: SyntaxTriviaList, text: string, value: number, trailing: SyntaxTriviaList): SyntaxToken;
        static Literal_3036(value: number): SyntaxToken;
        static Literal_1071(text: string, value: number): SyntaxToken;
        static Literal_2099(leading: SyntaxTriviaList, text: string, value: number, trailing: SyntaxTriviaList): SyntaxToken;
        static Literal_1676(value: number): SyntaxToken;
        static Literal_1853(text: string, value: number): SyntaxToken;
        static Literal_1085(leading: SyntaxTriviaList, text: string, value: number, trailing: SyntaxTriviaList): SyntaxToken;
        static Literal_2063(value: string): SyntaxToken;
        static Literal_1069(text: string, value: string): SyntaxToken;
        static Literal_4456(leading: SyntaxTriviaList, text: string, value: string, trailing: SyntaxTriviaList): SyntaxToken;
        static Literal_1331(value: string): SyntaxToken;
        static Literal_5364(text: string, value: string): SyntaxToken;
        static Literal_1408(leading: SyntaxTriviaList, text: string, value: string, trailing: SyntaxTriviaList): SyntaxToken;
        static BadToken(leading: SyntaxTriviaList, text: string, trailing: SyntaxTriviaList): SyntaxToken;
        static XmlTextLiteral(leading: SyntaxTriviaList, text: string, value: string, trailing: SyntaxTriviaList): SyntaxToken;
        static XmlTextNewLine(leading: SyntaxTriviaList, text: string, value: string, trailing: SyntaxTriviaList): SyntaxToken;
        static XmlEntity(leading: SyntaxTriviaList, text: string, value: string, trailing: SyntaxTriviaList): SyntaxToken;
        static DocumentationCommentExterior(text: string): SyntaxTrivia;
        static List_1448<TNode extends SyntaxNode>(): SyntaxList<TNode>;
        static SingletonList<TNode extends SyntaxNode>(node: TNode): SyntaxList<TNode>;
        static List_1439<TNode extends SyntaxNode>(nodes: System.Collections.Generic.IEnumerable<TNode>): SyntaxList<TNode>;
        static TokenList_1198(): SyntaxTokenList;
        static TokenList_2032(token: SyntaxToken): SyntaxTokenList;
        static TokenList_4662_Arr(tokens: SyntaxToken[]): SyntaxTokenList;
        static TokenList_4662(...tokens: SyntaxToken[]): SyntaxTokenList;
        static TokenList_6736(tokens: System.Collections.Generic.IEnumerable<SyntaxToken>): SyntaxTokenList;
        static Trivia(node: Syntax.StructuredTriviaSyntax): SyntaxTrivia;
        static TriviaList_1535(): SyntaxTriviaList;
        static TriviaList_7214(trivia: SyntaxTrivia): SyntaxTriviaList;
        static TriviaList_1408(...trivias: SyntaxTrivia[]): SyntaxTriviaList;
        static TriviaList_9316(trivias: System.Collections.Generic.IEnumerable<SyntaxTrivia>): SyntaxTriviaList;
        static SeparatedList_2415<TNode extends SyntaxNode>(): SeparatedSyntaxList<TNode>;
        static SingletonSeparatedList<TNode extends SyntaxNode>(node: TNode): SeparatedSyntaxList<TNode>;
        static SeparatedList_4526<TNode extends SyntaxNode>(nodes: System.Collections.Generic.IEnumerable<TNode>): SeparatedSyntaxList<TNode>;
        static SeparatedList_1014<TNode extends SyntaxNode>(nodes: System.Collections.Generic.IEnumerable<TNode>, separators: System.Collections.Generic.IEnumerable<SyntaxToken>): SeparatedSyntaxList<TNode>;
        static SeparatedList_1051<TNode extends SyntaxNode>(typeNode: {
            prototype: TNode;
        }, nodesAndTokens: System.Collections.Generic.IEnumerable<SyntaxNodeOrToken>): SeparatedSyntaxList<TNode>;
        static SeparatedList_1580<TNode extends SyntaxNode>(typeNode: {
            prototype: TNode;
        }, nodesAndTokens: SyntaxNodeOrTokenList): SeparatedSyntaxList<TNode>;
        private static NodesAreCorrectType<TNode>(typeNode, list);
        private static HasSeparatedNodeTokenPattern(list);
        static NodeOrTokenList_1718(): SyntaxNodeOrTokenList;
        static NodeOrTokenList_2074(nodesAndTokens: System.Collections.Generic.IEnumerable<SyntaxNodeOrToken>): SyntaxNodeOrTokenList;
        static NodeOrTokenList_2060(...nodesAndTokens: SyntaxNodeOrToken[]): SyntaxNodeOrTokenList;
        static IdentifierName_1404(name: string): Syntax.IdentifierNameSyntax;
        static SyntaxTree(root: SyntaxNode, options?: ParseOptions, path?: string, encoding?: System.Text.Encoding): SyntaxTree;
        static ParseSyntaxTree_2146(text: string, options?: ParseOptions, path?: string, encoding?: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken): SyntaxTree;
        static ParseSyntaxTree_2957(text: Text.SourceText, options?: ParseOptions, path?: string, cancellationToken?: System.Threading.CancellationToken): SyntaxTree;
        static ParseLeadingTrivia_9484(text: string, offset?: number): SyntaxTriviaList;
        static ParseLeadingTrivia_1568(text: string, options: CSharpParseOptions, offset?: number): SyntaxTriviaList;
        static ParseTrailingTrivia(text: string, offset?: number): SyntaxTriviaList;
        static ParseCref(text: string): Syntax.CrefSyntax;
        static ParseToken(text: string, offset?: number): SyntaxToken;
        static ParseTokens(text: string, offset?: number, initialTokenPosition?: number, options?: CSharpParseOptions): System.Collections.Generic.IEnumerable<SyntaxToken>;
        static ParseName(text: string, offset?: number, consumeFullText?: boolean): Syntax.NameSyntax;
        static ParseTypeName(text: string, offset?: number, consumeFullText?: boolean): Syntax.TypeSyntax;
        static ParseExpression(text: string, offset?: number, options?: ParseOptions, consumeFullText?: boolean): Syntax.ExpressionSyntax;
        static ParseStatement(text: string, offset?: number, options?: ParseOptions, consumeFullText?: boolean): Syntax.StatementSyntax;
        static ParseCompilationUnit(text: string, offset?: number, options?: CSharpParseOptions): Syntax.CompilationUnitSyntax;
        static ParseParameterList(text: string, offset?: number, options?: ParseOptions, consumeFullText?: boolean): Syntax.ParameterListSyntax;
        static ParseBracketedParameterList(text: string, offset?: number, options?: ParseOptions, consumeFullText?: boolean): Syntax.BracketedParameterListSyntax;
        static ParseArgumentList(text: string, offset?: number, options?: ParseOptions, consumeFullText?: boolean): Syntax.ArgumentListSyntax;
        static ParseBracketedArgumentList(text: string, offset?: number, options?: ParseOptions, consumeFullText?: boolean): Syntax.BracketedArgumentListSyntax;
        static ParseAttributeArgumentList(text: string, offset?: number, options?: ParseOptions, consumeFullText?: boolean): Syntax.AttributeArgumentListSyntax;
        private static MakeSourceText(text, offset);
        private static MakeLexer(text, offset, options?);
        private static MakeParser(lexer);
        static AreEquivalent_1404(oldTree: SyntaxTree, newTree: SyntaxTree, topLevel: boolean): boolean;
        static AreEquivalent_6317(oldNode: SyntaxNode, newNode: SyntaxNode, topLevel: boolean): boolean;
        static AreEquivalent_9979(oldNode: SyntaxNode, newNode: SyntaxNode, ignoreChildNode?: (_: SyntaxKind) => boolean): boolean;
        static AreEquivalent_8521(oldToken: SyntaxToken, newToken: SyntaxToken): boolean;
        static AreEquivalent_1097(oldList: SyntaxTokenList, newList: SyntaxTokenList): boolean;
        static AreEquivalent_2110<TNode extends CSharpSyntaxNode>(oldList: SyntaxList<TNode>, newList: SyntaxList<TNode>, topLevel: boolean): boolean;
        static AreEquivalent_5736<TNode extends SyntaxNode>(oldList: SyntaxList<TNode>, newList: SyntaxList<TNode>, ignoreChildNode?: (_: SyntaxKind) => boolean): boolean;
        static AreEquivalent_3678<TNode extends SyntaxNode>(oldList: SeparatedSyntaxList<TNode>, newList: SeparatedSyntaxList<TNode>, topLevel: boolean): boolean;
        static AreEquivalent_3062<TNode extends SyntaxNode>(oldList: SeparatedSyntaxList<TNode>, newList: SeparatedSyntaxList<TNode>, ignoreChildNode?: (_: SyntaxKind) => boolean): boolean;
        static GetStandaloneType(node: Syntax.TypeSyntax): Syntax.TypeSyntax;
        static GetStandaloneExpression(expression: Syntax.ExpressionSyntax): Syntax.ExpressionSyntax;
        static GetStandaloneNode(node: CSharpSyntaxNode): CSharpSyntaxNode;
        static FindConditionalAccessNodeForBinding(node: CSharpSyntaxNode): Syntax.ConditionalAccessExpressionSyntax;
        static GetNonGenericExpression(expression: Syntax.ExpressionSyntax): Syntax.ExpressionSyntax;
        static IsCompleteSubmission(tree: SyntaxTree): boolean;
        private static HasUnterminatedMultiLineComment(triviaList);
        static CaseSwitchLabel_3348(value: Syntax.ExpressionSyntax): Syntax.CaseSwitchLabelSyntax;
        static DefaultSwitchLabel_1172(): Syntax.DefaultSwitchLabelSyntax;
        static Block_4359(...statements: Syntax.StatementSyntax[]): Syntax.BlockSyntax;
        static Block_6043(statements: System.Collections.Generic.IEnumerable<Syntax.StatementSyntax>): Syntax.BlockSyntax;
        static PropertyDeclaration_1949(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, type: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: Syntax.AccessorListSyntax): Syntax.PropertyDeclarationSyntax;
        static MethodDeclaration_1736(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, returnType: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, parameterList: Syntax.ParameterListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>, body: Syntax.BlockSyntax, semicolonToken: SyntaxToken): Syntax.MethodDeclarationSyntax;
        static ConversionOperatorDeclaration_1627(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: Syntax.TypeSyntax, parameterList: Syntax.ParameterListSyntax, body: Syntax.BlockSyntax, semicolonToken: SyntaxToken): Syntax.ConversionOperatorDeclarationSyntax;
        static OperatorDeclaration_1306(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, returnType: Syntax.TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: Syntax.ParameterListSyntax, body: Syntax.BlockSyntax, semicolonToken: SyntaxToken): Syntax.OperatorDeclarationSyntax;
        static IndexerDeclaration_1610(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, type: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, parameterList: Syntax.BracketedParameterListSyntax, accessorList: Syntax.AccessorListSyntax): Syntax.IndexerDeclarationSyntax;
        static UsingDirective_5519(alias: Syntax.NameEqualsSyntax, name: Syntax.NameSyntax): Syntax.UsingDirectiveSyntax;
        static IdentifierName_9812(identifier: SyntaxToken): Syntax.IdentifierNameSyntax;
        static QualifiedName_1617(left: Syntax.NameSyntax, dotToken: SyntaxToken, right: Syntax.SimpleNameSyntax): Syntax.QualifiedNameSyntax;
        static QualifiedName_1747(left: Syntax.NameSyntax, right: Syntax.SimpleNameSyntax): Syntax.QualifiedNameSyntax;
        static GenericName_1946(identifier: SyntaxToken, typeArgumentList: Syntax.TypeArgumentListSyntax): Syntax.GenericNameSyntax;
        static GenericName_2033(identifier: SyntaxToken): Syntax.GenericNameSyntax;
        static GenericName_1677(identifier: string): Syntax.GenericNameSyntax;
        static TypeArgumentList_2074(lessThanToken: SyntaxToken, arguments1: SeparatedSyntaxList<Syntax.TypeSyntax>, greaterThanToken: SyntaxToken): Syntax.TypeArgumentListSyntax;
        static TypeArgumentList_2107(arguments1?: SeparatedSyntaxList<Syntax.TypeSyntax>): Syntax.TypeArgumentListSyntax;
        static AliasQualifiedName_1366(alias: Syntax.IdentifierNameSyntax, colonColonToken: SyntaxToken, name: Syntax.SimpleNameSyntax): Syntax.AliasQualifiedNameSyntax;
        static AliasQualifiedName_1636(alias: Syntax.IdentifierNameSyntax, name: Syntax.SimpleNameSyntax): Syntax.AliasQualifiedNameSyntax;
        static AliasQualifiedName_1112(alias: string, name: Syntax.SimpleNameSyntax): Syntax.AliasQualifiedNameSyntax;
        static PredefinedType(keyword: SyntaxToken): Syntax.PredefinedTypeSyntax;
        static ArrayType_6581(elementType: Syntax.TypeSyntax, rankSpecifiers: SyntaxList<Syntax.ArrayRankSpecifierSyntax>): Syntax.ArrayTypeSyntax;
        static ArrayType_1264(elementType: Syntax.TypeSyntax): Syntax.ArrayTypeSyntax;
        static ArrayRankSpecifier_6813(openBracketToken: SyntaxToken, sizes: SeparatedSyntaxList<Syntax.ExpressionSyntax>, closeBracketToken: SyntaxToken): Syntax.ArrayRankSpecifierSyntax;
        static ArrayRankSpecifier_4558(sizes?: SeparatedSyntaxList<Syntax.ExpressionSyntax>): Syntax.ArrayRankSpecifierSyntax;
        static PointerType_1337(elementType: Syntax.TypeSyntax, asteriskToken: SyntaxToken): Syntax.PointerTypeSyntax;
        static PointerType_1615(elementType: Syntax.TypeSyntax): Syntax.PointerTypeSyntax;
        static NullableType_5850(elementType: Syntax.TypeSyntax, questionToken: SyntaxToken): Syntax.NullableTypeSyntax;
        static NullableType_1501(elementType: Syntax.TypeSyntax): Syntax.NullableTypeSyntax;
        static OmittedTypeArgument_1624(omittedTypeArgumentToken: SyntaxToken): Syntax.OmittedTypeArgumentSyntax;
        static OmittedTypeArgument_1611(): Syntax.OmittedTypeArgumentSyntax;
        static ParenthesizedExpression_8161(openParenToken: SyntaxToken, expression: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken): Syntax.ParenthesizedExpressionSyntax;
        static ParenthesizedExpression_6144(expression: Syntax.ExpressionSyntax): Syntax.ParenthesizedExpressionSyntax;
        static PrefixUnaryExpression_1586(kind: SyntaxKind, operatorToken: SyntaxToken, operand: Syntax.ExpressionSyntax): Syntax.PrefixUnaryExpressionSyntax;
        static PrefixUnaryExpression_1139(kind: SyntaxKind, operand: Syntax.ExpressionSyntax): Syntax.PrefixUnaryExpressionSyntax;
        private static GetPrefixUnaryExpressionOperatorTokenKind(kind);
        static AwaitExpression_1054(awaitKeyword: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.AwaitExpressionSyntax;
        static AwaitExpression_6013(expression: Syntax.ExpressionSyntax): Syntax.AwaitExpressionSyntax;
        static PostfixUnaryExpression_1042(kind: SyntaxKind, operand: Syntax.ExpressionSyntax, operatorToken: SyntaxToken): Syntax.PostfixUnaryExpressionSyntax;
        static PostfixUnaryExpression_1001(kind: SyntaxKind, operand: Syntax.ExpressionSyntax): Syntax.PostfixUnaryExpressionSyntax;
        private static GetPostfixUnaryExpressionOperatorTokenKind(kind);
        static MemberAccessExpression_6280(kind: SyntaxKind, expression: Syntax.ExpressionSyntax, operatorToken: SyntaxToken, name: Syntax.SimpleNameSyntax): Syntax.MemberAccessExpressionSyntax;
        static MemberAccessExpression_1658(kind: SyntaxKind, expression: Syntax.ExpressionSyntax, name: Syntax.SimpleNameSyntax): Syntax.MemberAccessExpressionSyntax;
        private static GetMemberAccessExpressionOperatorTokenKind(kind);
        static ConditionalAccessExpression_4365(expression: Syntax.ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: Syntax.ExpressionSyntax): Syntax.ConditionalAccessExpressionSyntax;
        static ConditionalAccessExpression_4438(expression: Syntax.ExpressionSyntax, whenNotNull: Syntax.ExpressionSyntax): Syntax.ConditionalAccessExpressionSyntax;
        static MemberBindingExpression_7672(operatorToken: SyntaxToken, name: Syntax.SimpleNameSyntax): Syntax.MemberBindingExpressionSyntax;
        static MemberBindingExpression_1345(name: Syntax.SimpleNameSyntax): Syntax.MemberBindingExpressionSyntax;
        static ElementBindingExpression_1527(argumentList: Syntax.BracketedArgumentListSyntax): Syntax.ElementBindingExpressionSyntax;
        static ElementBindingExpression_2234(): Syntax.ElementBindingExpressionSyntax;
        static ImplicitElementAccess_2050(argumentList: Syntax.BracketedArgumentListSyntax): Syntax.ImplicitElementAccessSyntax;
        static ImplicitElementAccess_8426(): Syntax.ImplicitElementAccessSyntax;
        static BinaryExpression_2078(kind: SyntaxKind, left: Syntax.ExpressionSyntax, operatorToken: SyntaxToken, right: Syntax.ExpressionSyntax): Syntax.BinaryExpressionSyntax;
        static BinaryExpression_1482(kind: SyntaxKind, left: Syntax.ExpressionSyntax, right: Syntax.ExpressionSyntax): Syntax.BinaryExpressionSyntax;
        private static GetBinaryExpressionOperatorTokenKind(kind);
        static AssignmentExpression_3657(kind: SyntaxKind, left: Syntax.ExpressionSyntax, operatorToken: SyntaxToken, right: Syntax.ExpressionSyntax): Syntax.AssignmentExpressionSyntax;
        static AssignmentExpression_7372(kind: SyntaxKind, left: Syntax.ExpressionSyntax, right: Syntax.ExpressionSyntax): Syntax.AssignmentExpressionSyntax;
        private static GetAssignmentExpressionOperatorTokenKind(kind);
        static ConditionalExpression_1159(condition: Syntax.ExpressionSyntax, questionToken: SyntaxToken, whenTrue: Syntax.ExpressionSyntax, colonToken: SyntaxToken, whenFalse: Syntax.ExpressionSyntax): Syntax.ConditionalExpressionSyntax;
        static ConditionalExpression_2720(condition: Syntax.ExpressionSyntax, whenTrue: Syntax.ExpressionSyntax, whenFalse: Syntax.ExpressionSyntax): Syntax.ConditionalExpressionSyntax;
        static ThisExpression_1991(token: SyntaxToken): Syntax.ThisExpressionSyntax;
        static ThisExpression_1169(): Syntax.ThisExpressionSyntax;
        static BaseExpression_1185(token: SyntaxToken): Syntax.BaseExpressionSyntax;
        static BaseExpression_1547(): Syntax.BaseExpressionSyntax;
        static LiteralExpression_7980(kind: SyntaxKind, token: SyntaxToken): Syntax.LiteralExpressionSyntax;
        static LiteralExpression_1324(kind: SyntaxKind): Syntax.LiteralExpressionSyntax;
        private static GetLiteralExpressionTokenKind(kind);
        static MakeRefExpression_1856(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken): Syntax.MakeRefExpressionSyntax;
        static MakeRefExpression_8838(expression: Syntax.ExpressionSyntax): Syntax.MakeRefExpressionSyntax;
        static RefTypeExpression_2003(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken): Syntax.RefTypeExpressionSyntax;
        static RefTypeExpression_1288(expression: Syntax.ExpressionSyntax): Syntax.RefTypeExpressionSyntax;
        static RefValueExpression_1254(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: Syntax.ExpressionSyntax, comma: SyntaxToken, type: Syntax.TypeSyntax, closeParenToken: SyntaxToken): Syntax.RefValueExpressionSyntax;
        static RefValueExpression_1290(expression: Syntax.ExpressionSyntax, type: Syntax.TypeSyntax): Syntax.RefValueExpressionSyntax;
        static CheckedExpression_1461(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken): Syntax.CheckedExpressionSyntax;
        static CheckedExpression_1385(kind: SyntaxKind, expression: Syntax.ExpressionSyntax): Syntax.CheckedExpressionSyntax;
        private static GetCheckedExpressionKeywordKind(kind);
        static DefaultExpression_9224(keyword: SyntaxToken, openParenToken: SyntaxToken, type: Syntax.TypeSyntax, closeParenToken: SyntaxToken): Syntax.DefaultExpressionSyntax;
        static DefaultExpression_1872(type: Syntax.TypeSyntax): Syntax.DefaultExpressionSyntax;
        static TypeOfExpression_1008(keyword: SyntaxToken, openParenToken: SyntaxToken, type: Syntax.TypeSyntax, closeParenToken: SyntaxToken): Syntax.TypeOfExpressionSyntax;
        static TypeOfExpression_1591(type: Syntax.TypeSyntax): Syntax.TypeOfExpressionSyntax;
        static SizeOfExpression_1890(keyword: SyntaxToken, openParenToken: SyntaxToken, type: Syntax.TypeSyntax, closeParenToken: SyntaxToken): Syntax.SizeOfExpressionSyntax;
        static SizeOfExpression_1293(type: Syntax.TypeSyntax): Syntax.SizeOfExpressionSyntax;
        static InvocationExpression_9198(expression: Syntax.ExpressionSyntax, argumentList: Syntax.ArgumentListSyntax): Syntax.InvocationExpressionSyntax;
        static InvocationExpression_2460(expression: Syntax.ExpressionSyntax): Syntax.InvocationExpressionSyntax;
        static ElementAccessExpression_1162(expression: Syntax.ExpressionSyntax, argumentList: Syntax.BracketedArgumentListSyntax): Syntax.ElementAccessExpressionSyntax;
        static ElementAccessExpression_1533(expression: Syntax.ExpressionSyntax): Syntax.ElementAccessExpressionSyntax;
        static ArgumentList_1043(openParenToken: SyntaxToken, arguments1: SeparatedSyntaxList<Syntax.ArgumentSyntax>, closeParenToken: SyntaxToken): Syntax.ArgumentListSyntax;
        static ArgumentList_1288(arguments1?: SeparatedSyntaxList<Syntax.ArgumentSyntax>): Syntax.ArgumentListSyntax;
        static BracketedArgumentList_1168(openBracketToken: SyntaxToken, arguments1: SeparatedSyntaxList<Syntax.ArgumentSyntax>, closeBracketToken: SyntaxToken): Syntax.BracketedArgumentListSyntax;
        static BracketedArgumentList_8387(arguments1?: SeparatedSyntaxList<Syntax.ArgumentSyntax>): Syntax.BracketedArgumentListSyntax;
        static Argument_2910(nameColon: Syntax.NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.ArgumentSyntax;
        static Argument_9144(expression: Syntax.ExpressionSyntax): Syntax.ArgumentSyntax;
        static NameColon_9012(name: Syntax.IdentifierNameSyntax, colonToken: SyntaxToken): Syntax.NameColonSyntax;
        static NameColon_1614(name: Syntax.IdentifierNameSyntax): Syntax.NameColonSyntax;
        static NameColon_1885(name: string): Syntax.NameColonSyntax;
        static CastExpression_9709(openParenToken: SyntaxToken, type: Syntax.TypeSyntax, closeParenToken: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.CastExpressionSyntax;
        static CastExpression_9612(type: Syntax.TypeSyntax, expression: Syntax.ExpressionSyntax): Syntax.CastExpressionSyntax;
        static AnonymousMethodExpression_1352(asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: Syntax.ParameterListSyntax, block: Syntax.BlockSyntax): Syntax.AnonymousMethodExpressionSyntax;
        static AnonymousMethodExpression_4724(parameterList: Syntax.ParameterListSyntax, block: Syntax.BlockSyntax): Syntax.AnonymousMethodExpressionSyntax;
        static AnonymousMethodExpression_1559(): Syntax.AnonymousMethodExpressionSyntax;
        static SimpleLambdaExpression_6633(asyncKeyword: SyntaxToken, parameter: Syntax.ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): Syntax.SimpleLambdaExpressionSyntax;
        static SimpleLambdaExpression_6017(parameter: Syntax.ParameterSyntax, body: CSharpSyntaxNode): Syntax.SimpleLambdaExpressionSyntax;
        static ParenthesizedLambdaExpression_1721(asyncKeyword: SyntaxToken, parameterList: Syntax.ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): Syntax.ParenthesizedLambdaExpressionSyntax;
        static ParenthesizedLambdaExpression_3875(parameterList: Syntax.ParameterListSyntax, body: CSharpSyntaxNode): Syntax.ParenthesizedLambdaExpressionSyntax;
        static ParenthesizedLambdaExpression_1258(body: CSharpSyntaxNode): Syntax.ParenthesizedLambdaExpressionSyntax;
        static InitializerExpression_1979(kind: SyntaxKind, openBraceToken: SyntaxToken, expressions: SeparatedSyntaxList<Syntax.ExpressionSyntax>, closeBraceToken: SyntaxToken): Syntax.InitializerExpressionSyntax;
        static InitializerExpression_1714(kind: SyntaxKind, expressions?: SeparatedSyntaxList<Syntax.ExpressionSyntax>): Syntax.InitializerExpressionSyntax;
        static ObjectCreationExpression_7070(newKeyword: SyntaxToken, type: Syntax.TypeSyntax, argumentList: Syntax.ArgumentListSyntax, initializer: Syntax.InitializerExpressionSyntax): Syntax.ObjectCreationExpressionSyntax;
        static ObjectCreationExpression_1020(type: Syntax.TypeSyntax, argumentList: Syntax.ArgumentListSyntax, initializer: Syntax.InitializerExpressionSyntax): Syntax.ObjectCreationExpressionSyntax;
        static ObjectCreationExpression_1793(type: Syntax.TypeSyntax): Syntax.ObjectCreationExpressionSyntax;
        static AnonymousObjectMemberDeclarator_1075(nameEquals: Syntax.NameEqualsSyntax, expression: Syntax.ExpressionSyntax): Syntax.AnonymousObjectMemberDeclaratorSyntax;
        static AnonymousObjectMemberDeclarator_2144(expression: Syntax.ExpressionSyntax): Syntax.AnonymousObjectMemberDeclaratorSyntax;
        static AnonymousObjectCreationExpression_6133(newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: SeparatedSyntaxList<Syntax.AnonymousObjectMemberDeclaratorSyntax>, closeBraceToken: SyntaxToken): Syntax.AnonymousObjectCreationExpressionSyntax;
        static AnonymousObjectCreationExpression_1737(initializers?: SeparatedSyntaxList<Syntax.AnonymousObjectMemberDeclaratorSyntax>): Syntax.AnonymousObjectCreationExpressionSyntax;
        static ArrayCreationExpression_1446(newKeyword: SyntaxToken, type: Syntax.ArrayTypeSyntax, initializer: Syntax.InitializerExpressionSyntax): Syntax.ArrayCreationExpressionSyntax;
        static ArrayCreationExpression_3747(type: Syntax.ArrayTypeSyntax, initializer: Syntax.InitializerExpressionSyntax): Syntax.ArrayCreationExpressionSyntax;
        static ArrayCreationExpression_2101(type: Syntax.ArrayTypeSyntax): Syntax.ArrayCreationExpressionSyntax;
        static ImplicitArrayCreationExpression_2138(newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: SyntaxTokenList, closeBracketToken: SyntaxToken, initializer: Syntax.InitializerExpressionSyntax): Syntax.ImplicitArrayCreationExpressionSyntax;
        static ImplicitArrayCreationExpression_1037(commas: SyntaxTokenList, initializer: Syntax.InitializerExpressionSyntax): Syntax.ImplicitArrayCreationExpressionSyntax;
        static ImplicitArrayCreationExpression_1372(initializer: Syntax.InitializerExpressionSyntax): Syntax.ImplicitArrayCreationExpressionSyntax;
        static StackAllocArrayCreationExpression_1830(stackAllocKeyword: SyntaxToken, type: Syntax.TypeSyntax): Syntax.StackAllocArrayCreationExpressionSyntax;
        static StackAllocArrayCreationExpression_1025(type: Syntax.TypeSyntax): Syntax.StackAllocArrayCreationExpressionSyntax;
        static QueryExpression(fromClause: Syntax.FromClauseSyntax, body: Syntax.QueryBodySyntax): Syntax.QueryExpressionSyntax;
        static QueryBody_1176(clauses: SyntaxList<Syntax.QueryClauseSyntax>, selectOrGroup: Syntax.SelectOrGroupClauseSyntax, continuation: Syntax.QueryContinuationSyntax): Syntax.QueryBodySyntax;
        static QueryBody_1883(selectOrGroup: Syntax.SelectOrGroupClauseSyntax): Syntax.QueryBodySyntax;
        static FromClause_4646(fromKeyword: SyntaxToken, type: Syntax.TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.FromClauseSyntax;
        static FromClause_1546(type: Syntax.TypeSyntax, identifier: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.FromClauseSyntax;
        static FromClause_5300(identifier: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.FromClauseSyntax;
        static FromClause_6642(identifier: string, expression: Syntax.ExpressionSyntax): Syntax.FromClauseSyntax;
        static LetClause_9775(letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.LetClauseSyntax;
        static LetClause_6611(identifier: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.LetClauseSyntax;
        static LetClause_2005(identifier: string, expression: Syntax.ExpressionSyntax): Syntax.LetClauseSyntax;
        static JoinClause_1396(joinKeyword: SyntaxToken, type: Syntax.TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: Syntax.ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: Syntax.ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: Syntax.ExpressionSyntax, into: Syntax.JoinIntoClauseSyntax): Syntax.JoinClauseSyntax;
        static JoinClause_5271(type: Syntax.TypeSyntax, identifier: SyntaxToken, inExpression: Syntax.ExpressionSyntax, leftExpression: Syntax.ExpressionSyntax, rightExpression: Syntax.ExpressionSyntax, into: Syntax.JoinIntoClauseSyntax): Syntax.JoinClauseSyntax;
        static JoinClause_2668(identifier: SyntaxToken, inExpression: Syntax.ExpressionSyntax, leftExpression: Syntax.ExpressionSyntax, rightExpression: Syntax.ExpressionSyntax): Syntax.JoinClauseSyntax;
        static JoinClause_1767(identifier: string, inExpression: Syntax.ExpressionSyntax, leftExpression: Syntax.ExpressionSyntax, rightExpression: Syntax.ExpressionSyntax): Syntax.JoinClauseSyntax;
        static JoinIntoClause_2046(intoKeyword: SyntaxToken, identifier: SyntaxToken): Syntax.JoinIntoClauseSyntax;
        static JoinIntoClause_1593(identifier: SyntaxToken): Syntax.JoinIntoClauseSyntax;
        static JoinIntoClause_4774(identifier: string): Syntax.JoinIntoClauseSyntax;
        static WhereClause_3161(whereKeyword: SyntaxToken, condition: Syntax.ExpressionSyntax): Syntax.WhereClauseSyntax;
        static WhereClause_8812(condition: Syntax.ExpressionSyntax): Syntax.WhereClauseSyntax;
        static OrderByClause_4578(orderByKeyword: SyntaxToken, orderings: SeparatedSyntaxList<Syntax.OrderingSyntax>): Syntax.OrderByClauseSyntax;
        static OrderByClause_1098(orderings?: SeparatedSyntaxList<Syntax.OrderingSyntax>): Syntax.OrderByClauseSyntax;
        static Ordering_1799(kind: SyntaxKind, expression: Syntax.ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken): Syntax.OrderingSyntax;
        static Ordering_1914(kind: SyntaxKind, expression: Syntax.ExpressionSyntax): Syntax.OrderingSyntax;
        private static GetOrderingAscendingOrDescendingKeywordKind(kind);
        static SelectClause_1144(selectKeyword: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.SelectClauseSyntax;
        static SelectClause_1370(expression: Syntax.ExpressionSyntax): Syntax.SelectClauseSyntax;
        static GroupClause_1229(groupKeyword: SyntaxToken, groupExpression: Syntax.ExpressionSyntax, byKeyword: SyntaxToken, byExpression: Syntax.ExpressionSyntax): Syntax.GroupClauseSyntax;
        static GroupClause_1761(groupExpression: Syntax.ExpressionSyntax, byExpression: Syntax.ExpressionSyntax): Syntax.GroupClauseSyntax;
        static QueryContinuation_1244(intoKeyword: SyntaxToken, identifier: SyntaxToken, body: Syntax.QueryBodySyntax): Syntax.QueryContinuationSyntax;
        static QueryContinuation_2329(identifier: SyntaxToken, body: Syntax.QueryBodySyntax): Syntax.QueryContinuationSyntax;
        static QueryContinuation_1649(identifier: string, body: Syntax.QueryBodySyntax): Syntax.QueryContinuationSyntax;
        static OmittedArraySizeExpression_2029(omittedArraySizeExpressionToken: SyntaxToken): Syntax.OmittedArraySizeExpressionSyntax;
        static OmittedArraySizeExpression_2083(): Syntax.OmittedArraySizeExpressionSyntax;
        static GlobalStatement(statement: Syntax.StatementSyntax): Syntax.GlobalStatementSyntax;
        static Block_1784(openBraceToken: SyntaxToken, statements: SyntaxList<Syntax.StatementSyntax>, closeBraceToken: SyntaxToken): Syntax.BlockSyntax;
        static Block_1037(statements?: SyntaxList<Syntax.StatementSyntax>): Syntax.BlockSyntax;
        static LocalDeclarationStatement_8668(modifiers: SyntaxTokenList, declaration: Syntax.VariableDeclarationSyntax, semicolonToken: SyntaxToken): Syntax.LocalDeclarationStatementSyntax;
        static LocalDeclarationStatement_1324(modifiers: SyntaxTokenList, declaration: Syntax.VariableDeclarationSyntax): Syntax.LocalDeclarationStatementSyntax;
        static LocalDeclarationStatement_1522(declaration: Syntax.VariableDeclarationSyntax): Syntax.LocalDeclarationStatementSyntax;
        static VariableDeclaration_1163(type: Syntax.TypeSyntax, variables: SeparatedSyntaxList<Syntax.VariableDeclaratorSyntax>): Syntax.VariableDeclarationSyntax;
        static VariableDeclaration_1609(type: Syntax.TypeSyntax): Syntax.VariableDeclarationSyntax;
        static VariableDeclarator_2274(identifier: SyntaxToken, argumentList: Syntax.BracketedArgumentListSyntax, initializer: Syntax.EqualsValueClauseSyntax): Syntax.VariableDeclaratorSyntax;
        static VariableDeclarator_1143(identifier: SyntaxToken): Syntax.VariableDeclaratorSyntax;
        static VariableDeclarator_1159(identifier: string): Syntax.VariableDeclaratorSyntax;
        static EqualsValueClause_1763(equalsToken: SyntaxToken, value: Syntax.ExpressionSyntax): Syntax.EqualsValueClauseSyntax;
        static EqualsValueClause_1477(value: Syntax.ExpressionSyntax): Syntax.EqualsValueClauseSyntax;
        static ExpressionStatement_1248(expression: Syntax.ExpressionSyntax, semicolonToken: SyntaxToken): Syntax.ExpressionStatementSyntax;
        static ExpressionStatement_8641(expression: Syntax.ExpressionSyntax): Syntax.ExpressionStatementSyntax;
        static EmptyStatement_5677(semicolonToken: SyntaxToken): Syntax.EmptyStatementSyntax;
        static EmptyStatement_1657(): Syntax.EmptyStatementSyntax;
        static LabeledStatement_3705(identifier: SyntaxToken, colonToken: SyntaxToken, statement: Syntax.StatementSyntax): Syntax.LabeledStatementSyntax;
        static LabeledStatement_3323(identifier: SyntaxToken, statement: Syntax.StatementSyntax): Syntax.LabeledStatementSyntax;
        static LabeledStatement_3219(identifier: string, statement: Syntax.StatementSyntax): Syntax.LabeledStatementSyntax;
        static GotoStatement_6985(kind: SyntaxKind, gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: Syntax.ExpressionSyntax, semicolonToken: SyntaxToken): Syntax.GotoStatementSyntax;
        static GotoStatement_9517(kind: SyntaxKind, caseOrDefaultKeyword: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.GotoStatementSyntax;
        static GotoStatement_3705(kind: SyntaxKind, expression?: Syntax.ExpressionSyntax): Syntax.GotoStatementSyntax;
        static BreakStatement_1042(breakKeyword: SyntaxToken, semicolonToken: SyntaxToken): Syntax.BreakStatementSyntax;
        static BreakStatement_5136(): Syntax.BreakStatementSyntax;
        static ContinueStatement_6527(continueKeyword: SyntaxToken, semicolonToken: SyntaxToken): Syntax.ContinueStatementSyntax;
        static ContinueStatement_5243(): Syntax.ContinueStatementSyntax;
        static ReturnStatement_3904(returnKeyword: SyntaxToken, expression: Syntax.ExpressionSyntax, semicolonToken: SyntaxToken): Syntax.ReturnStatementSyntax;
        static ReturnStatement_4392(expression?: Syntax.ExpressionSyntax): Syntax.ReturnStatementSyntax;
        static ThrowStatement_1358(throwKeyword: SyntaxToken, expression: Syntax.ExpressionSyntax, semicolonToken: SyntaxToken): Syntax.ThrowStatementSyntax;
        static ThrowStatement_7504(expression?: Syntax.ExpressionSyntax): Syntax.ThrowStatementSyntax;
        static YieldStatement_1588(kind: SyntaxKind, yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: Syntax.ExpressionSyntax, semicolonToken: SyntaxToken): Syntax.YieldStatementSyntax;
        static YieldStatement_1867(kind: SyntaxKind, expression?: Syntax.ExpressionSyntax): Syntax.YieldStatementSyntax;
        private static GetYieldStatementReturnOrBreakKeywordKind(kind);
        static WhileStatement_2457(whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken, statement: Syntax.StatementSyntax): Syntax.WhileStatementSyntax;
        static WhileStatement_1771(condition: Syntax.ExpressionSyntax, statement: Syntax.StatementSyntax): Syntax.WhileStatementSyntax;
        static DoStatement_1208(doKeyword: SyntaxToken, statement: Syntax.StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken): Syntax.DoStatementSyntax;
        static DoStatement_1554(statement: Syntax.StatementSyntax, condition: Syntax.ExpressionSyntax): Syntax.DoStatementSyntax;
        static ForStatement_5480(forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: Syntax.VariableDeclarationSyntax, initializers: SeparatedSyntaxList<Syntax.ExpressionSyntax>, firstSemicolonToken: SyntaxToken, condition: Syntax.ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: SeparatedSyntaxList<Syntax.ExpressionSyntax>, closeParenToken: SyntaxToken, statement: Syntax.StatementSyntax): Syntax.ForStatementSyntax;
        static ForStatement_8259(declaration: Syntax.VariableDeclarationSyntax, initializers: SeparatedSyntaxList<Syntax.ExpressionSyntax>, condition: Syntax.ExpressionSyntax, incrementors: SeparatedSyntaxList<Syntax.ExpressionSyntax>, statement: Syntax.StatementSyntax): Syntax.ForStatementSyntax;
        static ForStatement_5894(statement: Syntax.StatementSyntax): Syntax.ForStatementSyntax;
        static ForEachStatement_1184(forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: Syntax.TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken, statement: Syntax.StatementSyntax): Syntax.ForEachStatementSyntax;
        static ForEachStatement_1713(type: Syntax.TypeSyntax, identifier: SyntaxToken, expression: Syntax.ExpressionSyntax, statement: Syntax.StatementSyntax): Syntax.ForEachStatementSyntax;
        static ForEachStatement_8464(type: Syntax.TypeSyntax, identifier: string, expression: Syntax.ExpressionSyntax, statement: Syntax.StatementSyntax): Syntax.ForEachStatementSyntax;
        static UsingStatement_2034(usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: Syntax.VariableDeclarationSyntax, expression: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken, statement: Syntax.StatementSyntax): Syntax.UsingStatementSyntax;
        static UsingStatement_1210(declaration: Syntax.VariableDeclarationSyntax, expression: Syntax.ExpressionSyntax, statement: Syntax.StatementSyntax): Syntax.UsingStatementSyntax;
        static UsingStatement_5720(statement: Syntax.StatementSyntax): Syntax.UsingStatementSyntax;
        static FixedStatement_1548(fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: Syntax.VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: Syntax.StatementSyntax): Syntax.FixedStatementSyntax;
        static FixedStatement_1896(declaration: Syntax.VariableDeclarationSyntax, statement: Syntax.StatementSyntax): Syntax.FixedStatementSyntax;
        static CheckedStatement_1663(kind: SyntaxKind, keyword: SyntaxToken, block: Syntax.BlockSyntax): Syntax.CheckedStatementSyntax;
        static CheckedStatement_7841(kind: SyntaxKind, block?: Syntax.BlockSyntax): Syntax.CheckedStatementSyntax;
        private static GetCheckedStatementKeywordKind(kind);
        static UnsafeStatement_7221(unsafeKeyword: SyntaxToken, block: Syntax.BlockSyntax): Syntax.UnsafeStatementSyntax;
        static UnsafeStatement_6353(block?: Syntax.BlockSyntax): Syntax.UnsafeStatementSyntax;
        static LockStatement_6696(lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken, statement: Syntax.StatementSyntax): Syntax.LockStatementSyntax;
        static LockStatement_1770(expression: Syntax.ExpressionSyntax, statement: Syntax.StatementSyntax): Syntax.LockStatementSyntax;
        static IfStatement_1417(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken, statement: Syntax.StatementSyntax, $else: Syntax.ElseClauseSyntax): Syntax.IfStatementSyntax;
        static IfStatement_6173(condition: Syntax.ExpressionSyntax, statement: Syntax.StatementSyntax, $else: Syntax.ElseClauseSyntax): Syntax.IfStatementSyntax;
        static IfStatement_1494(condition: Syntax.ExpressionSyntax, statement: Syntax.StatementSyntax): Syntax.IfStatementSyntax;
        static ElseClause_1077(elseKeyword: SyntaxToken, statement: Syntax.StatementSyntax): Syntax.ElseClauseSyntax;
        static ElseClause_1549(statement: Syntax.StatementSyntax): Syntax.ElseClauseSyntax;
        static SwitchStatement_1235(switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: SyntaxList<Syntax.SwitchSectionSyntax>, closeBraceToken: SyntaxToken): Syntax.SwitchStatementSyntax;
        static SwitchStatement_1938(expression: Syntax.ExpressionSyntax, sections: SyntaxList<Syntax.SwitchSectionSyntax>): Syntax.SwitchStatementSyntax;
        static SwitchStatement_1441(expression: Syntax.ExpressionSyntax): Syntax.SwitchStatementSyntax;
        static SwitchSection_1633(labels: SyntaxList<Syntax.SwitchLabelSyntax>, statements: SyntaxList<Syntax.StatementSyntax>): Syntax.SwitchSectionSyntax;
        static SwitchSection_6989(): Syntax.SwitchSectionSyntax;
        static CaseSwitchLabel_2116(keyword: SyntaxToken, value: Syntax.ExpressionSyntax, colonToken: SyntaxToken): Syntax.CaseSwitchLabelSyntax;
        static CaseSwitchLabel_1853(value: Syntax.ExpressionSyntax, colonToken: SyntaxToken): Syntax.CaseSwitchLabelSyntax;
        static DefaultSwitchLabel_2103(keyword: SyntaxToken, colonToken: SyntaxToken): Syntax.DefaultSwitchLabelSyntax;
        static DefaultSwitchLabel_1779(colonToken: SyntaxToken): Syntax.DefaultSwitchLabelSyntax;
        static TryStatement_3588(tryKeyword: SyntaxToken, block: Syntax.BlockSyntax, catches: SyntaxList<Syntax.CatchClauseSyntax>, $finally: Syntax.FinallyClauseSyntax): Syntax.TryStatementSyntax;
        static TryStatement_9994(block: Syntax.BlockSyntax, catches: SyntaxList<Syntax.CatchClauseSyntax>, $finally: Syntax.FinallyClauseSyntax): Syntax.TryStatementSyntax;
        static TryStatement_4268(catches?: SyntaxList<Syntax.CatchClauseSyntax>): Syntax.TryStatementSyntax;
        static CatchClause_1606(catchKeyword: SyntaxToken, declaration: Syntax.CatchDeclarationSyntax, filter: Syntax.CatchFilterClauseSyntax, block: Syntax.BlockSyntax): Syntax.CatchClauseSyntax;
        static CatchClause_1141(declaration: Syntax.CatchDeclarationSyntax, filter: Syntax.CatchFilterClauseSyntax, block: Syntax.BlockSyntax): Syntax.CatchClauseSyntax;
        static CatchClause_4605(): Syntax.CatchClauseSyntax;
        static CatchDeclaration_1702(openParenToken: SyntaxToken, type: Syntax.TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken): Syntax.CatchDeclarationSyntax;
        static CatchDeclaration_1903(type: Syntax.TypeSyntax, identifier: SyntaxToken): Syntax.CatchDeclarationSyntax;
        static CatchDeclaration_1762(type: Syntax.TypeSyntax): Syntax.CatchDeclarationSyntax;
        static CatchFilterClause_8524(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: Syntax.ExpressionSyntax, closeParenToken: SyntaxToken): Syntax.CatchFilterClauseSyntax;
        static CatchFilterClause_9905(filterExpression: Syntax.ExpressionSyntax): Syntax.CatchFilterClauseSyntax;
        static FinallyClause_2308(finallyKeyword: SyntaxToken, block: Syntax.BlockSyntax): Syntax.FinallyClauseSyntax;
        static FinallyClause_1828(block?: Syntax.BlockSyntax): Syntax.FinallyClauseSyntax;
        static CompilationUnit_1797(externs: SyntaxList<Syntax.ExternAliasDirectiveSyntax>, usings: SyntaxList<Syntax.UsingDirectiveSyntax>, attributeLists: SyntaxList<Syntax.AttributeListSyntax>, members: SyntaxList<Syntax.MemberDeclarationSyntax>, endOfFileToken: SyntaxToken): Syntax.CompilationUnitSyntax;
        static CompilationUnit_7893(externs: SyntaxList<Syntax.ExternAliasDirectiveSyntax>, usings: SyntaxList<Syntax.UsingDirectiveSyntax>, attributeLists: SyntaxList<Syntax.AttributeListSyntax>, members: SyntaxList<Syntax.MemberDeclarationSyntax>): Syntax.CompilationUnitSyntax;
        static CompilationUnit_1729(): Syntax.CompilationUnitSyntax;
        static ExternAliasDirective_3055(externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken): Syntax.ExternAliasDirectiveSyntax;
        static ExternAliasDirective_1172(identifier: SyntaxToken): Syntax.ExternAliasDirectiveSyntax;
        static ExternAliasDirective_1943(identifier: string): Syntax.ExternAliasDirectiveSyntax;
        static UsingDirective_9846(usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: Syntax.NameEqualsSyntax, name: Syntax.NameSyntax, semicolonToken: SyntaxToken): Syntax.UsingDirectiveSyntax;
        static UsingDirective_6482(staticKeyword: SyntaxToken, alias: Syntax.NameEqualsSyntax, name: Syntax.NameSyntax): Syntax.UsingDirectiveSyntax;
        static UsingDirective_1590(name: Syntax.NameSyntax): Syntax.UsingDirectiveSyntax;
        static NamespaceDeclaration_1400(namespaceKeyword: SyntaxToken, name: Syntax.NameSyntax, openBraceToken: SyntaxToken, externs: SyntaxList<Syntax.ExternAliasDirectiveSyntax>, usings: SyntaxList<Syntax.UsingDirectiveSyntax>, members: SyntaxList<Syntax.MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): Syntax.NamespaceDeclarationSyntax;
        static NamespaceDeclaration_2111(name: Syntax.NameSyntax, externs: SyntaxList<Syntax.ExternAliasDirectiveSyntax>, usings: SyntaxList<Syntax.UsingDirectiveSyntax>, members: SyntaxList<Syntax.MemberDeclarationSyntax>): Syntax.NamespaceDeclarationSyntax;
        static NamespaceDeclaration_1529(name: Syntax.NameSyntax): Syntax.NamespaceDeclarationSyntax;
        static AttributeList_1768(openBracketToken: SyntaxToken, target: Syntax.AttributeTargetSpecifierSyntax, attributes: SeparatedSyntaxList<Syntax.AttributeSyntax>, closeBracketToken: SyntaxToken): Syntax.AttributeListSyntax;
        static AttributeList_1877(target: Syntax.AttributeTargetSpecifierSyntax, attributes: SeparatedSyntaxList<Syntax.AttributeSyntax>): Syntax.AttributeListSyntax;
        static AttributeList_1370(attributes?: SeparatedSyntaxList<Syntax.AttributeSyntax>): Syntax.AttributeListSyntax;
        static AttributeTargetSpecifier_1734(identifier: SyntaxToken, colonToken: SyntaxToken): Syntax.AttributeTargetSpecifierSyntax;
        static AttributeTargetSpecifier_1352(identifier: SyntaxToken): Syntax.AttributeTargetSpecifierSyntax;
        static Attribute_1729(name: Syntax.NameSyntax, argumentList: Syntax.AttributeArgumentListSyntax): Syntax.AttributeSyntax;
        static Attribute_1080(name: Syntax.NameSyntax): Syntax.AttributeSyntax;
        static AttributeArgumentList_9314(openParenToken: SyntaxToken, arguments1: SeparatedSyntaxList<Syntax.AttributeArgumentSyntax>, closeParenToken: SyntaxToken): Syntax.AttributeArgumentListSyntax;
        static AttributeArgumentList_9344(arguments1?: SeparatedSyntaxList<Syntax.AttributeArgumentSyntax>): Syntax.AttributeArgumentListSyntax;
        static AttributeArgument_7913(nameEquals: Syntax.NameEqualsSyntax, nameColon: Syntax.NameColonSyntax, expression: Syntax.ExpressionSyntax): Syntax.AttributeArgumentSyntax;
        static AttributeArgument_1158(expression: Syntax.ExpressionSyntax): Syntax.AttributeArgumentSyntax;
        static NameEquals_2119(name: Syntax.IdentifierNameSyntax, equalsToken: SyntaxToken): Syntax.NameEqualsSyntax;
        static NameEquals_1424(name: Syntax.IdentifierNameSyntax): Syntax.NameEqualsSyntax;
        static NameEquals_1288(name: string): Syntax.NameEqualsSyntax;
        static TypeParameterList_1787(lessThanToken: SyntaxToken, parameters: SeparatedSyntaxList<Syntax.TypeParameterSyntax>, greaterThanToken: SyntaxToken): Syntax.TypeParameterListSyntax;
        static TypeParameterList_1178(parameters?: SeparatedSyntaxList<Syntax.TypeParameterSyntax>): Syntax.TypeParameterListSyntax;
        static TypeParameter_6906(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, varianceKeyword: SyntaxToken, identifier: SyntaxToken): Syntax.TypeParameterSyntax;
        static TypeParameter_2019(identifier: SyntaxToken): Syntax.TypeParameterSyntax;
        static TypeParameter_7108(identifier: string): Syntax.TypeParameterSyntax;
        static ClassDeclaration_6025(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, baseList: Syntax.BaseListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<Syntax.MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): Syntax.ClassDeclarationSyntax;
        static ClassDeclaration_1337(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, baseList: Syntax.BaseListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>, members: SyntaxList<Syntax.MemberDeclarationSyntax>): Syntax.ClassDeclarationSyntax;
        static ClassDeclaration_1457(identifier: SyntaxToken): Syntax.ClassDeclarationSyntax;
        static ClassDeclaration_1390(identifier: string): Syntax.ClassDeclarationSyntax;
        static StructDeclaration_3822(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, baseList: Syntax.BaseListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<Syntax.MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): Syntax.StructDeclarationSyntax;
        static StructDeclaration_8348(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, baseList: Syntax.BaseListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>, members: SyntaxList<Syntax.MemberDeclarationSyntax>): Syntax.StructDeclarationSyntax;
        static StructDeclaration_1761(identifier: SyntaxToken): Syntax.StructDeclarationSyntax;
        static StructDeclaration_2134(identifier: string): Syntax.StructDeclarationSyntax;
        static InterfaceDeclaration_1831(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, baseList: Syntax.BaseListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<Syntax.MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): Syntax.InterfaceDeclarationSyntax;
        static InterfaceDeclaration_8639(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, baseList: Syntax.BaseListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>, members: SyntaxList<Syntax.MemberDeclarationSyntax>): Syntax.InterfaceDeclarationSyntax;
        static InterfaceDeclaration_1732(identifier: SyntaxToken): Syntax.InterfaceDeclarationSyntax;
        static InterfaceDeclaration_1152(identifier: string): Syntax.InterfaceDeclarationSyntax;
        static EnumDeclaration_1802(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: Syntax.BaseListSyntax, openBraceToken: SyntaxToken, members: SeparatedSyntaxList<Syntax.EnumMemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): Syntax.EnumDeclarationSyntax;
        static EnumDeclaration_1679(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, identifier: SyntaxToken, baseList: Syntax.BaseListSyntax, members: SeparatedSyntaxList<Syntax.EnumMemberDeclarationSyntax>): Syntax.EnumDeclarationSyntax;
        static EnumDeclaration_1087(identifier: SyntaxToken): Syntax.EnumDeclarationSyntax;
        static EnumDeclaration_1864(identifier: string): Syntax.EnumDeclarationSyntax;
        static DelegateDeclaration_5980(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, delegateKeyword: SyntaxToken, returnType: Syntax.TypeSyntax, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, parameterList: Syntax.ParameterListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>, semicolonToken: SyntaxToken): Syntax.DelegateDeclarationSyntax;
        static DelegateDeclaration_5759(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, returnType: Syntax.TypeSyntax, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, parameterList: Syntax.ParameterListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>): Syntax.DelegateDeclarationSyntax;
        static DelegateDeclaration_1458(returnType: Syntax.TypeSyntax, identifier: SyntaxToken): Syntax.DelegateDeclarationSyntax;
        static DelegateDeclaration_9226(returnType: Syntax.TypeSyntax, identifier: string): Syntax.DelegateDeclarationSyntax;
        static EnumMemberDeclaration_5981(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, identifier: SyntaxToken, equalsValue: Syntax.EqualsValueClauseSyntax): Syntax.EnumMemberDeclarationSyntax;
        static EnumMemberDeclaration_5599(identifier: SyntaxToken): Syntax.EnumMemberDeclarationSyntax;
        static EnumMemberDeclaration_1956(identifier: string): Syntax.EnumMemberDeclarationSyntax;
        static BaseList_3029(colonToken: SyntaxToken, types: SeparatedSyntaxList<Syntax.BaseTypeSyntax>): Syntax.BaseListSyntax;
        static BaseList_1793(types?: SeparatedSyntaxList<Syntax.BaseTypeSyntax>): Syntax.BaseListSyntax;
        static SimpleBaseType(type: Syntax.TypeSyntax): Syntax.SimpleBaseTypeSyntax;
        static TypeParameterConstraintClause_1764(whereKeyword: SyntaxToken, name: Syntax.IdentifierNameSyntax, colonToken: SyntaxToken, constraints: SeparatedSyntaxList<Syntax.TypeParameterConstraintSyntax>): Syntax.TypeParameterConstraintClauseSyntax;
        static TypeParameterConstraintClause_8765(name: Syntax.IdentifierNameSyntax, constraints: SeparatedSyntaxList<Syntax.TypeParameterConstraintSyntax>): Syntax.TypeParameterConstraintClauseSyntax;
        static TypeParameterConstraintClause_1524(name: Syntax.IdentifierNameSyntax): Syntax.TypeParameterConstraintClauseSyntax;
        static TypeParameterConstraintClause_2012(name: string): Syntax.TypeParameterConstraintClauseSyntax;
        static ConstructorConstraint_1519(newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken): Syntax.ConstructorConstraintSyntax;
        static ConstructorConstraint_6302(): Syntax.ConstructorConstraintSyntax;
        static ClassOrStructConstraint_1543(kind: SyntaxKind, classOrStructKeyword: SyntaxToken): Syntax.ClassOrStructConstraintSyntax;
        static ClassOrStructConstraint_2074(kind: SyntaxKind): Syntax.ClassOrStructConstraintSyntax;
        private static GetClassOrStructConstraintClassOrStructKeywordKind(kind);
        static TypeConstraint(type: Syntax.TypeSyntax): Syntax.TypeConstraintSyntax;
        static FieldDeclaration_8233(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, declaration: Syntax.VariableDeclarationSyntax, semicolonToken: SyntaxToken): Syntax.FieldDeclarationSyntax;
        static FieldDeclaration_2138(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, declaration: Syntax.VariableDeclarationSyntax): Syntax.FieldDeclarationSyntax;
        static FieldDeclaration_9428(declaration: Syntax.VariableDeclarationSyntax): Syntax.FieldDeclarationSyntax;
        static EventFieldDeclaration_8505(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, eventKeyword: SyntaxToken, declaration: Syntax.VariableDeclarationSyntax, semicolonToken: SyntaxToken): Syntax.EventFieldDeclarationSyntax;
        static EventFieldDeclaration_1917(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, declaration: Syntax.VariableDeclarationSyntax): Syntax.EventFieldDeclarationSyntax;
        static EventFieldDeclaration_1145(declaration: Syntax.VariableDeclarationSyntax): Syntax.EventFieldDeclarationSyntax;
        static ExplicitInterfaceSpecifier_1235(name: Syntax.NameSyntax, dotToken: SyntaxToken): Syntax.ExplicitInterfaceSpecifierSyntax;
        static ExplicitInterfaceSpecifier_2222(name: Syntax.NameSyntax): Syntax.ExplicitInterfaceSpecifierSyntax;
        static MethodDeclaration_7196(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, returnType: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, parameterList: Syntax.ParameterListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>, body: Syntax.BlockSyntax, expressionBody: Syntax.ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): Syntax.MethodDeclarationSyntax;
        static MethodDeclaration_4928(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, returnType: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: Syntax.TypeParameterListSyntax, parameterList: Syntax.ParameterListSyntax, constraintClauses: SyntaxList<Syntax.TypeParameterConstraintClauseSyntax>, body: Syntax.BlockSyntax, expressionBody: Syntax.ArrowExpressionClauseSyntax): Syntax.MethodDeclarationSyntax;
        static MethodDeclaration_7463(returnType: Syntax.TypeSyntax, identifier: SyntaxToken): Syntax.MethodDeclarationSyntax;
        static MethodDeclaration_2046(returnType: Syntax.TypeSyntax, identifier: string): Syntax.MethodDeclarationSyntax;
        static OperatorDeclaration_1160(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, returnType: Syntax.TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: Syntax.ParameterListSyntax, body: Syntax.BlockSyntax, expressionBody: Syntax.ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): Syntax.OperatorDeclarationSyntax;
        static OperatorDeclaration_1772(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, returnType: Syntax.TypeSyntax, operatorToken: SyntaxToken, parameterList: Syntax.ParameterListSyntax, body: Syntax.BlockSyntax, expressionBody: Syntax.ArrowExpressionClauseSyntax): Syntax.OperatorDeclarationSyntax;
        static OperatorDeclaration_1820(returnType: Syntax.TypeSyntax, operatorToken: SyntaxToken): Syntax.OperatorDeclarationSyntax;
        static ConversionOperatorDeclaration_1744(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: Syntax.TypeSyntax, parameterList: Syntax.ParameterListSyntax, body: Syntax.BlockSyntax, expressionBody: Syntax.ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): Syntax.ConversionOperatorDeclarationSyntax;
        static ConversionOperatorDeclaration_1986(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, implicitOrExplicitKeyword: SyntaxToken, type: Syntax.TypeSyntax, parameterList: Syntax.ParameterListSyntax, body: Syntax.BlockSyntax, expressionBody: Syntax.ArrowExpressionClauseSyntax): Syntax.ConversionOperatorDeclarationSyntax;
        static ConversionOperatorDeclaration_2115(implicitOrExplicitKeyword: SyntaxToken, type: Syntax.TypeSyntax): Syntax.ConversionOperatorDeclarationSyntax;
        static ConstructorDeclaration_1481(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, identifier: SyntaxToken, parameterList: Syntax.ParameterListSyntax, initializer: Syntax.ConstructorInitializerSyntax, body: Syntax.BlockSyntax, semicolonToken: SyntaxToken): Syntax.ConstructorDeclarationSyntax;
        static ConstructorDeclaration_7306(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, identifier: SyntaxToken, parameterList: Syntax.ParameterListSyntax, initializer: Syntax.ConstructorInitializerSyntax, body: Syntax.BlockSyntax): Syntax.ConstructorDeclarationSyntax;
        static ConstructorDeclaration_8125(identifier: SyntaxToken): Syntax.ConstructorDeclarationSyntax;
        static ConstructorDeclaration_1140(identifier: string): Syntax.ConstructorDeclarationSyntax;
        static ConstructorInitializer_7095(kind: SyntaxKind, colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: Syntax.ArgumentListSyntax): Syntax.ConstructorInitializerSyntax;
        static ConstructorInitializer_1097(kind: SyntaxKind, argumentList?: Syntax.ArgumentListSyntax): Syntax.ConstructorInitializerSyntax;
        private static GetConstructorInitializerThisOrBaseKeywordKind(kind);
        static DestructorDeclaration_1923(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: Syntax.ParameterListSyntax, body: Syntax.BlockSyntax, semicolonToken: SyntaxToken): Syntax.DestructorDeclarationSyntax;
        static DestructorDeclaration_7645(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, identifier: SyntaxToken, parameterList: Syntax.ParameterListSyntax, body: Syntax.BlockSyntax): Syntax.DestructorDeclarationSyntax;
        static DestructorDeclaration_1929(identifier: SyntaxToken): Syntax.DestructorDeclarationSyntax;
        static DestructorDeclaration_1184(identifier: string): Syntax.DestructorDeclarationSyntax;
        static PropertyDeclaration_1381(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, type: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: Syntax.AccessorListSyntax, expressionBody: Syntax.ArrowExpressionClauseSyntax, initializer: Syntax.EqualsValueClauseSyntax, semicolon: SyntaxToken): Syntax.PropertyDeclarationSyntax;
        static PropertyDeclaration_1181(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, type: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: Syntax.AccessorListSyntax, expressionBody: Syntax.ArrowExpressionClauseSyntax, initializer: Syntax.EqualsValueClauseSyntax): Syntax.PropertyDeclarationSyntax;
        static PropertyDeclaration_1445(type: Syntax.TypeSyntax, identifier: SyntaxToken): Syntax.PropertyDeclarationSyntax;
        static PropertyDeclaration_1424(type: Syntax.TypeSyntax, identifier: string): Syntax.PropertyDeclarationSyntax;
        static ArrowExpressionClause_7237(arrowToken: SyntaxToken, expression: Syntax.ExpressionSyntax): Syntax.ArrowExpressionClauseSyntax;
        static ArrowExpressionClause_6470(expression: Syntax.ExpressionSyntax): Syntax.ArrowExpressionClauseSyntax;
        static EventDeclaration_1808(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, eventKeyword: SyntaxToken, type: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: Syntax.AccessorListSyntax): Syntax.EventDeclarationSyntax;
        static EventDeclaration_4696(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, type: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: Syntax.AccessorListSyntax): Syntax.EventDeclarationSyntax;
        static EventDeclaration_2008(type: Syntax.TypeSyntax, identifier: SyntaxToken): Syntax.EventDeclarationSyntax;
        static EventDeclaration_1015(type: Syntax.TypeSyntax, identifier: string): Syntax.EventDeclarationSyntax;
        static IndexerDeclaration_8282(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, type: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: Syntax.BracketedParameterListSyntax, accessorList: Syntax.AccessorListSyntax, expressionBody: Syntax.ArrowExpressionClauseSyntax, semicolon: SyntaxToken): Syntax.IndexerDeclarationSyntax;
        static IndexerDeclaration_4594(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, type: Syntax.TypeSyntax, explicitInterfaceSpecifier: Syntax.ExplicitInterfaceSpecifierSyntax, parameterList: Syntax.BracketedParameterListSyntax, accessorList: Syntax.AccessorListSyntax, expressionBody: Syntax.ArrowExpressionClauseSyntax): Syntax.IndexerDeclarationSyntax;
        static IndexerDeclaration_1134(type: Syntax.TypeSyntax): Syntax.IndexerDeclarationSyntax;
        static AccessorList_1639(openBraceToken: SyntaxToken, accessors: SyntaxList<Syntax.AccessorDeclarationSyntax>, closeBraceToken: SyntaxToken): Syntax.AccessorListSyntax;
        static AccessorList_1820(accessors?: SyntaxList<Syntax.AccessorDeclarationSyntax>): Syntax.AccessorListSyntax;
        static AccessorDeclaration_8957(kind: SyntaxKind, attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, keyword: SyntaxToken, body: Syntax.BlockSyntax, semicolonToken: SyntaxToken): Syntax.AccessorDeclarationSyntax;
        static AccessorDeclaration_1515(kind: SyntaxKind, attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, body: Syntax.BlockSyntax): Syntax.AccessorDeclarationSyntax;
        static AccessorDeclaration_9179(kind: SyntaxKind, body?: Syntax.BlockSyntax): Syntax.AccessorDeclarationSyntax;
        private static GetAccessorDeclarationKeywordKind(kind);
        static ParameterList_1120(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<Syntax.ParameterSyntax>, closeParenToken: SyntaxToken): Syntax.ParameterListSyntax;
        static ParameterList_8831(parameters?: SeparatedSyntaxList<Syntax.ParameterSyntax>): Syntax.ParameterListSyntax;
        static BracketedParameterList_1823(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<Syntax.ParameterSyntax>, closeBracketToken: SyntaxToken): Syntax.BracketedParameterListSyntax;
        static BracketedParameterList_1992(parameters?: SeparatedSyntaxList<Syntax.ParameterSyntax>): Syntax.BracketedParameterListSyntax;
        static Parameter_7982(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, type: Syntax.TypeSyntax, identifier: SyntaxToken, $default: Syntax.EqualsValueClauseSyntax): Syntax.ParameterSyntax;
        static Parameter_1967(identifier: SyntaxToken): Syntax.ParameterSyntax;
        static IncompleteMember_1376(attributeLists: SyntaxList<Syntax.AttributeListSyntax>, modifiers: SyntaxTokenList, type: Syntax.TypeSyntax): Syntax.IncompleteMemberSyntax;
        static IncompleteMember_1063(type?: Syntax.TypeSyntax): Syntax.IncompleteMemberSyntax;
        static SkippedTokensTrivia_1492(tokens: SyntaxTokenList): Syntax.SkippedTokensTriviaSyntax;
        static SkippedTokensTrivia_1030(): Syntax.SkippedTokensTriviaSyntax;
        static DocumentationCommentTrivia_1391(kind: SyntaxKind, content: SyntaxList<Syntax.XmlNodeSyntax>, endOfComment: SyntaxToken): Syntax.DocumentationCommentTriviaSyntax;
        static DocumentationCommentTrivia_1025(kind: SyntaxKind, content?: SyntaxList<Syntax.XmlNodeSyntax>): Syntax.DocumentationCommentTriviaSyntax;
        static TypeCref(type: Syntax.TypeSyntax): Syntax.TypeCrefSyntax;
        static QualifiedCref_1689(container: Syntax.TypeSyntax, dotToken: SyntaxToken, member: Syntax.MemberCrefSyntax): Syntax.QualifiedCrefSyntax;
        static QualifiedCref_6919(container: Syntax.TypeSyntax, member: Syntax.MemberCrefSyntax): Syntax.QualifiedCrefSyntax;
        static NameMemberCref_6133(name: Syntax.TypeSyntax, parameters: Syntax.CrefParameterListSyntax): Syntax.NameMemberCrefSyntax;
        static NameMemberCref_1522(name: Syntax.TypeSyntax): Syntax.NameMemberCrefSyntax;
        static IndexerMemberCref_1919(thisKeyword: SyntaxToken, parameters: Syntax.CrefBracketedParameterListSyntax): Syntax.IndexerMemberCrefSyntax;
        static IndexerMemberCref_7773(parameters?: Syntax.CrefBracketedParameterListSyntax): Syntax.IndexerMemberCrefSyntax;
        static OperatorMemberCref_8861(operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: Syntax.CrefParameterListSyntax): Syntax.OperatorMemberCrefSyntax;
        static OperatorMemberCref_6802(operatorToken: SyntaxToken, parameters: Syntax.CrefParameterListSyntax): Syntax.OperatorMemberCrefSyntax;
        static OperatorMemberCref_4079(operatorToken: SyntaxToken): Syntax.OperatorMemberCrefSyntax;
        static ConversionOperatorMemberCref_9661(implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: Syntax.TypeSyntax, parameters: Syntax.CrefParameterListSyntax): Syntax.ConversionOperatorMemberCrefSyntax;
        static ConversionOperatorMemberCref_1679(implicitOrExplicitKeyword: SyntaxToken, type: Syntax.TypeSyntax, parameters: Syntax.CrefParameterListSyntax): Syntax.ConversionOperatorMemberCrefSyntax;
        static ConversionOperatorMemberCref_2121(implicitOrExplicitKeyword: SyntaxToken, type: Syntax.TypeSyntax): Syntax.ConversionOperatorMemberCrefSyntax;
        static CrefParameterList_1308(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<Syntax.CrefParameterSyntax>, closeParenToken: SyntaxToken): Syntax.CrefParameterListSyntax;
        static CrefParameterList_1621(parameters?: SeparatedSyntaxList<Syntax.CrefParameterSyntax>): Syntax.CrefParameterListSyntax;
        static CrefBracketedParameterList_1976(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<Syntax.CrefParameterSyntax>, closeBracketToken: SyntaxToken): Syntax.CrefBracketedParameterListSyntax;
        static CrefBracketedParameterList_1239(parameters?: SeparatedSyntaxList<Syntax.CrefParameterSyntax>): Syntax.CrefBracketedParameterListSyntax;
        static CrefParameter_1799(refOrOutKeyword: SyntaxToken, type: Syntax.TypeSyntax): Syntax.CrefParameterSyntax;
        static CrefParameter_1173(type: Syntax.TypeSyntax): Syntax.CrefParameterSyntax;
        static XmlElement_1306(startTag: Syntax.XmlElementStartTagSyntax, content: SyntaxList<Syntax.XmlNodeSyntax>, endTag: Syntax.XmlElementEndTagSyntax): Syntax.XmlElementSyntax;
        static XmlElement_4504(startTag: Syntax.XmlElementStartTagSyntax, endTag: Syntax.XmlElementEndTagSyntax): Syntax.XmlElementSyntax;
        static XmlElementStartTag_2520(lessThanToken: SyntaxToken, name: Syntax.XmlNameSyntax, attributes: SyntaxList<Syntax.XmlAttributeSyntax>, greaterThanToken: SyntaxToken): Syntax.XmlElementStartTagSyntax;
        static XmlElementStartTag_9484(name: Syntax.XmlNameSyntax, attributes: SyntaxList<Syntax.XmlAttributeSyntax>): Syntax.XmlElementStartTagSyntax;
        static XmlElementStartTag_1612(name: Syntax.XmlNameSyntax): Syntax.XmlElementStartTagSyntax;
        static XmlElementEndTag_1148(lessThanSlashToken: SyntaxToken, name: Syntax.XmlNameSyntax, greaterThanToken: SyntaxToken): Syntax.XmlElementEndTagSyntax;
        static XmlElementEndTag_1332(name: Syntax.XmlNameSyntax): Syntax.XmlElementEndTagSyntax;
        static XmlEmptyElement_1077(lessThanToken: SyntaxToken, name: Syntax.XmlNameSyntax, attributes: SyntaxList<Syntax.XmlAttributeSyntax>, slashGreaterThanToken: SyntaxToken): Syntax.XmlEmptyElementSyntax;
        static XmlEmptyElement_1840(name: Syntax.XmlNameSyntax, attributes: SyntaxList<Syntax.XmlAttributeSyntax>): Syntax.XmlEmptyElementSyntax;
        static XmlEmptyElement_1296(name: Syntax.XmlNameSyntax): Syntax.XmlEmptyElementSyntax;
        static XmlName_7035(prefix: Syntax.XmlPrefixSyntax, localName: SyntaxToken): Syntax.XmlNameSyntax;
        static XmlName_3729(localName: SyntaxToken): Syntax.XmlNameSyntax;
        static XmlName_1304(localName: string): Syntax.XmlNameSyntax;
        static XmlPrefix_3737(prefix: SyntaxToken, colonToken: SyntaxToken): Syntax.XmlPrefixSyntax;
        static XmlPrefix_2083(prefix: SyntaxToken): Syntax.XmlPrefixSyntax;
        static XmlPrefix_1375(prefix: string): Syntax.XmlPrefixSyntax;
        static XmlTextAttribute_1252(name: Syntax.XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: SyntaxTokenList, endQuoteToken: SyntaxToken): Syntax.XmlTextAttributeSyntax;
        static XmlTextAttribute_1816(name: Syntax.XmlNameSyntax, startQuoteToken: SyntaxToken, textTokens: SyntaxTokenList, endQuoteToken: SyntaxToken): Syntax.XmlTextAttributeSyntax;
        static XmlTextAttribute_7348(name: Syntax.XmlNameSyntax, startQuoteToken: SyntaxToken, endQuoteToken: SyntaxToken): Syntax.XmlTextAttributeSyntax;
        static XmlCrefAttribute_1157(name: Syntax.XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: Syntax.CrefSyntax, endQuoteToken: SyntaxToken): Syntax.XmlCrefAttributeSyntax;
        static XmlCrefAttribute_5703(name: Syntax.XmlNameSyntax, startQuoteToken: SyntaxToken, cref: Syntax.CrefSyntax, endQuoteToken: SyntaxToken): Syntax.XmlCrefAttributeSyntax;
        static XmlNameAttribute_3328(name: Syntax.XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: Syntax.IdentifierNameSyntax, endQuoteToken: SyntaxToken): Syntax.XmlNameAttributeSyntax;
        static XmlNameAttribute_2143(name: Syntax.XmlNameSyntax, startQuoteToken: SyntaxToken, identifier: Syntax.IdentifierNameSyntax, endQuoteToken: SyntaxToken): Syntax.XmlNameAttributeSyntax;
        static XmlNameAttribute_7999(name: Syntax.XmlNameSyntax, startQuoteToken: SyntaxToken, identifier: string, endQuoteToken: SyntaxToken): Syntax.XmlNameAttributeSyntax;
        static XmlText_7478(textTokens: SyntaxTokenList): Syntax.XmlTextSyntax;
        static XmlText_4657(): Syntax.XmlTextSyntax;
        static XmlCDataSection_1269(startCDataToken: SyntaxToken, textTokens: SyntaxTokenList, endCDataToken: SyntaxToken): Syntax.XmlCDataSectionSyntax;
        static XmlCDataSection_6071(textTokens?: SyntaxTokenList): Syntax.XmlCDataSectionSyntax;
        static XmlProcessingInstruction_6003(startProcessingInstructionToken: SyntaxToken, name: Syntax.XmlNameSyntax, textTokens: SyntaxTokenList, endProcessingInstructionToken: SyntaxToken): Syntax.XmlProcessingInstructionSyntax;
        static XmlProcessingInstruction_1292(name: Syntax.XmlNameSyntax, textTokens: SyntaxTokenList): Syntax.XmlProcessingInstructionSyntax;
        static XmlProcessingInstruction_5754(name: Syntax.XmlNameSyntax): Syntax.XmlProcessingInstructionSyntax;
        static XmlComment_1987(lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: SyntaxTokenList, minusMinusGreaterThanToken: SyntaxToken): Syntax.XmlCommentSyntax;
        static XmlComment_2099(textTokens?: SyntaxTokenList): Syntax.XmlCommentSyntax;
        static IfDirectiveTrivia_3004(hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: Syntax.ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): Syntax.IfDirectiveTriviaSyntax;
        static IfDirectiveTrivia_2146(condition: Syntax.ExpressionSyntax, isActive: boolean, branchTaken: boolean, conditionValue: boolean): Syntax.IfDirectiveTriviaSyntax;
        static ElifDirectiveTrivia_1767(hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: Syntax.ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): Syntax.ElifDirectiveTriviaSyntax;
        static ElifDirectiveTrivia_1069(condition: Syntax.ExpressionSyntax, isActive: boolean, branchTaken: boolean, conditionValue: boolean): Syntax.ElifDirectiveTriviaSyntax;
        static ElseDirectiveTrivia_6202(hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean): Syntax.ElseDirectiveTriviaSyntax;
        static ElseDirectiveTrivia_2606(isActive: boolean, branchTaken: boolean): Syntax.ElseDirectiveTriviaSyntax;
        static EndIfDirectiveTrivia_1427(hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.EndIfDirectiveTriviaSyntax;
        static EndIfDirectiveTrivia_3948(isActive: boolean): Syntax.EndIfDirectiveTriviaSyntax;
        static RegionDirectiveTrivia_1280(hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.RegionDirectiveTriviaSyntax;
        static RegionDirectiveTrivia_8522(isActive: boolean): Syntax.RegionDirectiveTriviaSyntax;
        static EndRegionDirectiveTrivia_3825(hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.EndRegionDirectiveTriviaSyntax;
        static EndRegionDirectiveTrivia_8318(isActive: boolean): Syntax.EndRegionDirectiveTriviaSyntax;
        static ErrorDirectiveTrivia_4709(hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.ErrorDirectiveTriviaSyntax;
        static ErrorDirectiveTrivia_1714(isActive: boolean): Syntax.ErrorDirectiveTriviaSyntax;
        static WarningDirectiveTrivia_3903(hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.WarningDirectiveTriviaSyntax;
        static WarningDirectiveTrivia_1865(isActive: boolean): Syntax.WarningDirectiveTriviaSyntax;
        static BadDirectiveTrivia_1871(hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.BadDirectiveTriviaSyntax;
        static BadDirectiveTrivia_2707(identifier: SyntaxToken, isActive: boolean): Syntax.BadDirectiveTriviaSyntax;
        static DefineDirectiveTrivia_1640(hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.DefineDirectiveTriviaSyntax;
        static DefineDirectiveTrivia_2673(name: SyntaxToken, isActive: boolean): Syntax.DefineDirectiveTriviaSyntax;
        static DefineDirectiveTrivia_2085(name: string, isActive: boolean): Syntax.DefineDirectiveTriviaSyntax;
        static UndefDirectiveTrivia_1554(hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.UndefDirectiveTriviaSyntax;
        static UndefDirectiveTrivia_1022(name: SyntaxToken, isActive: boolean): Syntax.UndefDirectiveTriviaSyntax;
        static UndefDirectiveTrivia_6325(name: string, isActive: boolean): Syntax.UndefDirectiveTriviaSyntax;
        static LineDirectiveTrivia_2819(hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.LineDirectiveTriviaSyntax;
        static LineDirectiveTrivia_1235(line: SyntaxToken, file: SyntaxToken, isActive: boolean): Syntax.LineDirectiveTriviaSyntax;
        static LineDirectiveTrivia_1817(line: SyntaxToken, isActive: boolean): Syntax.LineDirectiveTriviaSyntax;
        static PragmaWarningDirectiveTrivia_1663(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: SeparatedSyntaxList<Syntax.ExpressionSyntax>, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.PragmaWarningDirectiveTriviaSyntax;
        static PragmaWarningDirectiveTrivia_2287(disableOrRestoreKeyword: SyntaxToken, errorCodes: SeparatedSyntaxList<Syntax.ExpressionSyntax>, isActive: boolean): Syntax.PragmaWarningDirectiveTriviaSyntax;
        static PragmaWarningDirectiveTrivia_1709(disableOrRestoreKeyword: SyntaxToken, isActive: boolean): Syntax.PragmaWarningDirectiveTriviaSyntax;
        static PragmaChecksumDirectiveTrivia_1238(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.PragmaChecksumDirectiveTriviaSyntax;
        static PragmaChecksumDirectiveTrivia_1298(file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, isActive: boolean): Syntax.PragmaChecksumDirectiveTriviaSyntax;
        static ReferenceDirectiveTrivia_1118(hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): Syntax.ReferenceDirectiveTriviaSyntax;
        static ReferenceDirectiveTrivia_2058(file: SyntaxToken, isActive: boolean): Syntax.ReferenceDirectiveTriviaSyntax;
        static InterpolatedString_4706(stringStart: SyntaxToken, interpolatedInserts: SeparatedSyntaxList<Syntax.InterpolatedStringInsertSyntax>, stringEnd: SyntaxToken): Syntax.InterpolatedStringSyntax;
        static InterpolatedString_1171(interpolatedInserts?: SeparatedSyntaxList<Syntax.InterpolatedStringInsertSyntax>): Syntax.InterpolatedStringSyntax;
        static InterpolatedStringInsert_5213(expression: Syntax.ExpressionSyntax, comma: SyntaxToken, alignment: Syntax.ExpressionSyntax, format: SyntaxToken): Syntax.InterpolatedStringInsertSyntax;
        static InterpolatedStringInsert_1969(expression: Syntax.ExpressionSyntax): Syntax.InterpolatedStringInsertSyntax;
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class CSharpSyntaxTree extends SyntaxTree {
        static Dummy: SyntaxTree;
        Options: CSharpParseOptions;
        protected CloneNodeAsRoot<T extends CSharpSyntaxNode>(node: T): T;
        GetRoot(cancellationToken?: System.Threading.CancellationToken): CSharpSyntaxNode;
        TryGetRoot(root: {
            refObj: CSharpSyntaxNode;
        }): boolean;
        GetCompilationUnitRoot(cancellationToken?: System.Threading.CancellationToken): Syntax.CompilationUnitSyntax;
        IsEquivalentTo(tree: SyntaxTree, topLevel?: boolean): boolean;
        HasReferenceDirectives: boolean;
        private hasDirectives;
        directives: Syntax.InternalSyntax.DirectiveStack;
        SetDirectiveStack(directives: Syntax.InternalSyntax.DirectiveStack): void;
        private GetDirectives();
        IsAnyPreprocessorSymbolDefined(conditionalSymbols: System.Collections.Immutable.ImmutableArray<string>): boolean;
        IsPreprocessorSymbolDefined_6691(symbolName: string): boolean;
        private IsPreprocessorSymbolDefined_3316(directives, symbolName);
        private preprocessorStateChangePositions;
        private preprocessorStates;
        IsPreprocessorSymbolDefined_1267(symbolName: string, position: number): boolean;
        private BuildPreprocessorStateChangeMap();
        static Create_5969(root: CSharpSyntaxNode, options?: CSharpParseOptions, path?: string, encoding?: System.Text.Encoding): SyntaxTree;
        static Create_5255(root: CSharpSyntaxNode, text: Text.SourceText): SyntaxTree;
        static CreateWithoutClone(root: CSharpSyntaxNode): SyntaxTree;
        static ParseText_7227(text: string, options?: CSharpParseOptions, path?: string, encoding?: System.Text.Encoding, cancellationToken?: System.Threading.CancellationToken): SyntaxTree;
        static ParseText_2029(text: Text.SourceText, options?: CSharpParseOptions, path?: string, cancellationToken?: System.Threading.CancellationToken): SyntaxTree;
        WithChangedText(newText: Text.SourceText): SyntaxTree;
        private WithChanges(newText, changes);
        GetChangedSpans(oldTree: SyntaxTree): System.Collections.Generic.IList<Text.TextSpan>;
        GetChanges(oldTree: SyntaxTree): System.Collections.Generic.IList<Text.TextChange>;
        GetLineSpan(span: Text.TextSpan, cancellationToken?: System.Threading.CancellationToken): FileLinePositionSpan;
        GetMappedLineSpan(span: Text.TextSpan, cancellationToken?: System.Threading.CancellationToken): FileLinePositionSpan;
        GetLineVisibility(position: number, cancellationToken?: System.Threading.CancellationToken): LineVisibility;
        GetMappedLineSpanAndVisibility(span: Text.TextSpan, isHiddenPosition: {
            refObj: boolean;
        }): FileLinePositionSpan;
        HasHiddenRegions(): boolean;
        GetPragmaDirectiveWarningState(id: string, position: number): ReportDiagnostic;
        private lazyLineDirectiveMap;
        private lazyPragmaWarningStateMap;
        private GetLinePosition(position);
        GetLocation(span: Text.TextSpan): Location;
        GetDiagnostics_1067(node: SyntaxNode): System.Collections.Generic.IEnumerable<Diagnostic>;
        private GetDiagnostics_1234(greenNode, position);
        private EnumerateDiagnostics(node, position);
        GetDiagnostics_9583(token: SyntaxToken): System.Collections.Generic.IEnumerable<Diagnostic>;
        GetDiagnostics_1774(trivia: SyntaxTrivia): System.Collections.Generic.IEnumerable<Diagnostic>;
        GetDiagnostics_6963(nodeOrToken: SyntaxNodeOrToken): System.Collections.Generic.IEnumerable<Diagnostic>;
        GetDiagnostics_4066(cancellationToken?: System.Threading.CancellationToken): System.Collections.Generic.IEnumerable<Diagnostic>;
        protected GetRootCore(cancellationToken: System.Threading.CancellationToken): SyntaxNode;
        protected TryGetRootCore(root: {
            refObj: SyntaxNode;
        }): boolean;
        OptionsCore: ParseOptions;
        constructor();
    }
    module CSharpSyntaxTree {
        class DummySyntaxTree extends CSharpSyntaxTree {
            private node;
            ctor_1052(): DummySyntaxTree;
            ToString(): string;
            GetText(cancellationToken: System.Threading.CancellationToken): Text.SourceText;
            TryGetText(text: {
                refObj: Text.SourceText;
            }): boolean;
            Length: number;
            Options: CSharpParseOptions;
            FilePath: string;
            GetReference(node: SyntaxNode): SyntaxReference;
            GetRoot(cancellationToken: System.Threading.CancellationToken): CSharpSyntaxNode;
            TryGetRoot(root: {
                refObj: CSharpSyntaxNode;
            }): boolean;
            HasCompilationUnitRoot: boolean;
            GetLineSpan(span: Text.TextSpan, cancellationToken?: System.Threading.CancellationToken): FileLinePositionSpan;
            WithRootAndOptions(root: SyntaxNode, options: ParseOptions): SyntaxTree;
            WithFilePath(path: string): SyntaxTree;
            constructor();
        }
        class ParsedSyntaxTree extends CSharpSyntaxTree {
            private options;
            private path;
            private root;
            private hasCompilationUnitRoot;
            private encodingOpt;
            private checksumAlgorithm;
            private lazyText;
            ctor_1144(textOpt: Text.SourceText, encodingOpt: System.Text.Encoding, checksumAlgorithm: Text.SourceHashAlgorithm, path: string, options: CSharpParseOptions, root: CSharpSyntaxNode, directives: Syntax.InternalSyntax.DirectiveStack, cloneRoot?: boolean): ParsedSyntaxTree;
            FilePath: string;
            GetText(cancellationToken: System.Threading.CancellationToken): Text.SourceText;
            TryGetText(text: {
                refObj: Text.SourceText;
            }): boolean;
            Length: number;
            GetRoot(cancellationToken: System.Threading.CancellationToken): CSharpSyntaxNode;
            TryGetRoot(root: {
                refObj: CSharpSyntaxNode;
            }): boolean;
            HasCompilationUnitRoot: boolean;
            Options: CSharpParseOptions;
            GetReference(node: SyntaxNode): SyntaxReference;
            ToString(): string;
            WithRootAndOptions(root: SyntaxNode, options: ParseOptions): SyntaxTree;
            WithFilePath(path: string): SyntaxTree;
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class ChildSyntaxList implements IStruct {
        private node;
        private count;
        ctor_9473(node: GreenNode): ChildSyntaxList;
        Count: number;
        private CountNodes();
        private Nodes;
        GetEnumerator(): ChildSyntaxList.Enumerator;
        Reverse(): ChildSyntaxList.Reversed;
        constructor();
    }
    module ChildSyntaxList {
        class Enumerator implements IStruct {
            private node;
            private childIndex;
            private list;
            private listIndex;
            private currentChild;
            ctor_2154(node: GreenNode): Enumerator;
            MoveNext(): boolean;
            Current: GreenNode;
            constructor();
        }
    }
    module ChildSyntaxList {
        class Reversed implements IStruct {
            private node;
            ctor_2096(node: GreenNode): Reversed;
            GetEnumerator(): Reversed.Enumerator;
            private Nodes;
            constructor();
        }
        module Reversed {
            class Enumerator implements IStruct {
                private node;
                private childIndex;
                private list;
                private listIndex;
                private currentChild;
                ctor_2154(node: GreenNode): Enumerator;
                MoveNext(): boolean;
                Current: GreenNode;
                constructor();
            }
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SeparatedSyntaxList<TNode extends CSharpSyntaxNode> implements System.IEquatable<SeparatedSyntaxList<TNode>>, IStruct {
        private list;
        ctor_9176(list: SyntaxList<CSharpSyntaxNode>): SeparatedSyntaxList<TNode>;
        private static Validate(list);
        Node: CSharpSyntaxNode;
        Count: number;
        SeparatorCount: number;
        $get$(index: number): TNode;
        GetSeparator(index: number): SyntaxToken;
        GetWithSeparators(): SyntaxList<CSharpSyntaxNode>;
        op_Equality(right: SeparatedSyntaxList<TNode>): boolean;
        op_Inequality(right: SeparatedSyntaxList<TNode>): boolean;
        Equals_1373(other: SeparatedSyntaxList<TNode>): boolean;
        Equals(obj: Object): boolean;
        GetHashCode(): number;
        private Nodes;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxDiagnosticInfoList implements IStruct {
        private node;
        ctor_2725(node: GreenNode): SyntaxDiagnosticInfoList;
        GetEnumerator(): SyntaxDiagnosticInfoList.Enumerator;
        Any(predicate: (_: DiagnosticInfo) => boolean): boolean;
        constructor();
    }
    module SyntaxDiagnosticInfoList {
        class Enumerator implements IStruct {
            private stack;
            private count;
            private current;
            ctor_2154(node: GreenNode): Enumerator;
            MoveNext(): boolean;
            private PushNodeOrToken(node);
            private PushToken(token);
            private Push(node);
            private Pop();
            Current: DiagnosticInfo;
            constructor();
        }
        module Enumerator {
            class NodeIteration implements IStruct {
                Node: GreenNode;
                DiagnosticIndex: number;
                SlotIndex: number;
                ctor_1131(node: GreenNode): NodeIteration;
                constructor();
            }
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class CSharpSyntaxVisitor<TResult> {
        Visit(node: CSharpSyntaxNode): TResult;
        VisitToken(token: SyntaxToken): TResult;
        VisitTrivia(trivia: SyntaxTrivia): TResult;
        protected DefaultVisit(node: CSharpSyntaxNode): TResult;
        VisitIdentifierName(node: IdentifierNameSyntax): TResult;
        VisitQualifiedName(node: QualifiedNameSyntax): TResult;
        VisitGenericName(node: GenericNameSyntax): TResult;
        VisitTypeArgumentList(node: TypeArgumentListSyntax): TResult;
        VisitAliasQualifiedName(node: AliasQualifiedNameSyntax): TResult;
        VisitPredefinedType(node: PredefinedTypeSyntax): TResult;
        VisitArrayType(node: ArrayTypeSyntax): TResult;
        VisitArrayRankSpecifier(node: ArrayRankSpecifierSyntax): TResult;
        VisitPointerType(node: PointerTypeSyntax): TResult;
        VisitNullableType(node: NullableTypeSyntax): TResult;
        VisitOmittedTypeArgument(node: OmittedTypeArgumentSyntax): TResult;
        VisitParenthesizedExpression(node: ParenthesizedExpressionSyntax): TResult;
        VisitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): TResult;
        VisitAwaitExpression(node: AwaitExpressionSyntax): TResult;
        VisitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): TResult;
        VisitMemberAccessExpression(node: MemberAccessExpressionSyntax): TResult;
        VisitConditionalAccessExpression(node: ConditionalAccessExpressionSyntax): TResult;
        VisitMemberBindingExpression(node: MemberBindingExpressionSyntax): TResult;
        VisitElementBindingExpression(node: ElementBindingExpressionSyntax): TResult;
        VisitImplicitElementAccess(node: ImplicitElementAccessSyntax): TResult;
        VisitBinaryExpression(node: BinaryExpressionSyntax): TResult;
        VisitAssignmentExpression(node: AssignmentExpressionSyntax): TResult;
        VisitConditionalExpression(node: ConditionalExpressionSyntax): TResult;
        VisitThisExpression(node: ThisExpressionSyntax): TResult;
        VisitBaseExpression(node: BaseExpressionSyntax): TResult;
        VisitLiteralExpression(node: LiteralExpressionSyntax): TResult;
        VisitMakeRefExpression(node: MakeRefExpressionSyntax): TResult;
        VisitRefTypeExpression(node: RefTypeExpressionSyntax): TResult;
        VisitRefValueExpression(node: RefValueExpressionSyntax): TResult;
        VisitCheckedExpression(node: CheckedExpressionSyntax): TResult;
        VisitDefaultExpression(node: DefaultExpressionSyntax): TResult;
        VisitTypeOfExpression(node: TypeOfExpressionSyntax): TResult;
        VisitSizeOfExpression(node: SizeOfExpressionSyntax): TResult;
        VisitInvocationExpression(node: InvocationExpressionSyntax): TResult;
        VisitElementAccessExpression(node: ElementAccessExpressionSyntax): TResult;
        VisitArgumentList(node: ArgumentListSyntax): TResult;
        VisitBracketedArgumentList(node: BracketedArgumentListSyntax): TResult;
        VisitArgument(node: ArgumentSyntax): TResult;
        VisitNameColon(node: NameColonSyntax): TResult;
        VisitCastExpression(node: CastExpressionSyntax): TResult;
        VisitAnonymousMethodExpression(node: AnonymousMethodExpressionSyntax): TResult;
        VisitSimpleLambdaExpression(node: SimpleLambdaExpressionSyntax): TResult;
        VisitParenthesizedLambdaExpression(node: ParenthesizedLambdaExpressionSyntax): TResult;
        VisitInitializerExpression(node: InitializerExpressionSyntax): TResult;
        VisitObjectCreationExpression(node: ObjectCreationExpressionSyntax): TResult;
        VisitAnonymousObjectMemberDeclarator(node: AnonymousObjectMemberDeclaratorSyntax): TResult;
        VisitAnonymousObjectCreationExpression(node: AnonymousObjectCreationExpressionSyntax): TResult;
        VisitArrayCreationExpression(node: ArrayCreationExpressionSyntax): TResult;
        VisitImplicitArrayCreationExpression(node: ImplicitArrayCreationExpressionSyntax): TResult;
        VisitStackAllocArrayCreationExpression(node: StackAllocArrayCreationExpressionSyntax): TResult;
        VisitQueryExpression(node: QueryExpressionSyntax): TResult;
        VisitQueryBody(node: QueryBodySyntax): TResult;
        VisitFromClause(node: FromClauseSyntax): TResult;
        VisitLetClause(node: LetClauseSyntax): TResult;
        VisitJoinClause(node: JoinClauseSyntax): TResult;
        VisitJoinIntoClause(node: JoinIntoClauseSyntax): TResult;
        VisitWhereClause(node: WhereClauseSyntax): TResult;
        VisitOrderByClause(node: OrderByClauseSyntax): TResult;
        VisitOrdering(node: OrderingSyntax): TResult;
        VisitSelectClause(node: SelectClauseSyntax): TResult;
        VisitGroupClause(node: GroupClauseSyntax): TResult;
        VisitQueryContinuation(node: QueryContinuationSyntax): TResult;
        VisitOmittedArraySizeExpression(node: OmittedArraySizeExpressionSyntax): TResult;
        VisitGlobalStatement(node: GlobalStatementSyntax): TResult;
        VisitBlock(node: BlockSyntax): TResult;
        VisitLocalDeclarationStatement(node: LocalDeclarationStatementSyntax): TResult;
        VisitVariableDeclaration(node: VariableDeclarationSyntax): TResult;
        VisitVariableDeclarator(node: VariableDeclaratorSyntax): TResult;
        VisitEqualsValueClause(node: EqualsValueClauseSyntax): TResult;
        VisitExpressionStatement(node: ExpressionStatementSyntax): TResult;
        VisitEmptyStatement(node: EmptyStatementSyntax): TResult;
        VisitLabeledStatement(node: LabeledStatementSyntax): TResult;
        VisitGotoStatement(node: GotoStatementSyntax): TResult;
        VisitBreakStatement(node: BreakStatementSyntax): TResult;
        VisitContinueStatement(node: ContinueStatementSyntax): TResult;
        VisitReturnStatement(node: ReturnStatementSyntax): TResult;
        VisitThrowStatement(node: ThrowStatementSyntax): TResult;
        VisitYieldStatement(node: YieldStatementSyntax): TResult;
        VisitWhileStatement(node: WhileStatementSyntax): TResult;
        VisitDoStatement(node: DoStatementSyntax): TResult;
        VisitForStatement(node: ForStatementSyntax): TResult;
        VisitForEachStatement(node: ForEachStatementSyntax): TResult;
        VisitUsingStatement(node: UsingStatementSyntax): TResult;
        VisitFixedStatement(node: FixedStatementSyntax): TResult;
        VisitCheckedStatement(node: CheckedStatementSyntax): TResult;
        VisitUnsafeStatement(node: UnsafeStatementSyntax): TResult;
        VisitLockStatement(node: LockStatementSyntax): TResult;
        VisitIfStatement(node: IfStatementSyntax): TResult;
        VisitElseClause(node: ElseClauseSyntax): TResult;
        VisitSwitchStatement(node: SwitchStatementSyntax): TResult;
        VisitSwitchSection(node: SwitchSectionSyntax): TResult;
        VisitCaseSwitchLabel(node: CaseSwitchLabelSyntax): TResult;
        VisitDefaultSwitchLabel(node: DefaultSwitchLabelSyntax): TResult;
        VisitTryStatement(node: TryStatementSyntax): TResult;
        VisitCatchClause(node: CatchClauseSyntax): TResult;
        VisitCatchDeclaration(node: CatchDeclarationSyntax): TResult;
        VisitCatchFilterClause(node: CatchFilterClauseSyntax): TResult;
        VisitFinallyClause(node: FinallyClauseSyntax): TResult;
        VisitCompilationUnit(node: CompilationUnitSyntax): TResult;
        VisitExternAliasDirective(node: ExternAliasDirectiveSyntax): TResult;
        VisitUsingDirective(node: UsingDirectiveSyntax): TResult;
        VisitNamespaceDeclaration(node: NamespaceDeclarationSyntax): TResult;
        VisitAttributeList(node: AttributeListSyntax): TResult;
        VisitAttributeTargetSpecifier(node: AttributeTargetSpecifierSyntax): TResult;
        VisitAttribute(node: AttributeSyntax): TResult;
        VisitAttributeArgumentList(node: AttributeArgumentListSyntax): TResult;
        VisitAttributeArgument(node: AttributeArgumentSyntax): TResult;
        VisitNameEquals(node: NameEqualsSyntax): TResult;
        VisitTypeParameterList(node: TypeParameterListSyntax): TResult;
        VisitTypeParameter(node: TypeParameterSyntax): TResult;
        VisitClassDeclaration(node: ClassDeclarationSyntax): TResult;
        VisitStructDeclaration(node: StructDeclarationSyntax): TResult;
        VisitInterfaceDeclaration(node: InterfaceDeclarationSyntax): TResult;
        VisitEnumDeclaration(node: EnumDeclarationSyntax): TResult;
        VisitDelegateDeclaration(node: DelegateDeclarationSyntax): TResult;
        VisitEnumMemberDeclaration(node: EnumMemberDeclarationSyntax): TResult;
        VisitBaseList(node: BaseListSyntax): TResult;
        VisitSimpleBaseType(node: SimpleBaseTypeSyntax): TResult;
        VisitTypeParameterConstraintClause(node: TypeParameterConstraintClauseSyntax): TResult;
        VisitConstructorConstraint(node: ConstructorConstraintSyntax): TResult;
        VisitClassOrStructConstraint(node: ClassOrStructConstraintSyntax): TResult;
        VisitTypeConstraint(node: TypeConstraintSyntax): TResult;
        VisitFieldDeclaration(node: FieldDeclarationSyntax): TResult;
        VisitEventFieldDeclaration(node: EventFieldDeclarationSyntax): TResult;
        VisitExplicitInterfaceSpecifier(node: ExplicitInterfaceSpecifierSyntax): TResult;
        VisitMethodDeclaration(node: MethodDeclarationSyntax): TResult;
        VisitOperatorDeclaration(node: OperatorDeclarationSyntax): TResult;
        VisitConversionOperatorDeclaration(node: ConversionOperatorDeclarationSyntax): TResult;
        VisitConstructorDeclaration(node: ConstructorDeclarationSyntax): TResult;
        VisitConstructorInitializer(node: ConstructorInitializerSyntax): TResult;
        VisitDestructorDeclaration(node: DestructorDeclarationSyntax): TResult;
        VisitPropertyDeclaration(node: PropertyDeclarationSyntax): TResult;
        VisitArrowExpressionClause(node: ArrowExpressionClauseSyntax): TResult;
        VisitEventDeclaration(node: EventDeclarationSyntax): TResult;
        VisitIndexerDeclaration(node: IndexerDeclarationSyntax): TResult;
        VisitAccessorList(node: AccessorListSyntax): TResult;
        VisitAccessorDeclaration(node: AccessorDeclarationSyntax): TResult;
        VisitParameterList(node: ParameterListSyntax): TResult;
        VisitBracketedParameterList(node: BracketedParameterListSyntax): TResult;
        VisitParameter(node: ParameterSyntax): TResult;
        VisitIncompleteMember(node: IncompleteMemberSyntax): TResult;
        VisitSkippedTokensTrivia(node: SkippedTokensTriviaSyntax): TResult;
        VisitDocumentationCommentTrivia(node: DocumentationCommentTriviaSyntax): TResult;
        VisitTypeCref(node: TypeCrefSyntax): TResult;
        VisitQualifiedCref(node: QualifiedCrefSyntax): TResult;
        VisitNameMemberCref(node: NameMemberCrefSyntax): TResult;
        VisitIndexerMemberCref(node: IndexerMemberCrefSyntax): TResult;
        VisitOperatorMemberCref(node: OperatorMemberCrefSyntax): TResult;
        VisitConversionOperatorMemberCref(node: ConversionOperatorMemberCrefSyntax): TResult;
        VisitCrefParameterList(node: CrefParameterListSyntax): TResult;
        VisitCrefBracketedParameterList(node: CrefBracketedParameterListSyntax): TResult;
        VisitCrefParameter(node: CrefParameterSyntax): TResult;
        VisitXmlElement(node: XmlElementSyntax): TResult;
        VisitXmlElementStartTag(node: XmlElementStartTagSyntax): TResult;
        VisitXmlElementEndTag(node: XmlElementEndTagSyntax): TResult;
        VisitXmlEmptyElement(node: XmlEmptyElementSyntax): TResult;
        VisitXmlName(node: XmlNameSyntax): TResult;
        VisitXmlPrefix(node: XmlPrefixSyntax): TResult;
        VisitXmlTextAttribute(node: XmlTextAttributeSyntax): TResult;
        VisitXmlCrefAttribute(node: XmlCrefAttributeSyntax): TResult;
        VisitXmlNameAttribute(node: XmlNameAttributeSyntax): TResult;
        VisitXmlText(node: XmlTextSyntax): TResult;
        VisitXmlCDataSection(node: XmlCDataSectionSyntax): TResult;
        VisitXmlProcessingInstruction(node: XmlProcessingInstructionSyntax): TResult;
        VisitXmlComment(node: XmlCommentSyntax): TResult;
        VisitIfDirectiveTrivia(node: IfDirectiveTriviaSyntax): TResult;
        VisitElifDirectiveTrivia(node: ElifDirectiveTriviaSyntax): TResult;
        VisitElseDirectiveTrivia(node: ElseDirectiveTriviaSyntax): TResult;
        VisitEndIfDirectiveTrivia(node: EndIfDirectiveTriviaSyntax): TResult;
        VisitRegionDirectiveTrivia(node: RegionDirectiveTriviaSyntax): TResult;
        VisitEndRegionDirectiveTrivia(node: EndRegionDirectiveTriviaSyntax): TResult;
        VisitErrorDirectiveTrivia(node: ErrorDirectiveTriviaSyntax): TResult;
        VisitWarningDirectiveTrivia(node: WarningDirectiveTriviaSyntax): TResult;
        VisitBadDirectiveTrivia(node: BadDirectiveTriviaSyntax): TResult;
        VisitDefineDirectiveTrivia(node: DefineDirectiveTriviaSyntax): TResult;
        VisitUndefDirectiveTrivia(node: UndefDirectiveTriviaSyntax): TResult;
        VisitLineDirectiveTrivia(node: LineDirectiveTriviaSyntax): TResult;
        VisitPragmaWarningDirectiveTrivia(node: PragmaWarningDirectiveTriviaSyntax): TResult;
        VisitPragmaChecksumDirectiveTrivia(node: PragmaChecksumDirectiveTriviaSyntax): TResult;
        VisitReferenceDirectiveTrivia(node: ReferenceDirectiveTriviaSyntax): TResult;
        VisitInterpolatedString(node: InterpolatedStringSyntax): TResult;
        VisitInterpolatedStringInsert(node: InterpolatedStringInsertSyntax): TResult;
        constructor();
    }
    class CSharpSyntaxVisitorBase {
        Visit(node: CSharpSyntaxNode): void;
        VisitToken(token: SyntaxToken): void;
        VisitTrivia(trivia: SyntaxTrivia): void;
        DefaultVisit(node: CSharpSyntaxNode): void;
        VisitIdentifierName(node: IdentifierNameSyntax): void;
        VisitQualifiedName(node: QualifiedNameSyntax): void;
        VisitGenericName(node: GenericNameSyntax): void;
        VisitTypeArgumentList(node: TypeArgumentListSyntax): void;
        VisitAliasQualifiedName(node: AliasQualifiedNameSyntax): void;
        VisitPredefinedType(node: PredefinedTypeSyntax): void;
        VisitArrayType(node: ArrayTypeSyntax): void;
        VisitArrayRankSpecifier(node: ArrayRankSpecifierSyntax): void;
        VisitPointerType(node: PointerTypeSyntax): void;
        VisitNullableType(node: NullableTypeSyntax): void;
        VisitOmittedTypeArgument(node: OmittedTypeArgumentSyntax): void;
        VisitParenthesizedExpression(node: ParenthesizedExpressionSyntax): void;
        VisitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): void;
        VisitAwaitExpression(node: AwaitExpressionSyntax): void;
        VisitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): void;
        VisitMemberAccessExpression(node: MemberAccessExpressionSyntax): void;
        VisitConditionalAccessExpression(node: ConditionalAccessExpressionSyntax): void;
        VisitMemberBindingExpression(node: MemberBindingExpressionSyntax): void;
        VisitElementBindingExpression(node: ElementBindingExpressionSyntax): void;
        VisitImplicitElementAccess(node: ImplicitElementAccessSyntax): void;
        VisitBinaryExpression(node: BinaryExpressionSyntax): void;
        VisitAssignmentExpression(node: AssignmentExpressionSyntax): void;
        VisitConditionalExpression(node: ConditionalExpressionSyntax): void;
        VisitThisExpression(node: ThisExpressionSyntax): void;
        VisitBaseExpression(node: BaseExpressionSyntax): void;
        VisitLiteralExpression(node: LiteralExpressionSyntax): void;
        VisitMakeRefExpression(node: MakeRefExpressionSyntax): void;
        VisitRefTypeExpression(node: RefTypeExpressionSyntax): void;
        VisitRefValueExpression(node: RefValueExpressionSyntax): void;
        VisitCheckedExpression(node: CheckedExpressionSyntax): void;
        VisitDefaultExpression(node: DefaultExpressionSyntax): void;
        VisitTypeOfExpression(node: TypeOfExpressionSyntax): void;
        VisitSizeOfExpression(node: SizeOfExpressionSyntax): void;
        VisitInvocationExpression(node: InvocationExpressionSyntax): void;
        VisitElementAccessExpression(node: ElementAccessExpressionSyntax): void;
        VisitArgumentList(node: ArgumentListSyntax): void;
        VisitBracketedArgumentList(node: BracketedArgumentListSyntax): void;
        VisitArgument(node: ArgumentSyntax): void;
        VisitNameColon(node: NameColonSyntax): void;
        VisitCastExpression(node: CastExpressionSyntax): void;
        VisitAnonymousMethodExpression(node: AnonymousMethodExpressionSyntax): void;
        VisitSimpleLambdaExpression(node: SimpleLambdaExpressionSyntax): void;
        VisitParenthesizedLambdaExpression(node: ParenthesizedLambdaExpressionSyntax): void;
        VisitInitializerExpression(node: InitializerExpressionSyntax): void;
        VisitObjectCreationExpression(node: ObjectCreationExpressionSyntax): void;
        VisitAnonymousObjectMemberDeclarator(node: AnonymousObjectMemberDeclaratorSyntax): void;
        VisitAnonymousObjectCreationExpression(node: AnonymousObjectCreationExpressionSyntax): void;
        VisitArrayCreationExpression(node: ArrayCreationExpressionSyntax): void;
        VisitImplicitArrayCreationExpression(node: ImplicitArrayCreationExpressionSyntax): void;
        VisitStackAllocArrayCreationExpression(node: StackAllocArrayCreationExpressionSyntax): void;
        VisitQueryExpression(node: QueryExpressionSyntax): void;
        VisitQueryBody(node: QueryBodySyntax): void;
        VisitFromClause(node: FromClauseSyntax): void;
        VisitLetClause(node: LetClauseSyntax): void;
        VisitJoinClause(node: JoinClauseSyntax): void;
        VisitJoinIntoClause(node: JoinIntoClauseSyntax): void;
        VisitWhereClause(node: WhereClauseSyntax): void;
        VisitOrderByClause(node: OrderByClauseSyntax): void;
        VisitOrdering(node: OrderingSyntax): void;
        VisitSelectClause(node: SelectClauseSyntax): void;
        VisitGroupClause(node: GroupClauseSyntax): void;
        VisitQueryContinuation(node: QueryContinuationSyntax): void;
        VisitOmittedArraySizeExpression(node: OmittedArraySizeExpressionSyntax): void;
        VisitGlobalStatement(node: GlobalStatementSyntax): void;
        VisitBlock(node: BlockSyntax): void;
        VisitLocalDeclarationStatement(node: LocalDeclarationStatementSyntax): void;
        VisitVariableDeclaration(node: VariableDeclarationSyntax): void;
        VisitVariableDeclarator(node: VariableDeclaratorSyntax): void;
        VisitEqualsValueClause(node: EqualsValueClauseSyntax): void;
        VisitExpressionStatement(node: ExpressionStatementSyntax): void;
        VisitEmptyStatement(node: EmptyStatementSyntax): void;
        VisitLabeledStatement(node: LabeledStatementSyntax): void;
        VisitGotoStatement(node: GotoStatementSyntax): void;
        VisitBreakStatement(node: BreakStatementSyntax): void;
        VisitContinueStatement(node: ContinueStatementSyntax): void;
        VisitReturnStatement(node: ReturnStatementSyntax): void;
        VisitThrowStatement(node: ThrowStatementSyntax): void;
        VisitYieldStatement(node: YieldStatementSyntax): void;
        VisitWhileStatement(node: WhileStatementSyntax): void;
        VisitDoStatement(node: DoStatementSyntax): void;
        VisitForStatement(node: ForStatementSyntax): void;
        VisitForEachStatement(node: ForEachStatementSyntax): void;
        VisitUsingStatement(node: UsingStatementSyntax): void;
        VisitFixedStatement(node: FixedStatementSyntax): void;
        VisitCheckedStatement(node: CheckedStatementSyntax): void;
        VisitUnsafeStatement(node: UnsafeStatementSyntax): void;
        VisitLockStatement(node: LockStatementSyntax): void;
        VisitIfStatement(node: IfStatementSyntax): void;
        VisitElseClause(node: ElseClauseSyntax): void;
        VisitSwitchStatement(node: SwitchStatementSyntax): void;
        VisitSwitchSection(node: SwitchSectionSyntax): void;
        VisitCaseSwitchLabel(node: CaseSwitchLabelSyntax): void;
        VisitDefaultSwitchLabel(node: DefaultSwitchLabelSyntax): void;
        VisitTryStatement(node: TryStatementSyntax): void;
        VisitCatchClause(node: CatchClauseSyntax): void;
        VisitCatchDeclaration(node: CatchDeclarationSyntax): void;
        VisitCatchFilterClause(node: CatchFilterClauseSyntax): void;
        VisitFinallyClause(node: FinallyClauseSyntax): void;
        VisitCompilationUnit(node: CompilationUnitSyntax): void;
        VisitExternAliasDirective(node: ExternAliasDirectiveSyntax): void;
        VisitUsingDirective(node: UsingDirectiveSyntax): void;
        VisitNamespaceDeclaration(node: NamespaceDeclarationSyntax): void;
        VisitAttributeList(node: AttributeListSyntax): void;
        VisitAttributeTargetSpecifier(node: AttributeTargetSpecifierSyntax): void;
        VisitAttribute(node: AttributeSyntax): void;
        VisitAttributeArgumentList(node: AttributeArgumentListSyntax): void;
        VisitAttributeArgument(node: AttributeArgumentSyntax): void;
        VisitNameEquals(node: NameEqualsSyntax): void;
        VisitTypeParameterList(node: TypeParameterListSyntax): void;
        VisitTypeParameter(node: TypeParameterSyntax): void;
        VisitClassDeclaration(node: ClassDeclarationSyntax): void;
        VisitStructDeclaration(node: StructDeclarationSyntax): void;
        VisitInterfaceDeclaration(node: InterfaceDeclarationSyntax): void;
        VisitEnumDeclaration(node: EnumDeclarationSyntax): void;
        VisitDelegateDeclaration(node: DelegateDeclarationSyntax): void;
        VisitEnumMemberDeclaration(node: EnumMemberDeclarationSyntax): void;
        VisitBaseList(node: BaseListSyntax): void;
        VisitSimpleBaseType(node: SimpleBaseTypeSyntax): void;
        VisitTypeParameterConstraintClause(node: TypeParameterConstraintClauseSyntax): void;
        VisitConstructorConstraint(node: ConstructorConstraintSyntax): void;
        VisitClassOrStructConstraint(node: ClassOrStructConstraintSyntax): void;
        VisitTypeConstraint(node: TypeConstraintSyntax): void;
        VisitFieldDeclaration(node: FieldDeclarationSyntax): void;
        VisitEventFieldDeclaration(node: EventFieldDeclarationSyntax): void;
        VisitExplicitInterfaceSpecifier(node: ExplicitInterfaceSpecifierSyntax): void;
        VisitMethodDeclaration(node: MethodDeclarationSyntax): void;
        VisitOperatorDeclaration(node: OperatorDeclarationSyntax): void;
        VisitConversionOperatorDeclaration(node: ConversionOperatorDeclarationSyntax): void;
        VisitConstructorDeclaration(node: ConstructorDeclarationSyntax): void;
        VisitConstructorInitializer(node: ConstructorInitializerSyntax): void;
        VisitDestructorDeclaration(node: DestructorDeclarationSyntax): void;
        VisitPropertyDeclaration(node: PropertyDeclarationSyntax): void;
        VisitArrowExpressionClause(node: ArrowExpressionClauseSyntax): void;
        VisitEventDeclaration(node: EventDeclarationSyntax): void;
        VisitIndexerDeclaration(node: IndexerDeclarationSyntax): void;
        VisitAccessorList(node: AccessorListSyntax): void;
        VisitAccessorDeclaration(node: AccessorDeclarationSyntax): void;
        VisitParameterList(node: ParameterListSyntax): void;
        VisitBracketedParameterList(node: BracketedParameterListSyntax): void;
        VisitParameter(node: ParameterSyntax): void;
        VisitIncompleteMember(node: IncompleteMemberSyntax): void;
        VisitSkippedTokensTrivia(node: SkippedTokensTriviaSyntax): void;
        VisitDocumentationCommentTrivia(node: DocumentationCommentTriviaSyntax): void;
        VisitTypeCref(node: TypeCrefSyntax): void;
        VisitQualifiedCref(node: QualifiedCrefSyntax): void;
        VisitNameMemberCref(node: NameMemberCrefSyntax): void;
        VisitIndexerMemberCref(node: IndexerMemberCrefSyntax): void;
        VisitOperatorMemberCref(node: OperatorMemberCrefSyntax): void;
        VisitConversionOperatorMemberCref(node: ConversionOperatorMemberCrefSyntax): void;
        VisitCrefParameterList(node: CrefParameterListSyntax): void;
        VisitCrefBracketedParameterList(node: CrefBracketedParameterListSyntax): void;
        VisitCrefParameter(node: CrefParameterSyntax): void;
        VisitXmlElement(node: XmlElementSyntax): void;
        VisitXmlElementStartTag(node: XmlElementStartTagSyntax): void;
        VisitXmlElementEndTag(node: XmlElementEndTagSyntax): void;
        VisitXmlEmptyElement(node: XmlEmptyElementSyntax): void;
        VisitXmlName(node: XmlNameSyntax): void;
        VisitXmlPrefix(node: XmlPrefixSyntax): void;
        VisitXmlTextAttribute(node: XmlTextAttributeSyntax): void;
        VisitXmlCrefAttribute(node: XmlCrefAttributeSyntax): void;
        VisitXmlNameAttribute(node: XmlNameAttributeSyntax): void;
        VisitXmlText(node: XmlTextSyntax): void;
        VisitXmlCDataSection(node: XmlCDataSectionSyntax): void;
        VisitXmlProcessingInstruction(node: XmlProcessingInstructionSyntax): void;
        VisitXmlComment(node: XmlCommentSyntax): void;
        VisitIfDirectiveTrivia(node: IfDirectiveTriviaSyntax): void;
        VisitElifDirectiveTrivia(node: ElifDirectiveTriviaSyntax): void;
        VisitElseDirectiveTrivia(node: ElseDirectiveTriviaSyntax): void;
        VisitEndIfDirectiveTrivia(node: EndIfDirectiveTriviaSyntax): void;
        VisitRegionDirectiveTrivia(node: RegionDirectiveTriviaSyntax): void;
        VisitEndRegionDirectiveTrivia(node: EndRegionDirectiveTriviaSyntax): void;
        VisitErrorDirectiveTrivia(node: ErrorDirectiveTriviaSyntax): void;
        VisitWarningDirectiveTrivia(node: WarningDirectiveTriviaSyntax): void;
        VisitBadDirectiveTrivia(node: BadDirectiveTriviaSyntax): void;
        VisitDefineDirectiveTrivia(node: DefineDirectiveTriviaSyntax): void;
        VisitUndefDirectiveTrivia(node: UndefDirectiveTriviaSyntax): void;
        VisitLineDirectiveTrivia(node: LineDirectiveTriviaSyntax): void;
        VisitPragmaWarningDirectiveTrivia(node: PragmaWarningDirectiveTriviaSyntax): void;
        VisitPragmaChecksumDirectiveTrivia(node: PragmaChecksumDirectiveTriviaSyntax): void;
        VisitReferenceDirectiveTrivia(node: ReferenceDirectiveTriviaSyntax): void;
        VisitInterpolatedString(node: InterpolatedStringSyntax): void;
        VisitInterpolatedStringInsert(node: InterpolatedStringInsertSyntax): void;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class CSharpSyntaxRewriter extends CSharpSyntaxVisitor<CSharpSyntaxNode> {
        protected VisitIntoStructuredTrivia: boolean;
        ctor_2068(visitIntoStructuredTrivia?: boolean): CSharpSyntaxRewriter;
        VisitToken(token: SyntaxToken): CSharpSyntaxNode;
        VisitList_1459<TNode extends CSharpSyntaxNode>(list: SyntaxList<TNode>): SyntaxList<TNode>;
        VisitList_2124<TNode extends CSharpSyntaxNode>(list: SeparatedSyntaxList<TNode>): SeparatedSyntaxList<TNode>;
        VisitIdentifierName(node: IdentifierNameSyntax): CSharpSyntaxNode;
        VisitQualifiedName(node: QualifiedNameSyntax): CSharpSyntaxNode;
        VisitGenericName(node: GenericNameSyntax): CSharpSyntaxNode;
        VisitTypeArgumentList(node: TypeArgumentListSyntax): CSharpSyntaxNode;
        VisitAliasQualifiedName(node: AliasQualifiedNameSyntax): CSharpSyntaxNode;
        VisitPredefinedType(node: PredefinedTypeSyntax): CSharpSyntaxNode;
        VisitArrayType(node: ArrayTypeSyntax): CSharpSyntaxNode;
        VisitArrayRankSpecifier(node: ArrayRankSpecifierSyntax): CSharpSyntaxNode;
        VisitPointerType(node: PointerTypeSyntax): CSharpSyntaxNode;
        VisitNullableType(node: NullableTypeSyntax): CSharpSyntaxNode;
        VisitOmittedTypeArgument(node: OmittedTypeArgumentSyntax): CSharpSyntaxNode;
        VisitParenthesizedExpression(node: ParenthesizedExpressionSyntax): CSharpSyntaxNode;
        VisitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): CSharpSyntaxNode;
        VisitAwaitExpression(node: AwaitExpressionSyntax): CSharpSyntaxNode;
        VisitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): CSharpSyntaxNode;
        VisitMemberAccessExpression(node: MemberAccessExpressionSyntax): CSharpSyntaxNode;
        VisitConditionalAccessExpression(node: ConditionalAccessExpressionSyntax): CSharpSyntaxNode;
        VisitMemberBindingExpression(node: MemberBindingExpressionSyntax): CSharpSyntaxNode;
        VisitElementBindingExpression(node: ElementBindingExpressionSyntax): CSharpSyntaxNode;
        VisitImplicitElementAccess(node: ImplicitElementAccessSyntax): CSharpSyntaxNode;
        VisitBinaryExpression(node: BinaryExpressionSyntax): CSharpSyntaxNode;
        VisitAssignmentExpression(node: AssignmentExpressionSyntax): CSharpSyntaxNode;
        VisitConditionalExpression(node: ConditionalExpressionSyntax): CSharpSyntaxNode;
        VisitThisExpression(node: ThisExpressionSyntax): CSharpSyntaxNode;
        VisitBaseExpression(node: BaseExpressionSyntax): CSharpSyntaxNode;
        VisitLiteralExpression(node: LiteralExpressionSyntax): CSharpSyntaxNode;
        VisitMakeRefExpression(node: MakeRefExpressionSyntax): CSharpSyntaxNode;
        VisitRefTypeExpression(node: RefTypeExpressionSyntax): CSharpSyntaxNode;
        VisitRefValueExpression(node: RefValueExpressionSyntax): CSharpSyntaxNode;
        VisitCheckedExpression(node: CheckedExpressionSyntax): CSharpSyntaxNode;
        VisitDefaultExpression(node: DefaultExpressionSyntax): CSharpSyntaxNode;
        VisitTypeOfExpression(node: TypeOfExpressionSyntax): CSharpSyntaxNode;
        VisitSizeOfExpression(node: SizeOfExpressionSyntax): CSharpSyntaxNode;
        VisitInvocationExpression(node: InvocationExpressionSyntax): CSharpSyntaxNode;
        VisitElementAccessExpression(node: ElementAccessExpressionSyntax): CSharpSyntaxNode;
        VisitArgumentList(node: ArgumentListSyntax): CSharpSyntaxNode;
        VisitBracketedArgumentList(node: BracketedArgumentListSyntax): CSharpSyntaxNode;
        VisitArgument(node: ArgumentSyntax): CSharpSyntaxNode;
        VisitNameColon(node: NameColonSyntax): CSharpSyntaxNode;
        VisitCastExpression(node: CastExpressionSyntax): CSharpSyntaxNode;
        VisitAnonymousMethodExpression(node: AnonymousMethodExpressionSyntax): CSharpSyntaxNode;
        VisitSimpleLambdaExpression(node: SimpleLambdaExpressionSyntax): CSharpSyntaxNode;
        VisitParenthesizedLambdaExpression(node: ParenthesizedLambdaExpressionSyntax): CSharpSyntaxNode;
        VisitInitializerExpression(node: InitializerExpressionSyntax): CSharpSyntaxNode;
        VisitObjectCreationExpression(node: ObjectCreationExpressionSyntax): CSharpSyntaxNode;
        VisitAnonymousObjectMemberDeclarator(node: AnonymousObjectMemberDeclaratorSyntax): CSharpSyntaxNode;
        VisitAnonymousObjectCreationExpression(node: AnonymousObjectCreationExpressionSyntax): CSharpSyntaxNode;
        VisitArrayCreationExpression(node: ArrayCreationExpressionSyntax): CSharpSyntaxNode;
        VisitImplicitArrayCreationExpression(node: ImplicitArrayCreationExpressionSyntax): CSharpSyntaxNode;
        VisitStackAllocArrayCreationExpression(node: StackAllocArrayCreationExpressionSyntax): CSharpSyntaxNode;
        VisitQueryExpression(node: QueryExpressionSyntax): CSharpSyntaxNode;
        VisitQueryBody(node: QueryBodySyntax): CSharpSyntaxNode;
        VisitFromClause(node: FromClauseSyntax): CSharpSyntaxNode;
        VisitLetClause(node: LetClauseSyntax): CSharpSyntaxNode;
        VisitJoinClause(node: JoinClauseSyntax): CSharpSyntaxNode;
        VisitJoinIntoClause(node: JoinIntoClauseSyntax): CSharpSyntaxNode;
        VisitWhereClause(node: WhereClauseSyntax): CSharpSyntaxNode;
        VisitOrderByClause(node: OrderByClauseSyntax): CSharpSyntaxNode;
        VisitOrdering(node: OrderingSyntax): CSharpSyntaxNode;
        VisitSelectClause(node: SelectClauseSyntax): CSharpSyntaxNode;
        VisitGroupClause(node: GroupClauseSyntax): CSharpSyntaxNode;
        VisitQueryContinuation(node: QueryContinuationSyntax): CSharpSyntaxNode;
        VisitOmittedArraySizeExpression(node: OmittedArraySizeExpressionSyntax): CSharpSyntaxNode;
        VisitGlobalStatement(node: GlobalStatementSyntax): CSharpSyntaxNode;
        VisitBlock(node: BlockSyntax): CSharpSyntaxNode;
        VisitLocalDeclarationStatement(node: LocalDeclarationStatementSyntax): CSharpSyntaxNode;
        VisitVariableDeclaration(node: VariableDeclarationSyntax): CSharpSyntaxNode;
        VisitVariableDeclarator(node: VariableDeclaratorSyntax): CSharpSyntaxNode;
        VisitEqualsValueClause(node: EqualsValueClauseSyntax): CSharpSyntaxNode;
        VisitExpressionStatement(node: ExpressionStatementSyntax): CSharpSyntaxNode;
        VisitEmptyStatement(node: EmptyStatementSyntax): CSharpSyntaxNode;
        VisitLabeledStatement(node: LabeledStatementSyntax): CSharpSyntaxNode;
        VisitGotoStatement(node: GotoStatementSyntax): CSharpSyntaxNode;
        VisitBreakStatement(node: BreakStatementSyntax): CSharpSyntaxNode;
        VisitContinueStatement(node: ContinueStatementSyntax): CSharpSyntaxNode;
        VisitReturnStatement(node: ReturnStatementSyntax): CSharpSyntaxNode;
        VisitThrowStatement(node: ThrowStatementSyntax): CSharpSyntaxNode;
        VisitYieldStatement(node: YieldStatementSyntax): CSharpSyntaxNode;
        VisitWhileStatement(node: WhileStatementSyntax): CSharpSyntaxNode;
        VisitDoStatement(node: DoStatementSyntax): CSharpSyntaxNode;
        VisitForStatement(node: ForStatementSyntax): CSharpSyntaxNode;
        VisitForEachStatement(node: ForEachStatementSyntax): CSharpSyntaxNode;
        VisitUsingStatement(node: UsingStatementSyntax): CSharpSyntaxNode;
        VisitFixedStatement(node: FixedStatementSyntax): CSharpSyntaxNode;
        VisitCheckedStatement(node: CheckedStatementSyntax): CSharpSyntaxNode;
        VisitUnsafeStatement(node: UnsafeStatementSyntax): CSharpSyntaxNode;
        VisitLockStatement(node: LockStatementSyntax): CSharpSyntaxNode;
        VisitIfStatement(node: IfStatementSyntax): CSharpSyntaxNode;
        VisitElseClause(node: ElseClauseSyntax): CSharpSyntaxNode;
        VisitSwitchStatement(node: SwitchStatementSyntax): CSharpSyntaxNode;
        VisitSwitchSection(node: SwitchSectionSyntax): CSharpSyntaxNode;
        VisitCaseSwitchLabel(node: CaseSwitchLabelSyntax): CSharpSyntaxNode;
        VisitDefaultSwitchLabel(node: DefaultSwitchLabelSyntax): CSharpSyntaxNode;
        VisitTryStatement(node: TryStatementSyntax): CSharpSyntaxNode;
        VisitCatchClause(node: CatchClauseSyntax): CSharpSyntaxNode;
        VisitCatchDeclaration(node: CatchDeclarationSyntax): CSharpSyntaxNode;
        VisitCatchFilterClause(node: CatchFilterClauseSyntax): CSharpSyntaxNode;
        VisitFinallyClause(node: FinallyClauseSyntax): CSharpSyntaxNode;
        VisitCompilationUnit(node: CompilationUnitSyntax): CSharpSyntaxNode;
        VisitExternAliasDirective(node: ExternAliasDirectiveSyntax): CSharpSyntaxNode;
        VisitUsingDirective(node: UsingDirectiveSyntax): CSharpSyntaxNode;
        VisitNamespaceDeclaration(node: NamespaceDeclarationSyntax): CSharpSyntaxNode;
        VisitAttributeList(node: AttributeListSyntax): CSharpSyntaxNode;
        VisitAttributeTargetSpecifier(node: AttributeTargetSpecifierSyntax): CSharpSyntaxNode;
        VisitAttribute(node: AttributeSyntax): CSharpSyntaxNode;
        VisitAttributeArgumentList(node: AttributeArgumentListSyntax): CSharpSyntaxNode;
        VisitAttributeArgument(node: AttributeArgumentSyntax): CSharpSyntaxNode;
        VisitNameEquals(node: NameEqualsSyntax): CSharpSyntaxNode;
        VisitTypeParameterList(node: TypeParameterListSyntax): CSharpSyntaxNode;
        VisitTypeParameter(node: TypeParameterSyntax): CSharpSyntaxNode;
        VisitClassDeclaration(node: ClassDeclarationSyntax): CSharpSyntaxNode;
        VisitStructDeclaration(node: StructDeclarationSyntax): CSharpSyntaxNode;
        VisitInterfaceDeclaration(node: InterfaceDeclarationSyntax): CSharpSyntaxNode;
        VisitEnumDeclaration(node: EnumDeclarationSyntax): CSharpSyntaxNode;
        VisitDelegateDeclaration(node: DelegateDeclarationSyntax): CSharpSyntaxNode;
        VisitEnumMemberDeclaration(node: EnumMemberDeclarationSyntax): CSharpSyntaxNode;
        VisitBaseList(node: BaseListSyntax): CSharpSyntaxNode;
        VisitSimpleBaseType(node: SimpleBaseTypeSyntax): CSharpSyntaxNode;
        VisitTypeParameterConstraintClause(node: TypeParameterConstraintClauseSyntax): CSharpSyntaxNode;
        VisitConstructorConstraint(node: ConstructorConstraintSyntax): CSharpSyntaxNode;
        VisitClassOrStructConstraint(node: ClassOrStructConstraintSyntax): CSharpSyntaxNode;
        VisitTypeConstraint(node: TypeConstraintSyntax): CSharpSyntaxNode;
        VisitFieldDeclaration(node: FieldDeclarationSyntax): CSharpSyntaxNode;
        VisitEventFieldDeclaration(node: EventFieldDeclarationSyntax): CSharpSyntaxNode;
        VisitExplicitInterfaceSpecifier(node: ExplicitInterfaceSpecifierSyntax): CSharpSyntaxNode;
        VisitMethodDeclaration(node: MethodDeclarationSyntax): CSharpSyntaxNode;
        VisitOperatorDeclaration(node: OperatorDeclarationSyntax): CSharpSyntaxNode;
        VisitConversionOperatorDeclaration(node: ConversionOperatorDeclarationSyntax): CSharpSyntaxNode;
        VisitConstructorDeclaration(node: ConstructorDeclarationSyntax): CSharpSyntaxNode;
        VisitConstructorInitializer(node: ConstructorInitializerSyntax): CSharpSyntaxNode;
        VisitDestructorDeclaration(node: DestructorDeclarationSyntax): CSharpSyntaxNode;
        VisitPropertyDeclaration(node: PropertyDeclarationSyntax): CSharpSyntaxNode;
        VisitArrowExpressionClause(node: ArrowExpressionClauseSyntax): CSharpSyntaxNode;
        VisitEventDeclaration(node: EventDeclarationSyntax): CSharpSyntaxNode;
        VisitIndexerDeclaration(node: IndexerDeclarationSyntax): CSharpSyntaxNode;
        VisitAccessorList(node: AccessorListSyntax): CSharpSyntaxNode;
        VisitAccessorDeclaration(node: AccessorDeclarationSyntax): CSharpSyntaxNode;
        VisitParameterList(node: ParameterListSyntax): CSharpSyntaxNode;
        VisitBracketedParameterList(node: BracketedParameterListSyntax): CSharpSyntaxNode;
        VisitParameter(node: ParameterSyntax): CSharpSyntaxNode;
        VisitIncompleteMember(node: IncompleteMemberSyntax): CSharpSyntaxNode;
        VisitSkippedTokensTrivia(node: SkippedTokensTriviaSyntax): CSharpSyntaxNode;
        VisitDocumentationCommentTrivia(node: DocumentationCommentTriviaSyntax): CSharpSyntaxNode;
        VisitTypeCref(node: TypeCrefSyntax): CSharpSyntaxNode;
        VisitQualifiedCref(node: QualifiedCrefSyntax): CSharpSyntaxNode;
        VisitNameMemberCref(node: NameMemberCrefSyntax): CSharpSyntaxNode;
        VisitIndexerMemberCref(node: IndexerMemberCrefSyntax): CSharpSyntaxNode;
        VisitOperatorMemberCref(node: OperatorMemberCrefSyntax): CSharpSyntaxNode;
        VisitConversionOperatorMemberCref(node: ConversionOperatorMemberCrefSyntax): CSharpSyntaxNode;
        VisitCrefParameterList(node: CrefParameterListSyntax): CSharpSyntaxNode;
        VisitCrefBracketedParameterList(node: CrefBracketedParameterListSyntax): CSharpSyntaxNode;
        VisitCrefParameter(node: CrefParameterSyntax): CSharpSyntaxNode;
        VisitXmlElement(node: XmlElementSyntax): CSharpSyntaxNode;
        VisitXmlElementStartTag(node: XmlElementStartTagSyntax): CSharpSyntaxNode;
        VisitXmlElementEndTag(node: XmlElementEndTagSyntax): CSharpSyntaxNode;
        VisitXmlEmptyElement(node: XmlEmptyElementSyntax): CSharpSyntaxNode;
        VisitXmlName(node: XmlNameSyntax): CSharpSyntaxNode;
        VisitXmlPrefix(node: XmlPrefixSyntax): CSharpSyntaxNode;
        VisitXmlTextAttribute(node: XmlTextAttributeSyntax): CSharpSyntaxNode;
        VisitXmlCrefAttribute(node: XmlCrefAttributeSyntax): CSharpSyntaxNode;
        VisitXmlNameAttribute(node: XmlNameAttributeSyntax): CSharpSyntaxNode;
        VisitXmlText(node: XmlTextSyntax): CSharpSyntaxNode;
        VisitXmlCDataSection(node: XmlCDataSectionSyntax): CSharpSyntaxNode;
        VisitXmlProcessingInstruction(node: XmlProcessingInstructionSyntax): CSharpSyntaxNode;
        VisitXmlComment(node: XmlCommentSyntax): CSharpSyntaxNode;
        VisitIfDirectiveTrivia(node: IfDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitElifDirectiveTrivia(node: ElifDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitElseDirectiveTrivia(node: ElseDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitEndIfDirectiveTrivia(node: EndIfDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitRegionDirectiveTrivia(node: RegionDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitEndRegionDirectiveTrivia(node: EndRegionDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitErrorDirectiveTrivia(node: ErrorDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitWarningDirectiveTrivia(node: WarningDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitBadDirectiveTrivia(node: BadDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitDefineDirectiveTrivia(node: DefineDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitUndefDirectiveTrivia(node: UndefDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitLineDirectiveTrivia(node: LineDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitPragmaWarningDirectiveTrivia(node: PragmaWarningDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitPragmaChecksumDirectiveTrivia(node: PragmaChecksumDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitReferenceDirectiveTrivia(node: ReferenceDirectiveTriviaSyntax): CSharpSyntaxNode;
        VisitInterpolatedString(node: InterpolatedStringSyntax): CSharpSyntaxNode;
        VisitInterpolatedStringInsert(node: InterpolatedStringInsertSyntax): CSharpSyntaxNode;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxFirstTokenReplacer extends CSharpSyntaxRewriter {
        private oldToken;
        private newToken;
        private diagnosticOffsetDelta;
        private foundOldToken;
        ctor_3747(oldToken: SyntaxToken, newToken: SyntaxToken, diagnosticOffsetDelta: number): SyntaxFirstTokenReplacer;
        static Replace<TRoot extends CSharpSyntaxNode>(root: TRoot, oldToken: SyntaxToken, newToken: SyntaxToken, diagnosticOffsetDelta: number): TRoot;
        Visit(node: CSharpSyntaxNode): CSharpSyntaxNode;
        private static UpdateDiagnosticOffset<TSyntax>(node, diagnosticOffsetDelta);
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {
    class SyntaxLastTokenReplacer extends CSharpSyntaxRewriter {
        private oldToken;
        private newToken;
        private count;
        private found;
        ctor_5622(oldToken: SyntaxToken, newToken: SyntaxToken): SyntaxLastTokenReplacer;
        static Replace<TRoot extends CSharpSyntaxNode>(root: TRoot, newToken: SyntaxToken): TRoot;
        private static CountNonNullSlots(node);
        Visit(node: CSharpSyntaxNode): CSharpSyntaxNode;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SeparatedSyntaxListBuilder<TNode extends SyntaxNode> implements IStruct {
        private builder;
        private expectedSeparator;
        ctor_8478(size: number): SeparatedSyntaxListBuilder<TNode>;
        static Create<TNode extends SyntaxNode>(): SeparatedSyntaxListBuilder<TNode>;
        ctor_1989(builder: SyntaxListBaseBuilder): SeparatedSyntaxListBuilder<TNode>;
        IsNull: boolean;
        Count: number;
        Clear(): void;
        private CheckExpectedElement();
        private CheckExpectedSeparator();
        Add(node: TNode): SeparatedSyntaxListBuilder<TNode>;
        AddSeparator(separatorToken: SyntaxToken): SeparatedSyntaxListBuilder<TNode>;
        AddRange_1880(nodes: SeparatedSyntaxList<TNode>): SeparatedSyntaxListBuilder<TNode>;
        AddRange_9097(nodes: SeparatedSyntaxList<TNode>, count: number): SeparatedSyntaxListBuilder<TNode>;
        ToList_1421(): SeparatedSyntaxList<TNode>;
        ToList_2056<TDerived extends TNode>(): SeparatedSyntaxList<TDerived>;
        static op_Implicit_1343<TNode extends SyntaxNode>(builder: SeparatedSyntaxListBuilder<TNode>): SyntaxListBaseBuilder;
        static op_Implicit_4181<TNode extends SyntaxNode>(builder: SeparatedSyntaxListBuilder<TNode>): SeparatedSyntaxList<TNode>;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class SimpleSyntaxReference extends SyntaxReference {
        private node;
        ctor_7792(node: SyntaxNode): SimpleSyntaxReference;
        SyntaxTree: SyntaxTree;
        Span: Text.TextSpan;
        GetSyntax(cancellationToken: System.Threading.CancellationToken): SyntaxNode;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxEquivalence {
        static AreEquivalent_6608(before: SyntaxTree, after: SyntaxTree, ignoreChildNode: (_: SyntaxKind) => boolean, topLevel: boolean): boolean;
        static AreEquivalent_1123(before: SyntaxNode, after: SyntaxNode, ignoreChildNode: (_: SyntaxKind) => boolean, topLevel: boolean): boolean;
        static AreEquivalent_1097(before: SyntaxTokenList, after: SyntaxTokenList): boolean;
        static AreEquivalent_8521(before: SyntaxToken, after: SyntaxToken): boolean;
        private static AreTokensEquivalent(before, after);
        private static AreEquivalentRecursive(before, after, ignoreChildNode, topLevel);
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxFormatter extends CSharpSyntaxRewriter {
        private indentWhitespace;
        private useElasticTrivia;
        private isInStructuredTrivia;
        private previousToken;
        private indentNext;
        private afterLineBreak;
        private afterIndentation;
        private indentations;
        ctor_1134(indentWhitespace: string, useElasticTrivia: boolean): SyntaxFormatter;
        static Format_9806<TNode extends SyntaxNode>(node: TNode, indentWhitespace: string, useElasticTrivia?: boolean): TNode;
        static Format_1909(token: SyntaxToken, indentWhitespace: string, useElasticTrivia?: boolean): SyntaxToken;
        static Format_1809(trivia: SyntaxTriviaList, indentWhitespace: string, useElasticTrivia?: boolean): SyntaxTriviaList;
        private Free();
        VisitToken(token: SyntaxToken): SyntaxToken;
        private GetIndentation(count);
        private static LineBreaksAfter_3124(token);
        private LineBreaksAfter_5286(currentToken, nextToken);
        private static LineBreaksAfterCloseBrace(nextToken);
        private static LineBreaksAfterSemicolon(currentToken, nextToken);
        private NeedsSeparator(token, next);
        private static IsXmlTextToken(kind);
        private static BinaryTokenNeedsSeparator(kind);
        private static AssignmentTokenNeedsSeparator(kind);
        private RewriteTrivia(triviaList, depth, isTrailing, mustBeIndented, mustHaveSeparator, lineBreaksAfter);
        private static trimmedDocCommentExtertior;
        private GetSpace();
        private GetCarriageReturnLineFeed();
        private VisitStructuredTrivia(trivia);
        private static NeedsSeparatorBetween(trivia);
        private static NeedsLineBreakBetween(trivia, next, isTrailingTrivia);
        private static NeedsLineBreakBefore(trivia);
        private static NeedsLineBreakAfter(trivia, isTrailingTrivia);
        private static NeedsIndentAfterLineBreak(trivia);
        private static EndsInLineBreak_3346(token);
        private static EndsInLineBreak_1133(trivia);
        private static IsWord(kind);
        private static IsKeyword(kind);
        private static TokenCharacterCanBeDoubled(c);
        private static GetDeclarationDepth_1080(token);
        private static GetDeclarationDepth_1524(trivia);
        private static GetDeclarationDepth_1129(node);
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxListBase extends CSharpSyntaxNode {
        ctor_4023(green: Syntax.InternalSyntax.SyntaxListBase, parent: SyntaxNode, position: number): SyntaxListBase;
        constructor();
    }
    module SyntaxListBase {
        class SeparatedWithManyChildren extends SyntaxListBase {
            private children;
            ctor_2725(green: Syntax.InternalSyntax.SyntaxListBase, parent: SyntaxNode, position: number): SeparatedWithManyChildren;
            GetNodeSlot(i: number): SyntaxNode;
            GetCachedSlot(i: number): SyntaxNode;
            Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
            Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
            constructor();
        }
        class WithManyChildren extends SyntaxListBase {
            private children;
            ctor_3902(green: Syntax.InternalSyntax.SyntaxListBase, parent: SyntaxNode, position: number): WithManyChildren;
            GetNodeSlot(index: number): SyntaxNode;
            GetCachedSlot(index: number): SyntaxNode;
            Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
            Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
            constructor();
        }
        class WithManyWeakChildren extends SyntaxListBase {
            private children;
            private childPositions;
            ctor_1559(green: Syntax.InternalSyntax.SyntaxListBase.WithManyChildrenBase, parent: SyntaxNode, position: number): WithManyWeakChildren;
            GetChildPosition(index: number): number;
            GetNodeSlot(index: number): SyntaxNode;
            GetCachedSlot(index: number): SyntaxNode;
            Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
            Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
            constructor();
        }
        class WithThreeChildren extends SyntaxListBase {
            private child0;
            private child1;
            private child2;
            ctor_9136(green: Syntax.InternalSyntax.SyntaxListBase, parent: SyntaxNode, position: number): WithThreeChildren;
            GetNodeSlot(index: number): SyntaxNode;
            GetCachedSlot(index: number): SyntaxNode;
            Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
            Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
            constructor();
        }
        class WithTwoChildren extends SyntaxListBase {
            private child0;
            private child1;
            ctor_1567(green: Syntax.InternalSyntax.SyntaxListBase, parent: SyntaxNode, position: number): WithTwoChildren;
            GetNodeSlot(index: number): SyntaxNode;
            GetCachedSlot(index: number): SyntaxNode;
            Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult;
            Accept_1012(visitor: CSharpSyntaxVisitorBase): void;
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxListBaseBuilder {
        private nodes;
        Count: number;
        ctor_1860(size: number): SyntaxListBaseBuilder;
        Clear(): void;
        Add(item: SyntaxNode): void;
        AddInternal(item: GreenNode): void;
        AddRange_1539(items: SyntaxNode[]): void;
        AddRange_5502(items: SyntaxNode[], offset: number, length: number): void;
        private Validate(start, end);
        AddRange_1339(list: SyntaxList<SyntaxNode>): void;
        AddRange_6786(list: SyntaxList<SyntaxNode>, offset: number, count: number): void;
        AddRange_2002<TNode extends SyntaxNode>(list: SyntaxList<TNode>): void;
        AddRange_4324<TNode extends SyntaxNode>(list: SyntaxList<TNode>, offset: number, count: number): void;
        AddRange_7508(list: SyntaxNodeOrTokenList): void;
        AddRange_6190(list: SyntaxNodeOrTokenList, offset: number, count: number): void;
        AddRange_1343(list: SyntaxTokenList): void;
        AddRange_3866(list: SyntaxTokenList, offset: number, length: number): void;
        private Grow(size);
        Any(kind: SyntaxKind): boolean;
        ToListNode(): Syntax.InternalSyntax.CSharpSyntaxNode;
        static op_Implicit_5201(builder: SyntaxListBaseBuilder): SyntaxList<SyntaxNode>;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxListBuilderExtensions {
        static ToTokenList(builder: SyntaxListBaseBuilder): SyntaxTokenList;
        static ToList(builder: SyntaxListBaseBuilder): SyntaxList<SyntaxNode>;
        static ToSeparatedList<TNode extends SyntaxNode>(builder: SyntaxListBaseBuilder): SeparatedSyntaxList<TNode>;
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxListBuilder<TNode extends SyntaxNode> implements IStruct {
        private builder;
        ctor_7707(size: number): SyntaxListBuilder<TNode>;
        static Create<TNode extends SyntaxNode>(): SyntaxListBuilder<TNode>;
        ctor_1247(builder: SyntaxListBaseBuilder): SyntaxListBuilder<TNode>;
        IsNull: boolean;
        Count: number;
        Clear(): void;
        Add(node: TNode): SyntaxListBuilder<TNode>;
        AddRange_1628(items: TNode[], offset: number, length: number): void;
        AddRange_1067(nodes: SyntaxList<TNode>): void;
        AddRange_1900(nodes: SyntaxList<TNode>, offset: number, length: number): void;
        Any(kind: SyntaxKind): boolean;
        ToList(): SyntaxList<TNode>;
        static op_Implicit_1734<TNode extends SyntaxNode>(builder: SyntaxListBuilder<TNode>): SyntaxListBaseBuilder;
        static op_Implicit_3485<TNode extends SyntaxNode>(builder: SyntaxListBuilder<TNode>): SyntaxList<TNode>;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxNavigator extends AbstractSyntaxNavigator {
        static Instance: AbstractSyntaxNavigator;
        private static CommonSyntaxTriviaSkipped;
        private static StepIntoFunctions;
        protected GetStepIntoFunction(skipped: boolean, directives: boolean, docComments: boolean): (_: SyntaxTrivia) => boolean;
        static ToCommon_1495(func: (_: SyntaxTrivia) => boolean): (_: SyntaxTrivia) => boolean;
        static ToCommon_1089(func: (_: SyntaxToken) => boolean): (_: SyntaxToken) => boolean;
        constructor();
    }
    module SyntaxNavigator {
        enum SyntaxKinds {
            DocComments = 1,
            Directives = 2,
            SkippedTokens = 4,
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class SyntaxNodeExtensions {
        static WithAnnotations<TNode extends CSharpSyntaxNode>(node: TNode, ...annotations: SyntaxAnnotation[]): TNode;
        static WithAnnotations_Arr<TNode extends CSharpSyntaxNode>(node: TNode, annotations: SyntaxAnnotation[]): TNode;
        static IsAnonymousFunction(syntax: CSharpSyntaxNode): boolean;
        static IsQuery(syntax: CSharpSyntaxNode): boolean;
        static CanHaveAssociatedLocalBinder(syntax: CSharpSyntaxNode): boolean;
        static ExtractAnonymousTypeMemberName(input: Syntax.ExpressionSyntax): SyntaxToken;
        static GetReferenceOrNull(nodeOpt: CSharpSyntaxNode): SyntaxReference;
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxNodeOrTokenListBuilder {
        private nodes;
        private count;
        ctor_2261(size: number): SyntaxNodeOrTokenListBuilder;
        Count: number;
        Clear(): void;
        $get$(index: number): SyntaxNodeOrToken;
        $set$(index: number, value: SyntaxNodeOrToken): void;
        Add_9827(item: Syntax.InternalSyntax.CSharpSyntaxNode): void;
        Add_1846(item: SyntaxNodeOrToken): void;
        Add_2125(list: SyntaxNodeOrTokenList): void;
        Add_1317(list: SyntaxNodeOrTokenList, offset: number, length: number): void;
        Add_1490(nodeOrTokens: System.Collections.Generic.IEnumerable<SyntaxNodeOrToken>): void;
        RemoveLast(): void;
        private Grow(size);
        ToList(): SyntaxNodeOrTokenList;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxNodeRemover {
        static RemoveNodes<TRoot extends SyntaxNode>(root: TRoot, nodes: System.Collections.Generic.IEnumerable<SyntaxNode>, options: SyntaxRemoveOptions): TRoot;
    }
    module SyntaxNodeRemover {
        class SyntaxRemover extends CSharpSyntaxRewriter {
            private nodesToRemove;
            private options;
            private searchSpan;
            private residualTrivia;
            private directivesToKeep;
            ctor_5474(nodesToRemove: SyntaxNode[], options: SyntaxRemoveOptions): SyntaxRemover;
            private static ComputeTotalSpan(nodes);
            ResidualTrivia: SyntaxTriviaList;
            private AddResidualTrivia(trivia, requiresNewLine?);
            private AddEndOfLine();
            private static IsEndOfLine(trivia);
            private static HasEndOfLine(list);
            private IsForRemoval(node);
            private ShouldVisit(node);
            Visit(node: SyntaxNode): SyntaxNode;
            VisitToken(token: SyntaxToken): SyntaxToken;
            VisitList_2124<TNode extends SyntaxNode>(list: SeparatedSyntaxList<TNode>): SeparatedSyntaxList<TNode>;
            private AddTrivia_4505(node);
            private AddTrivia_3495(token, node);
            private AddTrivia_2265(node, token);
            private GetRemovedSpan(span, fullSpan);
            private AddDirectives(node, span);
            private static HasRelatedDirectives(directive);
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxReplacer {
        static Replace_2004<TNode extends SyntaxNode>(root: SyntaxNode, nodes?: System.Collections.Generic.IEnumerable<TNode>, computeReplacementNode?: (_: TNode, __: TNode) => SyntaxNode, tokens?: System.Collections.Generic.IEnumerable<SyntaxToken>, computeReplacementToken?: (_: SyntaxToken, __: SyntaxToken) => SyntaxToken, trivia?: System.Collections.Generic.IEnumerable<SyntaxTrivia>, computeReplacementTrivia?: (_: SyntaxTrivia, __: SyntaxTrivia) => SyntaxTrivia): SyntaxNode;
        static Replace_2079(root: SyntaxToken, nodes?: System.Collections.Generic.IEnumerable<SyntaxNode>, computeReplacementNode?: (_: SyntaxNode, __: SyntaxNode) => SyntaxNode, tokens?: System.Collections.Generic.IEnumerable<SyntaxToken>, computeReplacementToken?: (_: SyntaxToken, __: SyntaxToken) => SyntaxToken, trivia?: System.Collections.Generic.IEnumerable<SyntaxTrivia>, computeReplacementTrivia?: (_: SyntaxTrivia, __: SyntaxTrivia) => SyntaxTrivia): SyntaxToken;
        static ReplaceNodeInList(root: SyntaxNode, originalNode: SyntaxNode, newNodes: System.Collections.Generic.IEnumerable<SyntaxNode>): SyntaxNode;
        static InsertNodeInList(root: SyntaxNode, nodeInList: SyntaxNode, nodesToInsert: System.Collections.Generic.IEnumerable<SyntaxNode>, insertBefore: boolean): SyntaxNode;
        static ReplaceTokenInList(root: SyntaxNode, tokenInList: SyntaxToken, newTokens: System.Collections.Generic.IEnumerable<SyntaxToken>): SyntaxNode;
        static InsertTokenInList(root: SyntaxNode, tokenInList: SyntaxToken, newTokens: System.Collections.Generic.IEnumerable<SyntaxToken>, insertBefore: boolean): SyntaxNode;
        static ReplaceTriviaInList_1364(root: SyntaxNode, triviaInList: SyntaxTrivia, newTrivia: System.Collections.Generic.IEnumerable<SyntaxTrivia>): SyntaxNode;
        static InsertTriviaInList_8431(root: SyntaxNode, triviaInList: SyntaxTrivia, newTrivia: System.Collections.Generic.IEnumerable<SyntaxTrivia>, insertBefore: boolean): SyntaxNode;
        static ReplaceTriviaInList_1535(root: SyntaxToken, triviaInList: SyntaxTrivia, newTrivia: System.Collections.Generic.IEnumerable<SyntaxTrivia>): SyntaxToken;
        static InsertTriviaInList_2070(root: SyntaxToken, triviaInList: SyntaxTrivia, newTrivia: System.Collections.Generic.IEnumerable<SyntaxTrivia>, insertBefore: boolean): SyntaxToken;
        static GetItemNotListElementException(): System.InvalidOperationException;
    }
    module SyntaxReplacer {
        class Replacer<TNode extends SyntaxNode> extends CSharpSyntaxRewriter {
            private computeReplacementNode;
            private computeReplacementToken;
            private computeReplacementTrivia;
            private nodeSet;
            private tokenSet;
            private triviaSet;
            private spanSet;
            private totalSpan;
            private visitIntoStructuredTrivia1;
            private shouldVisitTrivia;
            ctor_1330(nodes: System.Collections.Generic.IEnumerable<TNode>, computeReplacementNode: (_: TNode, __: TNode) => SyntaxNode, tokens: System.Collections.Generic.IEnumerable<SyntaxToken>, computeReplacementToken: (_: SyntaxToken, __: SyntaxToken) => SyntaxToken, trivia: System.Collections.Generic.IEnumerable<SyntaxTrivia>, computeReplacementTrivia: (_: SyntaxTrivia, __: SyntaxTrivia) => SyntaxTrivia): Replacer<TNode>;
            private static NoNodes;
            private static NoTokens;
            private static NoTrivia;
            VisitIntoStructuredTrivia: boolean;
            HasWork: boolean;
            private static ComputeTotalSpan(spans);
            private ShouldVisit(span);
            Visit(node: SyntaxNode): SyntaxNode;
            VisitToken(token: SyntaxToken): SyntaxToken;
            VisitListElement_1457(trivia: SyntaxTrivia): SyntaxTrivia;
            constructor();
        }
    }
    module SyntaxReplacer {
        enum ListEditKind {
            InsertBefore = 0,
            InsertAfter = 1,
            Replace = 2,
        }
    }
    module SyntaxReplacer {
        class BaseListEditor extends CSharpSyntaxRewriter {
            private elementSpan;
            private visitTrivia;
            private visitIntoStructuredTrivia1;
            protected editKind: ListEditKind;
            ctor_3573(elementSpan: Text.TextSpan, editKind: ListEditKind, visitTrivia: boolean, visitIntoStructuredTrivia: boolean): BaseListEditor;
            VisitIntoStructuredTrivia: boolean;
            private ShouldVisit(span);
            Visit(node: SyntaxNode): SyntaxNode;
            VisitToken(token: SyntaxToken): SyntaxToken;
            VisitListElement_1457(trivia: SyntaxTrivia): SyntaxTrivia;
            constructor();
        }
    }
    module SyntaxReplacer {
        class NodeListEditor extends BaseListEditor {
            private originalNode;
            private newNodes;
            ctor_1468(originalNode: SyntaxNode, replacementNodes: System.Collections.Generic.IEnumerable<SyntaxNode>, editKind: ListEditKind): NodeListEditor;
            Visit(node: SyntaxNode): SyntaxNode;
            VisitList_2124<TNode extends SyntaxNode>(list: SeparatedSyntaxList<TNode>): SeparatedSyntaxList<TNode>;
            VisitList_2124_R<TNode extends SyntaxNode>(type: {
                prototype: TNode;
            }, list: SeparatedSyntaxList<TNode>): SeparatedSyntaxList<TNode>;
            VisitList_1459<TNode extends SyntaxNode>(list: SyntaxList<TNode>): SyntaxList<TNode>;
            VisitList_1459_R<TNode extends SyntaxNode>(type: {
                prototype: TNode;
            }, list: SyntaxList<TNode>): SyntaxList<TNode>;
            constructor();
        }
    }
    module SyntaxReplacer {
        class TokenListEditor extends BaseListEditor {
            private originalToken;
            private newTokens;
            ctor_8760(originalToken: SyntaxToken, newTokens: System.Collections.Generic.IEnumerable<SyntaxToken>, editKind: ListEditKind): TokenListEditor;
            VisitToken(token: SyntaxToken): SyntaxToken;
            VisitList_2127(list: SyntaxTokenList): SyntaxTokenList;
            constructor();
        }
    }
    module SyntaxReplacer {
        class TriviaListEditor extends BaseListEditor {
            private originalTrivia;
            private newTrivia;
            ctor_5032(originalTrivia: SyntaxTrivia, newTrivia: System.Collections.Generic.IEnumerable<SyntaxTrivia>, editKind: ListEditKind): TriviaListEditor;
            VisitList_8614(list: SyntaxTriviaList): SyntaxTriviaList;
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxTokenListBuilder {
        private nodes;
        private count;
        ctor_9494(size: number): SyntaxTokenListBuilder;
        static Create(): SyntaxTokenListBuilder;
        Count: number;
        Add_1167(item: SyntaxToken): void;
        Add_1167_NS(item: Syntax.InternalSyntax.SyntaxToken): void;
        Add_3746(list: SyntaxTokenList): void;
        Add_1909(list: SyntaxTokenList, offset: number, length: number): void;
        Add_1573(list: SyntaxToken[]): void;
        Add_1911(list: SyntaxToken[], offset: number, length: number): void;
        private CheckSpace(delta);
        private Grow(newSize);
        ToList(): SyntaxTokenList;
        static op_Implicit_2014(builder: SyntaxTokenListBuilder): SyntaxTokenList;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class SyntaxTreeDiagnosticEnumerator implements IStruct {
        private syntaxTree;
        private stack;
        private current;
        private position;
        private static DefaultStackCapacity;
        ctor_1274(syntaxTree: SyntaxTree, node: GreenNode, position: number): SyntaxTreeDiagnosticEnumerator;
        MoveNext(): boolean;
        Current: Diagnostic;
        constructor();
    }
    module SyntaxTreeDiagnosticEnumerator {
        class NodeIteration implements IStruct {
            Node: GreenNode;
            DiagnosticIndex: number;
            SlotIndex: number;
            ctor_1131(node: GreenNode): NodeIteration;
            constructor();
        }
    }
    module SyntaxTreeDiagnosticEnumerator {
        class NodeIterationStack implements IStruct {
            private stack;
            private count;
            ctor_1146(capacity: number): NodeIterationStack;
            PushNodeOrToken(node: GreenNode): void;
            private PushToken(token);
            private Push(node);
            Pop(): void;
            Any(): boolean;
            Top: NodeIteration;
            $get$(index: number): NodeIteration;
            UpdateSlotIndexForStackTop(slotIndex: number): void;
            UpdateDiagnosticIndexForStackTop(diagnosticIndex: number): void;
            constructor();
        }
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class SyntaxTriviaFunctions {
        static Any: (_: SyntaxTrivia) => boolean;
        static Skipped: (_: SyntaxTrivia) => boolean;
    }
}
declare module Microsoft.CodeAnalysis.CSharp.Syntax {
    class SyntaxTriviaListBuilder {
        private nodes;
        private count;
        private previous;
        ctor_9798(size: number): SyntaxTriviaListBuilder;
        static Create(): SyntaxTriviaListBuilder;
        Count: number;
        Clear(): void;
        $get$(index: number): SyntaxTrivia;
        Add_1150(item: SyntaxTrivia): SyntaxTriviaListBuilder;
        Add_1125(items: SyntaxTrivia[]): void;
        Add_1449(items: SyntaxTrivia[], offset: number, length: number): void;
        Add_1553(list: SyntaxTriviaList): void;
        Add_5102(list: SyntaxTriviaList, offset: number, length: number): void;
        private Grow(size);
        static op_Implicit_1293(builder: SyntaxTriviaListBuilder): SyntaxTriviaList;
        ToList(): SyntaxTriviaList;
        constructor();
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class FunctionExtensions {
        static TransitiveClosure<T>(relation: (_: T) => System.Collections.Generic.IEnumerable<T>, item: T): System.Collections.Generic.HashSet<T>;
        static ToLanguageSpecific_2139(predicate: (_: SyntaxToken) => boolean): (_: SyntaxToken) => boolean;
        static ToLanguageSpecific_1552(predicate: (_: SyntaxTrivia) => boolean): (_: SyntaxTrivia) => boolean;
    }
}
declare module Microsoft.CodeAnalysis.CSharp {
    class StringExtensions {
        static First(value: string): string;
        static Last(value: string): string;
    }
}
