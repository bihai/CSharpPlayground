///<reference path="../Syntax/Internal/SyntaxNode.ts"/>

///<reference path="../Syntax/Internal/StructuredTriviaSyntax.ts"/>
///<reference path="../Syntax/Internal/DirectiveTriviaSyntax.ts"/>


module Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax {


    export class ExpressionSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_1005(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ExpressionSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_7190(kind: SyntaxKind): ExpressionSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_1102(reader: Roslyn.Utilities.ObjectReader): ExpressionSyntax {
            super.ctor_4942(reader);
            return this;
        }
    }

    export class TypeSyntax extends ExpressionSyntax {
        constructor() { super(); }
        ctor_1049(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            return this;
        }
        ctor_2121(kind: SyntaxKind): TypeSyntax {
            super.ctor_7190(kind);
            return this;
        }

        ctor_6805(reader: Roslyn.Utilities.ObjectReader): TypeSyntax {
            super.ctor_1102(reader);
            return this;
        }
    }

    export class MemberDeclarationSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_1870(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MemberDeclarationSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_9655(kind: SyntaxKind): MemberDeclarationSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_3031(reader: Roslyn.Utilities.ObjectReader): MemberDeclarationSyntax {
            super.ctor_4942(reader);
            return this;
        }
    }

    export class NameSyntax extends TypeSyntax {
        constructor() { super(); }
        ctor_3444(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NameSyntax {
            super.ctor_1049(kind, diagnostics, annotations);
            return this;
        }
        ctor_1783(kind: SyntaxKind): NameSyntax {
            super.ctor_2121(kind);
            return this;
        }

        ctor_1133(reader: Roslyn.Utilities.ObjectReader): NameSyntax {
            super.ctor_6805(reader);
            return this;
        }
    }

    export class SimpleNameSyntax extends NameSyntax {
        constructor() { super(); }
        ctor_1424(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SimpleNameSyntax {
            super.ctor_3444(kind, diagnostics, annotations);
            return this;
        }
        ctor_3429(kind: SyntaxKind): SimpleNameSyntax {
            super.ctor_1783(kind);
            return this;
        }

        ctor_1404(reader: Roslyn.Utilities.ObjectReader): SimpleNameSyntax {
            super.ctor_1133(reader);
            return this;
        }

        public Identifier: SyntaxToken;
    }

    export class IdentifierNameSyntax extends SimpleNameSyntax {
        identifier: SyntaxToken;

        constructor() { super(); }
        ctor_1875(kind: SyntaxKind, identifier: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IdentifierNameSyntax {
            super.ctor_1424(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            return this;
        }


        ctor_3802(kind: SyntaxKind, identifier: SyntaxToken, context: SyntaxFactoryContext): IdentifierNameSyntax {
            super.ctor_3429(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            return this;
        }


        ctor_1665(kind: SyntaxKind, identifier: SyntaxToken): IdentifierNameSyntax {
            super.ctor_3429(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            return this;
        }

        public get Identifier(): SyntaxToken { return this.identifier; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.identifier;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.IdentifierNameSyntax().ctor_1588(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitIdentifierName(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitIdentifierName(this);
        }

        public Update(identifier: SyntaxToken): IdentifierNameSyntax {
            if (identifier != this.Identifier) {
                var newNode = SyntaxFactory.IdentifierName(identifier);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new IdentifierNameSyntax().ctor_1875(this.Kind, this.identifier, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new IdentifierNameSyntax().ctor_1875(this.Kind, this.identifier, this.GetDiagnostics(), annotations);
        }

        public ctor_2134(reader: Roslyn.Utilities.ObjectReader): IdentifierNameSyntax {
            super.ctor_1404(reader);
            this.SlotCount = 1;
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.identifier);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new IdentifierNameSyntax().ctor_2134(r);
        }
    }

    export class QualifiedNameSyntax extends NameSyntax {
        left: NameSyntax;
        dotToken: SyntaxToken;
        right: SimpleNameSyntax;

        constructor() { super(); }
        ctor_1516(kind: SyntaxKind, left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QualifiedNameSyntax {
            super.ctor_3444(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
            return this;
        }


        ctor_7156(kind: SyntaxKind, left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax, context: SyntaxFactoryContext): QualifiedNameSyntax {
            super.ctor_1783(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
            return this;
        }


        ctor_9191(kind: SyntaxKind, left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax): QualifiedNameSyntax {
            super.ctor_1783(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
            return this;
        }

        public get Left(): NameSyntax { return this.left; }
        public get DotToken(): SyntaxToken { return this.dotToken; }
        public get Right(): SimpleNameSyntax { return this.right; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.left;
                case 1: return this.dotToken;
                case 2: return this.right;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.QualifiedNameSyntax().ctor_5378(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitQualifiedName(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitQualifiedName(this);
        }

        public Update(left: NameSyntax, dotToken: SyntaxToken, right: SimpleNameSyntax): QualifiedNameSyntax {
            if (left != this.Left || dotToken != this.DotToken || right != this.Right) {
                var newNode = SyntaxFactory.QualifiedName(left, dotToken, right);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new QualifiedNameSyntax().ctor_1516(this.Kind, this.left, this.dotToken, this.right, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new QualifiedNameSyntax().ctor_1516(this.Kind, this.left, this.dotToken, this.right, this.GetDiagnostics(), annotations);
        }

        public ctor_2446(reader: Roslyn.Utilities.ObjectReader): QualifiedNameSyntax {
            super.ctor_1133(reader);
            this.SlotCount = 3;
            var left = <NameSyntax>reader.ReadValue();
            if (left != null) {
                this.AdjustFlagsAndWidth(left);
                this.left = left;
                return this;
            }
            var dotToken = <SyntaxToken>reader.ReadValue();
            if (dotToken != null) {
                this.AdjustFlagsAndWidth(dotToken);
                this.dotToken = dotToken;
                return this;
            }
            var right = <SimpleNameSyntax>reader.ReadValue();
            if (right != null) {
                this.AdjustFlagsAndWidth(right);
                this.right = right;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.dotToken);
            writer.WriteValue(this.right);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new QualifiedNameSyntax().ctor_2446(r);
        }
    }

    export class GenericNameSyntax extends SimpleNameSyntax {
        identifier: SyntaxToken;
        typeArgumentList: TypeArgumentListSyntax;

        constructor() { super(); }
        ctor_9310(kind: SyntaxKind, identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): GenericNameSyntax {
            super.ctor_1424(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
            return this;
        }


        ctor_1555(kind: SyntaxKind, identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax, context: SyntaxFactoryContext): GenericNameSyntax {
            super.ctor_3429(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
            return this;
        }


        ctor_9369(kind: SyntaxKind, identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax): GenericNameSyntax {
            super.ctor_3429(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
            return this;
        }

        public get Identifier(): SyntaxToken { return this.identifier; }
        public get TypeArgumentList(): TypeArgumentListSyntax { return this.typeArgumentList; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.identifier;
                case 1: return this.typeArgumentList;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.GenericNameSyntax().ctor_1471(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitGenericName(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitGenericName(this);
        }

        public Update(identifier: SyntaxToken, typeArgumentList: TypeArgumentListSyntax): GenericNameSyntax {
            if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList) {
                var newNode = SyntaxFactory.GenericName(identifier, typeArgumentList);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new GenericNameSyntax().ctor_9310(this.Kind, this.identifier, this.typeArgumentList, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new GenericNameSyntax().ctor_9310(this.Kind, this.identifier, this.typeArgumentList, this.GetDiagnostics(), annotations);
        }

        public ctor_1546(reader: Roslyn.Utilities.ObjectReader): GenericNameSyntax {
            super.ctor_1404(reader);
            this.SlotCount = 2;
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var typeArgumentList = <TypeArgumentListSyntax>reader.ReadValue();
            if (typeArgumentList != null) {
                this.AdjustFlagsAndWidth(typeArgumentList);
                this.typeArgumentList = typeArgumentList;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeArgumentList);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new GenericNameSyntax().ctor_1546(r);
        }
    }

    export class TypeArgumentListSyntax extends CSharpSyntaxNode {
        lessThanToken: SyntaxToken;
        arguments: CSharpSyntaxNode;
        greaterThanToken: SyntaxToken;

        constructor() { super(); }
        ctor_1878(kind: SyntaxKind, lessThanToken: SyntaxToken, arguments: CSharpSyntaxNode, greaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeArgumentListSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }


        ctor_1481(kind: SyntaxKind, lessThanToken: SyntaxToken, arguments: CSharpSyntaxNode, greaterThanToken: SyntaxToken, context: SyntaxFactoryContext): TypeArgumentListSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }


        ctor_1421(kind: SyntaxKind, lessThanToken: SyntaxToken, arguments: CSharpSyntaxNode, greaterThanToken: SyntaxToken): TypeArgumentListSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }

        public get LessThanToken(): SyntaxToken { return this.lessThanToken; }
        public get Arguments(): SeparatedSyntaxList<TypeSyntax> { return new SeparatedSyntaxList<TypeSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.arguments)); }
        public get GreaterThanToken(): SyntaxToken { return this.greaterThanToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.lessThanToken;
                case 1: return this.arguments;
                case 2: return this.greaterThanToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.TypeArgumentListSyntax().ctor_1247(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitTypeArgumentList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitTypeArgumentList(this);
        }

        public Update(lessThanToken: SyntaxToken, arguments: SeparatedSyntaxList<TypeSyntax>, greaterThanToken: SyntaxToken): TypeArgumentListSyntax {
            if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken) {
                var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new TypeArgumentListSyntax().ctor_1878(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new TypeArgumentListSyntax().ctor_1878(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, this.GetDiagnostics(), annotations);
        }

        public ctor_8074(reader: Roslyn.Utilities.ObjectReader): TypeArgumentListSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var lessThanToken = <SyntaxToken>reader.ReadValue();
            if (lessThanToken != null) {
                this.AdjustFlagsAndWidth(lessThanToken);
                this.lessThanToken = lessThanToken;
                return this;
            }
            var arguments = <CSharpSyntaxNode>reader.ReadValue();
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
                return this;
            }
            var greaterThanToken = <SyntaxToken>reader.ReadValue();
            if (greaterThanToken != null) {
                this.AdjustFlagsAndWidth(greaterThanToken);
                this.greaterThanToken = greaterThanToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.greaterThanToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new TypeArgumentListSyntax().ctor_8074(r);
        }
    }

    export class AliasQualifiedNameSyntax extends NameSyntax {
        alias: IdentifierNameSyntax;
        colonColonToken: SyntaxToken;
        name: SimpleNameSyntax;

        constructor() { super(); }
        ctor_2811(kind: SyntaxKind, alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AliasQualifiedNameSyntax {
            super.ctor_3444(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
            this.AdjustFlagsAndWidth(colonColonToken);
            this.colonColonToken = colonColonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            return this;
        }


        ctor_6279(kind: SyntaxKind, alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax, context: SyntaxFactoryContext): AliasQualifiedNameSyntax {
            super.ctor_1783(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
            this.AdjustFlagsAndWidth(colonColonToken);
            this.colonColonToken = colonColonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            return this;
        }


        ctor_1992(kind: SyntaxKind, alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax): AliasQualifiedNameSyntax {
            super.ctor_1783(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
            this.AdjustFlagsAndWidth(colonColonToken);
            this.colonColonToken = colonColonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            return this;
        }

        public get Alias(): IdentifierNameSyntax { return this.alias; }
        public get ColonColonToken(): SyntaxToken { return this.colonColonToken; }
        public get Name(): SimpleNameSyntax { return this.name; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.alias;
                case 1: return this.colonColonToken;
                case 2: return this.name;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AliasQualifiedNameSyntax().ctor_1535(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAliasQualifiedName(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAliasQualifiedName(this);
        }

        public Update(alias: IdentifierNameSyntax, colonColonToken: SyntaxToken, name: SimpleNameSyntax): AliasQualifiedNameSyntax {
            if (alias != this.Alias || colonColonToken != this.ColonColonToken || name != this.Name) {
                var newNode = SyntaxFactory.AliasQualifiedName(alias, colonColonToken, name);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AliasQualifiedNameSyntax().ctor_2811(this.Kind, this.alias, this.colonColonToken, this.name, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AliasQualifiedNameSyntax().ctor_2811(this.Kind, this.alias, this.colonColonToken, this.name, this.GetDiagnostics(), annotations);
        }

        public ctor_2052(reader: Roslyn.Utilities.ObjectReader): AliasQualifiedNameSyntax {
            super.ctor_1133(reader);
            this.SlotCount = 3;
            var alias = <IdentifierNameSyntax>reader.ReadValue();
            if (alias != null) {
                this.AdjustFlagsAndWidth(alias);
                this.alias = alias;
                return this;
            }
            var colonColonToken = <SyntaxToken>reader.ReadValue();
            if (colonColonToken != null) {
                this.AdjustFlagsAndWidth(colonColonToken);
                this.colonColonToken = colonColonToken;
                return this;
            }
            var name = <SimpleNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.alias);
            writer.WriteValue(this.colonColonToken);
            writer.WriteValue(this.name);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AliasQualifiedNameSyntax().ctor_2052(r);
        }
    }

    export class PredefinedTypeSyntax extends TypeSyntax {
        keyword: SyntaxToken;

        constructor() { super(); }
        ctor_7418(kind: SyntaxKind, keyword: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PredefinedTypeSyntax {
            super.ctor_1049(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            return this;
        }


        ctor_6017(kind: SyntaxKind, keyword: SyntaxToken, context: SyntaxFactoryContext): PredefinedTypeSyntax {
            super.ctor_2121(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            return this;
        }


        ctor_4867(kind: SyntaxKind, keyword: SyntaxToken): PredefinedTypeSyntax {
            super.ctor_2121(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.PredefinedTypeSyntax().ctor_1442(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitPredefinedType(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitPredefinedType(this);
        }

        public Update(keyword: SyntaxToken): PredefinedTypeSyntax {
            if (keyword != this.Keyword) {
                var newNode = SyntaxFactory.PredefinedType(keyword);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new PredefinedTypeSyntax().ctor_7418(this.Kind, this.keyword, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new PredefinedTypeSyntax().ctor_7418(this.Kind, this.keyword, this.GetDiagnostics(), annotations);
        }

        public ctor_7075(reader: Roslyn.Utilities.ObjectReader): PredefinedTypeSyntax {
            super.ctor_6805(reader);
            this.SlotCount = 1;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new PredefinedTypeSyntax().ctor_7075(r);
        }
    }

    export class ArrayTypeSyntax extends TypeSyntax {
        elementType: TypeSyntax;
        rankSpecifiers: CSharpSyntaxNode;

        constructor() { super(); }
        ctor_1849(kind: SyntaxKind, elementType: TypeSyntax, rankSpecifiers: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArrayTypeSyntax {
            super.ctor_1049(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            if (rankSpecifiers != null) {
                this.AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
            return this;
        }


        ctor_9992(kind: SyntaxKind, elementType: TypeSyntax, rankSpecifiers: CSharpSyntaxNode, context: SyntaxFactoryContext): ArrayTypeSyntax {
            super.ctor_2121(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            if (rankSpecifiers != null) {
                this.AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
            return this;
        }


        ctor_3609(kind: SyntaxKind, elementType: TypeSyntax, rankSpecifiers: CSharpSyntaxNode): ArrayTypeSyntax {
            super.ctor_2121(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            if (rankSpecifiers != null) {
                this.AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
            return this;
        }

        public get ElementType(): TypeSyntax { return this.elementType; }
        public get RankSpecifiers(): SyntaxList<ArrayRankSpecifierSyntax> { return new SyntaxList<ArrayRankSpecifierSyntax>().ctor_1319(this.rankSpecifiers); }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.elementType;
                case 1: return this.rankSpecifiers;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ArrayTypeSyntax().ctor_4307(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitArrayType(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitArrayType(this);
        }

        public Update(elementType: TypeSyntax, rankSpecifiers: SyntaxList<ArrayRankSpecifierSyntax>): ArrayTypeSyntax {
            if (elementType != this.ElementType || rankSpecifiers != this.RankSpecifiers) {
                var newNode = SyntaxFactory.ArrayType(elementType, rankSpecifiers);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ArrayTypeSyntax().ctor_1849(this.Kind, this.elementType, this.rankSpecifiers, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ArrayTypeSyntax().ctor_1849(this.Kind, this.elementType, this.rankSpecifiers, this.GetDiagnostics(), annotations);
        }

        public ctor_1768(reader: Roslyn.Utilities.ObjectReader): ArrayTypeSyntax {
            super.ctor_6805(reader);
            this.SlotCount = 2;
            var elementType = <TypeSyntax>reader.ReadValue();
            if (elementType != null) {
                this.AdjustFlagsAndWidth(elementType);
                this.elementType = elementType;
                return this;
            }
            var rankSpecifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (rankSpecifiers != null) {
                this.AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.elementType);
            writer.WriteValue(this.rankSpecifiers);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ArrayTypeSyntax().ctor_1768(r);
        }
    }

    export class ArrayRankSpecifierSyntax extends CSharpSyntaxNode {
        openBracketToken: SyntaxToken;
        sizes: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;

        constructor() { super(); }
        ctor_1933(kind: SyntaxKind, openBracketToken: SyntaxToken, sizes: CSharpSyntaxNode, closeBracketToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArrayRankSpecifierSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (sizes != null) {
                this.AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }


        ctor_1202(kind: SyntaxKind, openBracketToken: SyntaxToken, sizes: CSharpSyntaxNode, closeBracketToken: SyntaxToken, context: SyntaxFactoryContext): ArrayRankSpecifierSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (sizes != null) {
                this.AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }


        ctor_5670(kind: SyntaxKind, openBracketToken: SyntaxToken, sizes: CSharpSyntaxNode, closeBracketToken: SyntaxToken): ArrayRankSpecifierSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (sizes != null) {
                this.AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }

        public get OpenBracketToken(): SyntaxToken { return this.openBracketToken; }
        public get Sizes(): SeparatedSyntaxList<ExpressionSyntax> { return new SeparatedSyntaxList<ExpressionSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.sizes)); }
        public get CloseBracketToken(): SyntaxToken { return this.closeBracketToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openBracketToken;
                case 1: return this.sizes;
                case 2: return this.closeBracketToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ArrayRankSpecifierSyntax().ctor_5824(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitArrayRankSpecifier(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitArrayRankSpecifier(this);
        }

        public Update(openBracketToken: SyntaxToken, sizes: SeparatedSyntaxList<ExpressionSyntax>, closeBracketToken: SyntaxToken): ArrayRankSpecifierSyntax {
            if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken) {
                var newNode = SyntaxFactory.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ArrayRankSpecifierSyntax().ctor_1933(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ArrayRankSpecifierSyntax().ctor_1933(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, this.GetDiagnostics(), annotations);
        }

        public ctor_6695(reader: Roslyn.Utilities.ObjectReader): ArrayRankSpecifierSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var openBracketToken = <SyntaxToken>reader.ReadValue();
            if (openBracketToken != null) {
                this.AdjustFlagsAndWidth(openBracketToken);
                this.openBracketToken = openBracketToken;
                return this;
            }
            var sizes = <CSharpSyntaxNode>reader.ReadValue();
            if (sizes != null) {
                this.AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
                return this;
            }
            var closeBracketToken = <SyntaxToken>reader.ReadValue();
            if (closeBracketToken != null) {
                this.AdjustFlagsAndWidth(closeBracketToken);
                this.closeBracketToken = closeBracketToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.sizes);
            writer.WriteValue(this.closeBracketToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ArrayRankSpecifierSyntax().ctor_6695(r);
        }
    }

    export class PointerTypeSyntax extends TypeSyntax {
        elementType: TypeSyntax;
        asteriskToken: SyntaxToken;

        constructor() { super(); }
        ctor_7651(kind: SyntaxKind, elementType: TypeSyntax, asteriskToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PointerTypeSyntax {
            super.ctor_1049(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            return this;
        }


        ctor_2731(kind: SyntaxKind, elementType: TypeSyntax, asteriskToken: SyntaxToken, context: SyntaxFactoryContext): PointerTypeSyntax {
            super.ctor_2121(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            return this;
        }


        ctor_1332(kind: SyntaxKind, elementType: TypeSyntax, asteriskToken: SyntaxToken): PointerTypeSyntax {
            super.ctor_2121(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            return this;
        }

        public get ElementType(): TypeSyntax { return this.elementType; }
        public get AsteriskToken(): SyntaxToken { return this.asteriskToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.elementType;
                case 1: return this.asteriskToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.PointerTypeSyntax().ctor_6866(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitPointerType(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitPointerType(this);
        }

        public Update(elementType: TypeSyntax, asteriskToken: SyntaxToken): PointerTypeSyntax {
            if (elementType != this.ElementType || asteriskToken != this.AsteriskToken) {
                var newNode = SyntaxFactory.PointerType(elementType, asteriskToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new PointerTypeSyntax().ctor_7651(this.Kind, this.elementType, this.asteriskToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new PointerTypeSyntax().ctor_7651(this.Kind, this.elementType, this.asteriskToken, this.GetDiagnostics(), annotations);
        }

        public ctor_5210(reader: Roslyn.Utilities.ObjectReader): PointerTypeSyntax {
            super.ctor_6805(reader);
            this.SlotCount = 2;
            var elementType = <TypeSyntax>reader.ReadValue();
            if (elementType != null) {
                this.AdjustFlagsAndWidth(elementType);
                this.elementType = elementType;
                return this;
            }
            var asteriskToken = <SyntaxToken>reader.ReadValue();
            if (asteriskToken != null) {
                this.AdjustFlagsAndWidth(asteriskToken);
                this.asteriskToken = asteriskToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.elementType);
            writer.WriteValue(this.asteriskToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new PointerTypeSyntax().ctor_5210(r);
        }
    }

    export class NullableTypeSyntax extends TypeSyntax {
        elementType: TypeSyntax;
        questionToken: SyntaxToken;

        constructor() { super(); }
        ctor_8251(kind: SyntaxKind, elementType: TypeSyntax, questionToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NullableTypeSyntax {
            super.ctor_1049(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            return this;
        }


        ctor_1091(kind: SyntaxKind, elementType: TypeSyntax, questionToken: SyntaxToken, context: SyntaxFactoryContext): NullableTypeSyntax {
            super.ctor_2121(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            return this;
        }


        ctor_1751(kind: SyntaxKind, elementType: TypeSyntax, questionToken: SyntaxToken): NullableTypeSyntax {
            super.ctor_2121(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            return this;
        }

        public get ElementType(): TypeSyntax { return this.elementType; }
        public get QuestionToken(): SyntaxToken { return this.questionToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.elementType;
                case 1: return this.questionToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.NullableTypeSyntax().ctor_6515(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitNullableType(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitNullableType(this);
        }

        public Update(elementType: TypeSyntax, questionToken: SyntaxToken): NullableTypeSyntax {
            if (elementType != this.ElementType || questionToken != this.QuestionToken) {
                var newNode = SyntaxFactory.NullableType(elementType, questionToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new NullableTypeSyntax().ctor_8251(this.Kind, this.elementType, this.questionToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new NullableTypeSyntax().ctor_8251(this.Kind, this.elementType, this.questionToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1772(reader: Roslyn.Utilities.ObjectReader): NullableTypeSyntax {
            super.ctor_6805(reader);
            this.SlotCount = 2;
            var elementType = <TypeSyntax>reader.ReadValue();
            if (elementType != null) {
                this.AdjustFlagsAndWidth(elementType);
                this.elementType = elementType;
                return this;
            }
            var questionToken = <SyntaxToken>reader.ReadValue();
            if (questionToken != null) {
                this.AdjustFlagsAndWidth(questionToken);
                this.questionToken = questionToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.elementType);
            writer.WriteValue(this.questionToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new NullableTypeSyntax().ctor_1772(r);
        }
    }

    export class OmittedTypeArgumentSyntax extends TypeSyntax {
        omittedTypeArgumentToken: SyntaxToken;

        constructor() { super(); }
        ctor_1834(kind: SyntaxKind, omittedTypeArgumentToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OmittedTypeArgumentSyntax {
            super.ctor_1049(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
            this.omittedTypeArgumentToken = omittedTypeArgumentToken;
            return this;
        }


        ctor_1437(kind: SyntaxKind, omittedTypeArgumentToken: SyntaxToken, context: SyntaxFactoryContext): OmittedTypeArgumentSyntax {
            super.ctor_2121(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
            this.omittedTypeArgumentToken = omittedTypeArgumentToken;
            return this;
        }


        ctor_4471(kind: SyntaxKind, omittedTypeArgumentToken: SyntaxToken): OmittedTypeArgumentSyntax {
            super.ctor_2121(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
            this.omittedTypeArgumentToken = omittedTypeArgumentToken;
            return this;
        }

        public get OmittedTypeArgumentToken(): SyntaxToken { return this.omittedTypeArgumentToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.omittedTypeArgumentToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.OmittedTypeArgumentSyntax().ctor_5858(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitOmittedTypeArgument(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitOmittedTypeArgument(this);
        }

        public Update(omittedTypeArgumentToken: SyntaxToken): OmittedTypeArgumentSyntax {
            if (omittedTypeArgumentToken != this.OmittedTypeArgumentToken) {
                var newNode = SyntaxFactory.OmittedTypeArgument(omittedTypeArgumentToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new OmittedTypeArgumentSyntax().ctor_1834(this.Kind, this.omittedTypeArgumentToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new OmittedTypeArgumentSyntax().ctor_1834(this.Kind, this.omittedTypeArgumentToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1044(reader: Roslyn.Utilities.ObjectReader): OmittedTypeArgumentSyntax {
            super.ctor_6805(reader);
            this.SlotCount = 1;
            var omittedTypeArgumentToken = <SyntaxToken>reader.ReadValue();
            if (omittedTypeArgumentToken != null) {
                this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
                this.omittedTypeArgumentToken = omittedTypeArgumentToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.omittedTypeArgumentToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new OmittedTypeArgumentSyntax().ctor_1044(r);
        }
    }

    export class ParenthesizedExpressionSyntax extends ExpressionSyntax {
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_1550(kind: SyntaxKind, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ParenthesizedExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_6142(kind: SyntaxKind, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): ParenthesizedExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1449(kind: SyntaxKind, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): ParenthesizedExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openParenToken;
                case 1: return this.expression;
                case 2: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ParenthesizedExpressionSyntax().ctor_2189(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitParenthesizedExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitParenthesizedExpression(this);
        }

        public Update(openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): ParenthesizedExpressionSyntax {
            if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ParenthesizedExpressionSyntax().ctor_1550(this.Kind, this.openParenToken, this.expression, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ParenthesizedExpressionSyntax().ctor_1550(this.Kind, this.openParenToken, this.expression, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_8426(reader: Roslyn.Utilities.ObjectReader): ParenthesizedExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 3;
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ParenthesizedExpressionSyntax().ctor_8426(r);
        }
    }

    export class PrefixUnaryExpressionSyntax extends ExpressionSyntax {
        operatorToken: SyntaxToken;
        operand: ExpressionSyntax;

        constructor() { super(); }
        ctor_1992(kind: SyntaxKind, operatorToken: SyntaxToken, operand: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PrefixUnaryExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            return this;
        }


        ctor_1024(kind: SyntaxKind, operatorToken: SyntaxToken, operand: ExpressionSyntax, context: SyntaxFactoryContext): PrefixUnaryExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            return this;
        }


        ctor_5025(kind: SyntaxKind, operatorToken: SyntaxToken, operand: ExpressionSyntax): PrefixUnaryExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            return this;
        }

        public get OperatorToken(): SyntaxToken { return this.operatorToken; }
        public get Operand(): ExpressionSyntax { return this.operand; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.operatorToken;
                case 1: return this.operand;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.PrefixUnaryExpressionSyntax().ctor_9916(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitPrefixUnaryExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitPrefixUnaryExpression(this);
        }

        public Update(operatorToken: SyntaxToken, operand: ExpressionSyntax): PrefixUnaryExpressionSyntax {
            if (operatorToken != this.OperatorToken || operand != this.Operand) {
                var newNode = SyntaxFactory.PrefixUnaryExpression(this.Kind, operatorToken, operand);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new PrefixUnaryExpressionSyntax().ctor_1992(this.Kind, this.operatorToken, this.operand, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new PrefixUnaryExpressionSyntax().ctor_1992(this.Kind, this.operatorToken, this.operand, this.GetDiagnostics(), annotations);
        }

        public ctor_2004(reader: Roslyn.Utilities.ObjectReader): PrefixUnaryExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 2;
            var operatorToken = <SyntaxToken>reader.ReadValue();
            if (operatorToken != null) {
                this.AdjustFlagsAndWidth(operatorToken);
                this.operatorToken = operatorToken;
                return this;
            }
            var operand = <ExpressionSyntax>reader.ReadValue();
            if (operand != null) {
                this.AdjustFlagsAndWidth(operand);
                this.operand = operand;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.operand);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new PrefixUnaryExpressionSyntax().ctor_2004(r);
        }
    }

    export class AwaitExpressionSyntax extends ExpressionSyntax {
        awaitKeyword: SyntaxToken;
        expression: ExpressionSyntax;

        constructor() { super(); }
        ctor_1657(kind: SyntaxKind, awaitKeyword: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AwaitExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1535(kind: SyntaxKind, awaitKeyword: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): AwaitExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1403(kind: SyntaxKind, awaitKeyword: SyntaxToken, expression: ExpressionSyntax): AwaitExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }

        public get AwaitKeyword(): SyntaxToken { return this.awaitKeyword; }
        public get Expression(): ExpressionSyntax { return this.expression; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.awaitKeyword;
                case 1: return this.expression;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AwaitExpressionSyntax().ctor_1769(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAwaitExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAwaitExpression(this);
        }

        public Update(awaitKeyword: SyntaxToken, expression: ExpressionSyntax): AwaitExpressionSyntax {
            if (awaitKeyword != this.AwaitKeyword || expression != this.Expression) {
                var newNode = SyntaxFactory.AwaitExpression(awaitKeyword, expression);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AwaitExpressionSyntax().ctor_1657(this.Kind, this.awaitKeyword, this.expression, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AwaitExpressionSyntax().ctor_1657(this.Kind, this.awaitKeyword, this.expression, this.GetDiagnostics(), annotations);
        }

        public ctor_1726(reader: Roslyn.Utilities.ObjectReader): AwaitExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 2;
            var awaitKeyword = <SyntaxToken>reader.ReadValue();
            if (awaitKeyword != null) {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.awaitKeyword);
            writer.WriteValue(this.expression);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AwaitExpressionSyntax().ctor_1726(r);
        }
    }

    export class PostfixUnaryExpressionSyntax extends ExpressionSyntax {
        operand: ExpressionSyntax;
        operatorToken: SyntaxToken;

        constructor() { super(); }
        ctor_1408(kind: SyntaxKind, operand: ExpressionSyntax, operatorToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PostfixUnaryExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            return this;
        }


        ctor_5196(kind: SyntaxKind, operand: ExpressionSyntax, operatorToken: SyntaxToken, context: SyntaxFactoryContext): PostfixUnaryExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            return this;
        }


        ctor_1442(kind: SyntaxKind, operand: ExpressionSyntax, operatorToken: SyntaxToken): PostfixUnaryExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            return this;
        }

        public get Operand(): ExpressionSyntax { return this.operand; }
        public get OperatorToken(): SyntaxToken { return this.operatorToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.operand;
                case 1: return this.operatorToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.PostfixUnaryExpressionSyntax().ctor_8896(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitPostfixUnaryExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitPostfixUnaryExpression(this);
        }

        public Update(operand: ExpressionSyntax, operatorToken: SyntaxToken): PostfixUnaryExpressionSyntax {
            if (operand != this.Operand || operatorToken != this.OperatorToken) {
                var newNode = SyntaxFactory.PostfixUnaryExpression(this.Kind, operand, operatorToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new PostfixUnaryExpressionSyntax().ctor_1408(this.Kind, this.operand, this.operatorToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new PostfixUnaryExpressionSyntax().ctor_1408(this.Kind, this.operand, this.operatorToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1944(reader: Roslyn.Utilities.ObjectReader): PostfixUnaryExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 2;
            var operand = <ExpressionSyntax>reader.ReadValue();
            if (operand != null) {
                this.AdjustFlagsAndWidth(operand);
                this.operand = operand;
                return this;
            }
            var operatorToken = <SyntaxToken>reader.ReadValue();
            if (operatorToken != null) {
                this.AdjustFlagsAndWidth(operatorToken);
                this.operatorToken = operatorToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.operand);
            writer.WriteValue(this.operatorToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new PostfixUnaryExpressionSyntax().ctor_1944(r);
        }
    }

    export class MemberAccessExpressionSyntax extends ExpressionSyntax {
        expression: ExpressionSyntax;
        operatorToken: SyntaxToken;
        name: SimpleNameSyntax;

        constructor() { super(); }
        ctor_3040(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MemberAccessExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            return this;
        }


        ctor_9206(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax, context: SyntaxFactoryContext): MemberAccessExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            return this;
        }


        ctor_6416(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberAccessExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            return this;
        }

        public get Expression(): ExpressionSyntax { return this.expression; }
        public get OperatorToken(): SyntaxToken { return this.operatorToken; }
        public get Name(): SimpleNameSyntax { return this.name; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.expression;
                case 1: return this.operatorToken;
                case 2: return this.name;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.MemberAccessExpressionSyntax().ctor_3326(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitMemberAccessExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitMemberAccessExpression(this);
        }

        public Update(expression: ExpressionSyntax, operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberAccessExpressionSyntax {
            if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name) {
                var newNode = SyntaxFactory.MemberAccessExpression(this.Kind, expression, operatorToken, name);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new MemberAccessExpressionSyntax().ctor_3040(this.Kind, this.expression, this.operatorToken, this.name, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new MemberAccessExpressionSyntax().ctor_3040(this.Kind, this.expression, this.operatorToken, this.name, this.GetDiagnostics(), annotations);
        }

        public ctor_3517(reader: Roslyn.Utilities.ObjectReader): MemberAccessExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 3;
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var operatorToken = <SyntaxToken>reader.ReadValue();
            if (operatorToken != null) {
                this.AdjustFlagsAndWidth(operatorToken);
                this.operatorToken = operatorToken;
                return this;
            }
            var name = <SimpleNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.name);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new MemberAccessExpressionSyntax().ctor_3517(r);
        }
    }

    export class ConditionalAccessExpressionSyntax extends ExpressionSyntax {
        expression: ExpressionSyntax;
        operatorToken: SyntaxToken;
        whenNotNull: ExpressionSyntax;

        constructor() { super(); }
        ctor_1354(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConditionalAccessExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(whenNotNull);
            this.whenNotNull = whenNotNull;
            return this;
        }


        ctor_8619(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax, context: SyntaxFactoryContext): ConditionalAccessExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(whenNotNull);
            this.whenNotNull = whenNotNull;
            return this;
        }


        ctor_1887(kind: SyntaxKind, expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax): ConditionalAccessExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(whenNotNull);
            this.whenNotNull = whenNotNull;
            return this;
        }

        public get Expression(): ExpressionSyntax { return this.expression; }
        public get OperatorToken(): SyntaxToken { return this.operatorToken; }
        public get WhenNotNull(): ExpressionSyntax { return this.whenNotNull; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.expression;
                case 1: return this.operatorToken;
                case 2: return this.whenNotNull;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ConditionalAccessExpressionSyntax().ctor_1030(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitConditionalAccessExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitConditionalAccessExpression(this);
        }

        public Update(expression: ExpressionSyntax, operatorToken: SyntaxToken, whenNotNull: ExpressionSyntax): ConditionalAccessExpressionSyntax {
            if (expression != this.Expression || operatorToken != this.OperatorToken || whenNotNull != this.WhenNotNull) {
                var newNode = SyntaxFactory.ConditionalAccessExpression(expression, operatorToken, whenNotNull);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ConditionalAccessExpressionSyntax().ctor_1354(this.Kind, this.expression, this.operatorToken, this.whenNotNull, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ConditionalAccessExpressionSyntax().ctor_1354(this.Kind, this.expression, this.operatorToken, this.whenNotNull, this.GetDiagnostics(), annotations);
        }

        public ctor_8522(reader: Roslyn.Utilities.ObjectReader): ConditionalAccessExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 3;
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var operatorToken = <SyntaxToken>reader.ReadValue();
            if (operatorToken != null) {
                this.AdjustFlagsAndWidth(operatorToken);
                this.operatorToken = operatorToken;
                return this;
            }
            var whenNotNull = <ExpressionSyntax>reader.ReadValue();
            if (whenNotNull != null) {
                this.AdjustFlagsAndWidth(whenNotNull);
                this.whenNotNull = whenNotNull;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.whenNotNull);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ConditionalAccessExpressionSyntax().ctor_8522(r);
        }
    }

    export class MemberBindingExpressionSyntax extends ExpressionSyntax {
        operatorToken: SyntaxToken;
        name: SimpleNameSyntax;

        constructor() { super(); }
        ctor_1186(kind: SyntaxKind, operatorToken: SyntaxToken, name: SimpleNameSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MemberBindingExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            return this;
        }


        ctor_1227(kind: SyntaxKind, operatorToken: SyntaxToken, name: SimpleNameSyntax, context: SyntaxFactoryContext): MemberBindingExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            return this;
        }


        ctor_4500(kind: SyntaxKind, operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberBindingExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            return this;
        }

        public get OperatorToken(): SyntaxToken { return this.operatorToken; }
        public get Name(): SimpleNameSyntax { return this.name; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.operatorToken;
                case 1: return this.name;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.MemberBindingExpressionSyntax().ctor_1286(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitMemberBindingExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitMemberBindingExpression(this);
        }

        public Update(operatorToken: SyntaxToken, name: SimpleNameSyntax): MemberBindingExpressionSyntax {
            if (operatorToken != this.OperatorToken || name != this.Name) {
                var newNode = SyntaxFactory.MemberBindingExpression(operatorToken, name);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new MemberBindingExpressionSyntax().ctor_1186(this.Kind, this.operatorToken, this.name, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new MemberBindingExpressionSyntax().ctor_1186(this.Kind, this.operatorToken, this.name, this.GetDiagnostics(), annotations);
        }

        public ctor_1247(reader: Roslyn.Utilities.ObjectReader): MemberBindingExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 2;
            var operatorToken = <SyntaxToken>reader.ReadValue();
            if (operatorToken != null) {
                this.AdjustFlagsAndWidth(operatorToken);
                this.operatorToken = operatorToken;
                return this;
            }
            var name = <SimpleNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.name);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new MemberBindingExpressionSyntax().ctor_1247(r);
        }
    }

    export class ElementBindingExpressionSyntax extends ExpressionSyntax {
        argumentList: BracketedArgumentListSyntax;

        constructor() { super(); }
        ctor_1888(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ElementBindingExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }


        ctor_9693(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax, context: SyntaxFactoryContext): ElementBindingExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }


        ctor_2574(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax): ElementBindingExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }

        public get ArgumentList(): BracketedArgumentListSyntax { return this.argumentList; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.argumentList;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ElementBindingExpressionSyntax().ctor_2138(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitElementBindingExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitElementBindingExpression(this);
        }

        public Update(argumentList: BracketedArgumentListSyntax): ElementBindingExpressionSyntax {
            if (argumentList != this.ArgumentList) {
                var newNode = SyntaxFactory.ElementBindingExpression(argumentList);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ElementBindingExpressionSyntax().ctor_1888(this.Kind, this.argumentList, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ElementBindingExpressionSyntax().ctor_1888(this.Kind, this.argumentList, this.GetDiagnostics(), annotations);
        }

        public ctor_7162(reader: Roslyn.Utilities.ObjectReader): ElementBindingExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 1;
            var argumentList = <BracketedArgumentListSyntax>reader.ReadValue();
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.argumentList);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ElementBindingExpressionSyntax().ctor_7162(r);
        }
    }

    export class ImplicitElementAccessSyntax extends ExpressionSyntax {
        argumentList: BracketedArgumentListSyntax;

        constructor() { super(); }
        ctor_1984(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ImplicitElementAccessSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }


        ctor_2625(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax, context: SyntaxFactoryContext): ImplicitElementAccessSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }


        ctor_1156(kind: SyntaxKind, argumentList: BracketedArgumentListSyntax): ImplicitElementAccessSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }

        public get ArgumentList(): BracketedArgumentListSyntax { return this.argumentList; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.argumentList;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ImplicitElementAccessSyntax().ctor_5704(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitImplicitElementAccess(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitImplicitElementAccess(this);
        }

        public Update(argumentList: BracketedArgumentListSyntax): ImplicitElementAccessSyntax {
            if (argumentList != this.ArgumentList) {
                var newNode = SyntaxFactory.ImplicitElementAccess(argumentList);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ImplicitElementAccessSyntax().ctor_1984(this.Kind, this.argumentList, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ImplicitElementAccessSyntax().ctor_1984(this.Kind, this.argumentList, this.GetDiagnostics(), annotations);
        }

        public ctor_4986(reader: Roslyn.Utilities.ObjectReader): ImplicitElementAccessSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 1;
            var argumentList = <BracketedArgumentListSyntax>reader.ReadValue();
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.argumentList);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ImplicitElementAccessSyntax().ctor_4986(r);
        }
    }

    export class BinaryExpressionSyntax extends ExpressionSyntax {
        left: ExpressionSyntax;
        operatorToken: SyntaxToken;
        right: ExpressionSyntax;

        constructor() { super(); }
        ctor_1255(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BinaryExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
            return this;
        }


        ctor_8809(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax, context: SyntaxFactoryContext): BinaryExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
            return this;
        }


        ctor_3463(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): BinaryExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
            return this;
        }

        public get Left(): ExpressionSyntax { return this.left; }
        public get OperatorToken(): SyntaxToken { return this.operatorToken; }
        public get Right(): ExpressionSyntax { return this.right; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.left;
                case 1: return this.operatorToken;
                case 2: return this.right;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.BinaryExpressionSyntax().ctor_5723(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitBinaryExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitBinaryExpression(this);
        }

        public Update(left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): BinaryExpressionSyntax {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right) {
                var newNode = SyntaxFactory.BinaryExpression(this.Kind, left, operatorToken, right);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new BinaryExpressionSyntax().ctor_1255(this.Kind, this.left, this.operatorToken, this.right, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new BinaryExpressionSyntax().ctor_1255(this.Kind, this.left, this.operatorToken, this.right, this.GetDiagnostics(), annotations);
        }

        public ctor_1537(reader: Roslyn.Utilities.ObjectReader): BinaryExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 3;
            var left = <ExpressionSyntax>reader.ReadValue();
            if (left != null) {
                this.AdjustFlagsAndWidth(left);
                this.left = left;
                return this;
            }
            var operatorToken = <SyntaxToken>reader.ReadValue();
            if (operatorToken != null) {
                this.AdjustFlagsAndWidth(operatorToken);
                this.operatorToken = operatorToken;
                return this;
            }
            var right = <ExpressionSyntax>reader.ReadValue();
            if (right != null) {
                this.AdjustFlagsAndWidth(right);
                this.right = right;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.right);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new BinaryExpressionSyntax().ctor_1537(r);
        }
    }

    export class AssignmentExpressionSyntax extends ExpressionSyntax {
        left: ExpressionSyntax;
        operatorToken: SyntaxToken;
        right: ExpressionSyntax;

        constructor() { super(); }
        ctor_1574(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AssignmentExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
            return this;
        }


        ctor_9550(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax, context: SyntaxFactoryContext): AssignmentExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
            return this;
        }


        ctor_2044(kind: SyntaxKind, left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): AssignmentExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
            return this;
        }

        public get Left(): ExpressionSyntax { return this.left; }
        public get OperatorToken(): SyntaxToken { return this.operatorToken; }
        public get Right(): ExpressionSyntax { return this.right; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.left;
                case 1: return this.operatorToken;
                case 2: return this.right;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AssignmentExpressionSyntax().ctor_1006(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAssignmentExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAssignmentExpression(this);
        }

        public Update(left: ExpressionSyntax, operatorToken: SyntaxToken, right: ExpressionSyntax): AssignmentExpressionSyntax {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right) {
                var newNode = SyntaxFactory.AssignmentExpression(this.Kind, left, operatorToken, right);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AssignmentExpressionSyntax().ctor_1574(this.Kind, this.left, this.operatorToken, this.right, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AssignmentExpressionSyntax().ctor_1574(this.Kind, this.left, this.operatorToken, this.right, this.GetDiagnostics(), annotations);
        }

        public ctor_5472(reader: Roslyn.Utilities.ObjectReader): AssignmentExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 3;
            var left = <ExpressionSyntax>reader.ReadValue();
            if (left != null) {
                this.AdjustFlagsAndWidth(left);
                this.left = left;
                return this;
            }
            var operatorToken = <SyntaxToken>reader.ReadValue();
            if (operatorToken != null) {
                this.AdjustFlagsAndWidth(operatorToken);
                this.operatorToken = operatorToken;
                return this;
            }
            var right = <ExpressionSyntax>reader.ReadValue();
            if (right != null) {
                this.AdjustFlagsAndWidth(right);
                this.right = right;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.right);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AssignmentExpressionSyntax().ctor_5472(r);
        }
    }

    export class ConditionalExpressionSyntax extends ExpressionSyntax {
        condition: ExpressionSyntax;
        questionToken: SyntaxToken;
        whenTrue: ExpressionSyntax;
        colonToken: SyntaxToken;
        whenFalse: ExpressionSyntax;

        constructor() { super(); }
        ctor_8788(kind: SyntaxKind, condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConditionalExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            this.AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
            return this;
        }


        ctor_3635(kind: SyntaxKind, condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax, context: SyntaxFactoryContext): ConditionalExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            this.AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
            return this;
        }


        ctor_1059(kind: SyntaxKind, condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax): ConditionalExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            this.AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
            return this;
        }

        public get Condition(): ExpressionSyntax { return this.condition; }
        public get QuestionToken(): SyntaxToken { return this.questionToken; }
        public get WhenTrue(): ExpressionSyntax { return this.whenTrue; }
        public get ColonToken(): SyntaxToken { return this.colonToken; }
        public get WhenFalse(): ExpressionSyntax { return this.whenFalse; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.condition;
                case 1: return this.questionToken;
                case 2: return this.whenTrue;
                case 3: return this.colonToken;
                case 4: return this.whenFalse;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ConditionalExpressionSyntax().ctor_1071(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitConditionalExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitConditionalExpression(this);
        }

        public Update(condition: ExpressionSyntax, questionToken: SyntaxToken, whenTrue: ExpressionSyntax, colonToken: SyntaxToken, whenFalse: ExpressionSyntax): ConditionalExpressionSyntax {
            if (condition != this.Condition || questionToken != this.QuestionToken || whenTrue != this.WhenTrue || colonToken != this.ColonToken || whenFalse != this.WhenFalse) {
                var newNode = SyntaxFactory.ConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ConditionalExpressionSyntax().ctor_8788(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ConditionalExpressionSyntax().ctor_8788(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, this.GetDiagnostics(), annotations);
        }

        public ctor_9050(reader: Roslyn.Utilities.ObjectReader): ConditionalExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 5;
            var condition = <ExpressionSyntax>reader.ReadValue();
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
                return this;
            }
            var questionToken = <SyntaxToken>reader.ReadValue();
            if (questionToken != null) {
                this.AdjustFlagsAndWidth(questionToken);
                this.questionToken = questionToken;
                return this;
            }
            var whenTrue = <ExpressionSyntax>reader.ReadValue();
            if (whenTrue != null) {
                this.AdjustFlagsAndWidth(whenTrue);
                this.whenTrue = whenTrue;
                return this;
            }
            var colonToken = <SyntaxToken>reader.ReadValue();
            if (colonToken != null) {
                this.AdjustFlagsAndWidth(colonToken);
                this.colonToken = colonToken;
                return this;
            }
            var whenFalse = <ExpressionSyntax>reader.ReadValue();
            if (whenFalse != null) {
                this.AdjustFlagsAndWidth(whenFalse);
                this.whenFalse = whenFalse;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.questionToken);
            writer.WriteValue(this.whenTrue);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.whenFalse);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ConditionalExpressionSyntax().ctor_9050(r);
        }
    }

    export class InstanceExpressionSyntax extends ExpressionSyntax {
        constructor() { super(); }
        ctor_1786(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InstanceExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            return this;
        }
        ctor_1876(kind: SyntaxKind): InstanceExpressionSyntax {
            super.ctor_7190(kind);
            return this;
        }

        ctor_2457(reader: Roslyn.Utilities.ObjectReader): InstanceExpressionSyntax {
            super.ctor_1102(reader);
            return this;
        }
    }

    export class ThisExpressionSyntax extends InstanceExpressionSyntax {
        token: SyntaxToken;

        constructor() { super(); }
        ctor_1800(kind: SyntaxKind, token: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ThisExpressionSyntax {
            super.ctor_1786(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
            return this;
        }


        ctor_1182(kind: SyntaxKind, token: SyntaxToken, context: SyntaxFactoryContext): ThisExpressionSyntax {
            super.ctor_1876(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
            return this;
        }


        ctor_1863(kind: SyntaxKind, token: SyntaxToken): ThisExpressionSyntax {
            super.ctor_1876(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
            return this;
        }

        public get Token(): SyntaxToken { return this.token; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.token;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ThisExpressionSyntax().ctor_9095(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitThisExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitThisExpression(this);
        }

        public Update(token: SyntaxToken): ThisExpressionSyntax {
            if (token != this.Token) {
                var newNode = SyntaxFactory.ThisExpression(token);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ThisExpressionSyntax().ctor_1800(this.Kind, this.token, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ThisExpressionSyntax().ctor_1800(this.Kind, this.token, this.GetDiagnostics(), annotations);
        }

        public ctor_1014(reader: Roslyn.Utilities.ObjectReader): ThisExpressionSyntax {
            super.ctor_2457(reader);
            this.SlotCount = 1;
            var token = <SyntaxToken>reader.ReadValue();
            if (token != null) {
                this.AdjustFlagsAndWidth(token);
                this.token = token;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.token);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ThisExpressionSyntax().ctor_1014(r);
        }
    }

    export class BaseExpressionSyntax extends InstanceExpressionSyntax {
        token: SyntaxToken;

        constructor() { super(); }
        ctor_6977(kind: SyntaxKind, token: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseExpressionSyntax {
            super.ctor_1786(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
            return this;
        }


        ctor_1808(kind: SyntaxKind, token: SyntaxToken, context: SyntaxFactoryContext): BaseExpressionSyntax {
            super.ctor_1876(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
            return this;
        }


        ctor_1616(kind: SyntaxKind, token: SyntaxToken): BaseExpressionSyntax {
            super.ctor_1876(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
            return this;
        }

        public get Token(): SyntaxToken { return this.token; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.token;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.BaseExpressionSyntax().ctor_8798(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitBaseExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitBaseExpression(this);
        }

        public Update(token: SyntaxToken): BaseExpressionSyntax {
            if (token != this.Token) {
                var newNode = SyntaxFactory.BaseExpression(token);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new BaseExpressionSyntax().ctor_6977(this.Kind, this.token, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new BaseExpressionSyntax().ctor_6977(this.Kind, this.token, this.GetDiagnostics(), annotations);
        }

        public ctor_6025(reader: Roslyn.Utilities.ObjectReader): BaseExpressionSyntax {
            super.ctor_2457(reader);
            this.SlotCount = 1;
            var token = <SyntaxToken>reader.ReadValue();
            if (token != null) {
                this.AdjustFlagsAndWidth(token);
                this.token = token;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.token);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new BaseExpressionSyntax().ctor_6025(r);
        }
    }

    export class LiteralExpressionSyntax extends ExpressionSyntax {
        token: SyntaxToken;

        constructor() { super(); }
        ctor_1257(kind: SyntaxKind, token: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LiteralExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
            return this;
        }


        ctor_2020(kind: SyntaxKind, token: SyntaxToken, context: SyntaxFactoryContext): LiteralExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
            return this;
        }


        ctor_1875(kind: SyntaxKind, token: SyntaxToken): LiteralExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
            return this;
        }

        public get Token(): SyntaxToken { return this.token; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.token;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.LiteralExpressionSyntax().ctor_1907(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitLiteralExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitLiteralExpression(this);
        }

        public Update(token: SyntaxToken): LiteralExpressionSyntax {
            if (token != this.Token) {
                var newNode = SyntaxFactory.LiteralExpression(this.Kind, token);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new LiteralExpressionSyntax().ctor_1257(this.Kind, this.token, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new LiteralExpressionSyntax().ctor_1257(this.Kind, this.token, this.GetDiagnostics(), annotations);
        }

        public ctor_5223(reader: Roslyn.Utilities.ObjectReader): LiteralExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 1;
            var token = <SyntaxToken>reader.ReadValue();
            if (token != null) {
                this.AdjustFlagsAndWidth(token);
                this.token = token;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.token);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new LiteralExpressionSyntax().ctor_5223(r);
        }
    }

    export class MakeRefExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_1416(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MakeRefExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_7027(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): MakeRefExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_2439(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): MakeRefExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                case 1: return this.openParenToken;
                case 2: return this.expression;
                case 3: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.MakeRefExpressionSyntax().ctor_6904(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitMakeRefExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitMakeRefExpression(this);
        }

        public Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): MakeRefExpressionSyntax {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.MakeRefExpression(keyword, openParenToken, expression, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new MakeRefExpressionSyntax().ctor_1416(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new MakeRefExpressionSyntax().ctor_1416(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_3915(reader: Roslyn.Utilities.ObjectReader): MakeRefExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new MakeRefExpressionSyntax().ctor_3915(r);
        }
    }

    export class RefTypeExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_7310(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): RefTypeExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1373(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): RefTypeExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_2137(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): RefTypeExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                case 1: return this.openParenToken;
                case 2: return this.expression;
                case 3: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.RefTypeExpressionSyntax().ctor_1551(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitRefTypeExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitRefTypeExpression(this);
        }

        public Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): RefTypeExpressionSyntax {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.RefTypeExpression(keyword, openParenToken, expression, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new RefTypeExpressionSyntax().ctor_7310(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new RefTypeExpressionSyntax().ctor_7310(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1821(reader: Roslyn.Utilities.ObjectReader): RefTypeExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new RefTypeExpressionSyntax().ctor_1821(r);
        }
    }

    export class RefValueExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        comma: SyntaxToken;
        type: TypeSyntax;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_9480(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): RefValueExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(comma);
            this.comma = comma;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_2244(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): RefValueExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(comma);
            this.comma = comma;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_7980(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): RefValueExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(comma);
            this.comma = comma;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get Comma(): SyntaxToken { return this.comma; }
        public get Type(): TypeSyntax { return this.type; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                case 1: return this.openParenToken;
                case 2: return this.expression;
                case 3: return this.comma;
                case 4: return this.type;
                case 5: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.RefValueExpressionSyntax().ctor_1590(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitRefValueExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitRefValueExpression(this);
        }

        public Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, comma: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): RefValueExpressionSyntax {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || comma != this.Comma || type != this.Type || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.RefValueExpression(keyword, openParenToken, expression, comma, type, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new RefValueExpressionSyntax().ctor_9480(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new RefValueExpressionSyntax().ctor_9480(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_9232(reader: Roslyn.Utilities.ObjectReader): RefValueExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 6;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var comma = <SyntaxToken>reader.ReadValue();
            if (comma != null) {
                this.AdjustFlagsAndWidth(comma);
                this.comma = comma;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.comma);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new RefValueExpressionSyntax().ctor_9232(r);
        }
    }

    export class CheckedExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_1085(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CheckedExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1641(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): CheckedExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1447(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): CheckedExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                case 1: return this.openParenToken;
                case 2: return this.expression;
                case 3: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CheckedExpressionSyntax().ctor_5940(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCheckedExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCheckedExpression(this);
        }

        public Update(keyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken): CheckedExpressionSyntax {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.CheckedExpression(this.Kind, keyword, openParenToken, expression, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CheckedExpressionSyntax().ctor_1085(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CheckedExpressionSyntax().ctor_1085(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_8960(reader: Roslyn.Utilities.ObjectReader): CheckedExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CheckedExpressionSyntax().ctor_8960(r);
        }
    }

    export class DefaultExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_1965(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DefaultExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_4943(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): DefaultExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1190(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): DefaultExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Type(): TypeSyntax { return this.type; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                case 1: return this.openParenToken;
                case 2: return this.type;
                case 3: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.DefaultExpressionSyntax().ctor_2428(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitDefaultExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitDefaultExpression(this);
        }

        public Update(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): DefaultExpressionSyntax {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.DefaultExpression(keyword, openParenToken, type, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new DefaultExpressionSyntax().ctor_1965(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new DefaultExpressionSyntax().ctor_1965(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1731(reader: Roslyn.Utilities.ObjectReader): DefaultExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new DefaultExpressionSyntax().ctor_1731(r);
        }
    }

    export class TypeOfExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_1350(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeOfExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1868(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): TypeOfExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_2174(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): TypeOfExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Type(): TypeSyntax { return this.type; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                case 1: return this.openParenToken;
                case 2: return this.type;
                case 3: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.TypeOfExpressionSyntax().ctor_2097(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitTypeOfExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitTypeOfExpression(this);
        }

        public Update(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): TypeOfExpressionSyntax {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.TypeOfExpression(keyword, openParenToken, type, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new TypeOfExpressionSyntax().ctor_1350(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new TypeOfExpressionSyntax().ctor_1350(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1334(reader: Roslyn.Utilities.ObjectReader): TypeOfExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new TypeOfExpressionSyntax().ctor_1334(r);
        }
    }

    export class SizeOfExpressionSyntax extends ExpressionSyntax {
        keyword: SyntaxToken;
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_1452(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SizeOfExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1117(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): SizeOfExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_4244(kind: SyntaxKind, keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): SizeOfExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Type(): TypeSyntax { return this.type; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                case 1: return this.openParenToken;
                case 2: return this.type;
                case 3: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.SizeOfExpressionSyntax().ctor_1207(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitSizeOfExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitSizeOfExpression(this);
        }

        public Update(keyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken): SizeOfExpressionSyntax {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.SizeOfExpression(keyword, openParenToken, type, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new SizeOfExpressionSyntax().ctor_1452(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new SizeOfExpressionSyntax().ctor_1452(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_4010(reader: Roslyn.Utilities.ObjectReader): SizeOfExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new SizeOfExpressionSyntax().ctor_4010(r);
        }
    }

    export class InvocationExpressionSyntax extends ExpressionSyntax {
        expression: ExpressionSyntax;
        argumentList: ArgumentListSyntax;

        constructor() { super(); }
        ctor_7344(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: ArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InvocationExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }


        ctor_1045(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: ArgumentListSyntax, context: SyntaxFactoryContext): InvocationExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }


        ctor_1650(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }

        public get Expression(): ExpressionSyntax { return this.expression; }
        public get ArgumentList(): ArgumentListSyntax { return this.argumentList; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.expression;
                case 1: return this.argumentList;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.InvocationExpressionSyntax().ctor_1641(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitInvocationExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitInvocationExpression(this);
        }

        public Update(expression: ExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax {
            if (expression != this.Expression || argumentList != this.ArgumentList) {
                var newNode = SyntaxFactory.InvocationExpression(expression, argumentList);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new InvocationExpressionSyntax().ctor_7344(this.Kind, this.expression, this.argumentList, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new InvocationExpressionSyntax().ctor_7344(this.Kind, this.expression, this.argumentList, this.GetDiagnostics(), annotations);
        }

        public ctor_1278(reader: Roslyn.Utilities.ObjectReader): InvocationExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 2;
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var argumentList = <ArgumentListSyntax>reader.ReadValue();
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.argumentList);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new InvocationExpressionSyntax().ctor_1278(r);
        }
    }

    export class ElementAccessExpressionSyntax extends ExpressionSyntax {
        expression: ExpressionSyntax;
        argumentList: BracketedArgumentListSyntax;

        constructor() { super(); }
        ctor_1433(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ElementAccessExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }


        ctor_1566(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax, context: SyntaxFactoryContext): ElementAccessExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }


        ctor_1465(kind: SyntaxKind, expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax): ElementAccessExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }

        public get Expression(): ExpressionSyntax { return this.expression; }
        public get ArgumentList(): BracketedArgumentListSyntax { return this.argumentList; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.expression;
                case 1: return this.argumentList;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ElementAccessExpressionSyntax().ctor_1611(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitElementAccessExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitElementAccessExpression(this);
        }

        public Update(expression: ExpressionSyntax, argumentList: BracketedArgumentListSyntax): ElementAccessExpressionSyntax {
            if (expression != this.Expression || argumentList != this.ArgumentList) {
                var newNode = SyntaxFactory.ElementAccessExpression(expression, argumentList);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ElementAccessExpressionSyntax().ctor_1433(this.Kind, this.expression, this.argumentList, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ElementAccessExpressionSyntax().ctor_1433(this.Kind, this.expression, this.argumentList, this.GetDiagnostics(), annotations);
        }

        public ctor_1646(reader: Roslyn.Utilities.ObjectReader): ElementAccessExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 2;
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var argumentList = <BracketedArgumentListSyntax>reader.ReadValue();
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.argumentList);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ElementAccessExpressionSyntax().ctor_1646(r);
        }
    }

    export class BaseArgumentListSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_1600(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseArgumentListSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_1379(kind: SyntaxKind): BaseArgumentListSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_2083(reader: Roslyn.Utilities.ObjectReader): BaseArgumentListSyntax {
            super.ctor_4942(reader);
            return this;
        }

        public Arguments: SeparatedSyntaxList<ArgumentSyntax>;
    }

    export class ArgumentListSyntax extends BaseArgumentListSyntax {
        openParenToken: SyntaxToken;
        arguments: CSharpSyntaxNode;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_5553(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArgumentListSyntax {
            super.ctor_1600(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_2059(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): ArgumentListSyntax {
            super.ctor_1379(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1509(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken): ArgumentListSyntax {
            super.ctor_1379(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Arguments(): SeparatedSyntaxList<ArgumentSyntax> { return new SeparatedSyntaxList<ArgumentSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.arguments)); }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openParenToken;
                case 1: return this.arguments;
                case 2: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ArgumentListSyntax().ctor_1575(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitArgumentList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitArgumentList(this);
        }

        public Update(openParenToken: SyntaxToken, arguments: SeparatedSyntaxList<ArgumentSyntax>, closeParenToken: SyntaxToken): ArgumentListSyntax {
            if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.ArgumentList(openParenToken, arguments, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ArgumentListSyntax().ctor_5553(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ArgumentListSyntax().ctor_5553(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_4325(reader: Roslyn.Utilities.ObjectReader): ArgumentListSyntax {
            super.ctor_2083(reader);
            this.SlotCount = 3;
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var arguments = <CSharpSyntaxNode>reader.ReadValue();
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ArgumentListSyntax().ctor_4325(r);
        }
    }

    export class BracketedArgumentListSyntax extends BaseArgumentListSyntax {
        openBracketToken: SyntaxToken;
        arguments: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;

        constructor() { super(); }
        ctor_1038(kind: SyntaxKind, openBracketToken: SyntaxToken, arguments: CSharpSyntaxNode, closeBracketToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BracketedArgumentListSyntax {
            super.ctor_1600(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }


        ctor_3403(kind: SyntaxKind, openBracketToken: SyntaxToken, arguments: CSharpSyntaxNode, closeBracketToken: SyntaxToken, context: SyntaxFactoryContext): BracketedArgumentListSyntax {
            super.ctor_1379(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }


        ctor_2475(kind: SyntaxKind, openBracketToken: SyntaxToken, arguments: CSharpSyntaxNode, closeBracketToken: SyntaxToken): BracketedArgumentListSyntax {
            super.ctor_1379(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }

        public get OpenBracketToken(): SyntaxToken { return this.openBracketToken; }
        public get Arguments(): SeparatedSyntaxList<ArgumentSyntax> { return new SeparatedSyntaxList<ArgumentSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.arguments)); }
        public get CloseBracketToken(): SyntaxToken { return this.closeBracketToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openBracketToken;
                case 1: return this.arguments;
                case 2: return this.closeBracketToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.BracketedArgumentListSyntax().ctor_2085(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitBracketedArgumentList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitBracketedArgumentList(this);
        }

        public Update(openBracketToken: SyntaxToken, arguments: SeparatedSyntaxList<ArgumentSyntax>, closeBracketToken: SyntaxToken): BracketedArgumentListSyntax {
            if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken) {
                var newNode = SyntaxFactory.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new BracketedArgumentListSyntax().ctor_1038(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new BracketedArgumentListSyntax().ctor_1038(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1834(reader: Roslyn.Utilities.ObjectReader): BracketedArgumentListSyntax {
            super.ctor_2083(reader);
            this.SlotCount = 3;
            var openBracketToken = <SyntaxToken>reader.ReadValue();
            if (openBracketToken != null) {
                this.AdjustFlagsAndWidth(openBracketToken);
                this.openBracketToken = openBracketToken;
                return this;
            }
            var arguments = <CSharpSyntaxNode>reader.ReadValue();
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
                return this;
            }
            var closeBracketToken = <SyntaxToken>reader.ReadValue();
            if (closeBracketToken != null) {
                this.AdjustFlagsAndWidth(closeBracketToken);
                this.closeBracketToken = closeBracketToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeBracketToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new BracketedArgumentListSyntax().ctor_1834(r);
        }
    }

    export class ArgumentSyntax extends CSharpSyntaxNode {
        nameColon: NameColonSyntax;
        refOrOutKeyword: SyntaxToken;
        expression: ExpressionSyntax;

        constructor() { super(); }
        ctor_1209(kind: SyntaxKind, nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArgumentSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            if (nameColon != null) {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (refOrOutKeyword != null) {
                this.AdjustFlagsAndWidth(refOrOutKeyword);
                this.refOrOutKeyword = refOrOutKeyword;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_7053(kind: SyntaxKind, nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): ArgumentSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            if (nameColon != null) {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (refOrOutKeyword != null) {
                this.AdjustFlagsAndWidth(refOrOutKeyword);
                this.refOrOutKeyword = refOrOutKeyword;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1629(kind: SyntaxKind, nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax): ArgumentSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            if (nameColon != null) {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (refOrOutKeyword != null) {
                this.AdjustFlagsAndWidth(refOrOutKeyword);
                this.refOrOutKeyword = refOrOutKeyword;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }

        public get NameColon(): NameColonSyntax { return this.nameColon; }
        public get RefOrOutKeyword(): SyntaxToken { return this.refOrOutKeyword; }
        public get Expression(): ExpressionSyntax { return this.expression; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.nameColon;
                case 1: return this.refOrOutKeyword;
                case 2: return this.expression;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ArgumentSyntax().ctor_7616(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitArgument(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitArgument(this);
        }

        public Update(nameColon: NameColonSyntax, refOrOutKeyword: SyntaxToken, expression: ExpressionSyntax): ArgumentSyntax {
            if (nameColon != this.NameColon || refOrOutKeyword != this.RefOrOutKeyword || expression != this.Expression) {
                var newNode = SyntaxFactory.Argument(nameColon, refOrOutKeyword, expression);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ArgumentSyntax().ctor_1209(this.Kind, this.nameColon, this.refOrOutKeyword, this.expression, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ArgumentSyntax().ctor_1209(this.Kind, this.nameColon, this.refOrOutKeyword, this.expression, this.GetDiagnostics(), annotations);
        }

        public ctor_6384(reader: Roslyn.Utilities.ObjectReader): ArgumentSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var nameColon = <NameColonSyntax>reader.ReadValue();
            if (nameColon != null) {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
                return this;
            }
            var refOrOutKeyword = <SyntaxToken>reader.ReadValue();
            if (refOrOutKeyword != null) {
                this.AdjustFlagsAndWidth(refOrOutKeyword);
                this.refOrOutKeyword = refOrOutKeyword;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.nameColon);
            writer.WriteValue(this.refOrOutKeyword);
            writer.WriteValue(this.expression);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ArgumentSyntax().ctor_6384(r);
        }
    }

    export class NameColonSyntax extends CSharpSyntaxNode {
        name: IdentifierNameSyntax;
        colonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1158(kind: SyntaxKind, name: IdentifierNameSyntax, colonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NameColonSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }


        ctor_2966(kind: SyntaxKind, name: IdentifierNameSyntax, colonToken: SyntaxToken, context: SyntaxFactoryContext): NameColonSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }


        ctor_5628(kind: SyntaxKind, name: IdentifierNameSyntax, colonToken: SyntaxToken): NameColonSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }

        public get Name(): IdentifierNameSyntax { return this.name; }
        public get ColonToken(): SyntaxToken { return this.colonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.name;
                case 1: return this.colonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.NameColonSyntax().ctor_6392(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitNameColon(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitNameColon(this);
        }

        public Update(name: IdentifierNameSyntax, colonToken: SyntaxToken): NameColonSyntax {
            if (name != this.Name || colonToken != this.ColonToken) {
                var newNode = SyntaxFactory.NameColon(name, colonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new NameColonSyntax().ctor_1158(this.Kind, this.name, this.colonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new NameColonSyntax().ctor_1158(this.Kind, this.name, this.colonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1197(reader: Roslyn.Utilities.ObjectReader): NameColonSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var name = <IdentifierNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var colonToken = <SyntaxToken>reader.ReadValue();
            if (colonToken != null) {
                this.AdjustFlagsAndWidth(colonToken);
                this.colonToken = colonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.colonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new NameColonSyntax().ctor_1197(r);
        }
    }

    export class CastExpressionSyntax extends ExpressionSyntax {
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        closeParenToken: SyntaxToken;
        expression: ExpressionSyntax;

        constructor() { super(); }
        ctor_5677(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CastExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1718(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): CastExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1715(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax): CastExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }

        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Type(): TypeSyntax { return this.type; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }
        public get Expression(): ExpressionSyntax { return this.expression; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openParenToken;
                case 1: return this.type;
                case 2: return this.closeParenToken;
                case 3: return this.expression;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CastExpressionSyntax().ctor_2030(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCastExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCastExpression(this);
        }

        public Update(openParenToken: SyntaxToken, type: TypeSyntax, closeParenToken: SyntaxToken, expression: ExpressionSyntax): CastExpressionSyntax {
            if (openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken || expression != this.Expression) {
                var newNode = SyntaxFactory.CastExpression(openParenToken, type, closeParenToken, expression);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CastExpressionSyntax().ctor_5677(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CastExpressionSyntax().ctor_5677(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, this.GetDiagnostics(), annotations);
        }

        public ctor_8776(reader: Roslyn.Utilities.ObjectReader): CastExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.expression);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CastExpressionSyntax().ctor_8776(r);
        }
    }

    export class AnonymousMethodExpressionSyntax extends ExpressionSyntax {
        asyncKeyword: SyntaxToken;
        delegateKeyword: SyntaxToken;
        parameterList: ParameterListSyntax;
        block: BlockSyntax;

        constructor() { super(); }
        ctor_2080(kind: SyntaxKind, asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AnonymousMethodExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }


        ctor_5936(kind: SyntaxKind, asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, context: SyntaxFactoryContext): AnonymousMethodExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }


        ctor_1422(kind: SyntaxKind, asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): AnonymousMethodExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }

        public get AsyncKeyword(): SyntaxToken { return this.asyncKeyword; }
        public get DelegateKeyword(): SyntaxToken { return this.delegateKeyword; }
        public get ParameterList(): ParameterListSyntax { return this.parameterList; }
        public get Block(): BlockSyntax { return this.block; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.asyncKeyword;
                case 1: return this.delegateKeyword;
                case 2: return this.parameterList;
                case 3: return this.block;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AnonymousMethodExpressionSyntax().ctor_7841(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAnonymousMethodExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAnonymousMethodExpression(this);
        }

        public Update(asyncKeyword: SyntaxToken, delegateKeyword: SyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): AnonymousMethodExpressionSyntax {
            if (asyncKeyword != this.AsyncKeyword || delegateKeyword != this.DelegateKeyword || parameterList != this.ParameterList || block != this.Block) {
                var newNode = SyntaxFactory.AnonymousMethodExpression(asyncKeyword, delegateKeyword, parameterList, block);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AnonymousMethodExpressionSyntax().ctor_2080(this.Kind, this.asyncKeyword, this.delegateKeyword, this.parameterList, this.block, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AnonymousMethodExpressionSyntax().ctor_2080(this.Kind, this.asyncKeyword, this.delegateKeyword, this.parameterList, this.block, this.GetDiagnostics(), annotations);
        }

        public ctor_6799(reader: Roslyn.Utilities.ObjectReader): AnonymousMethodExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var asyncKeyword = <SyntaxToken>reader.ReadValue();
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
                return this;
            }
            var delegateKeyword = <SyntaxToken>reader.ReadValue();
            if (delegateKeyword != null) {
                this.AdjustFlagsAndWidth(delegateKeyword);
                this.delegateKeyword = delegateKeyword;
                return this;
            }
            var parameterList = <ParameterListSyntax>reader.ReadValue();
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
                return this;
            }
            var block = <BlockSyntax>reader.ReadValue();
            if (block != null) {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.asyncKeyword);
            writer.WriteValue(this.delegateKeyword);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.block);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AnonymousMethodExpressionSyntax().ctor_6799(r);
        }
    }

    export class SimpleLambdaExpressionSyntax extends ExpressionSyntax {
        asyncKeyword: SyntaxToken;
        parameter: ParameterSyntax;
        arrowToken: SyntaxToken;
        body: CSharpSyntaxNode;

        constructor() { super(); }
        ctor_3608(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SimpleLambdaExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
            }
            this.AdjustFlagsAndWidth(parameter);
            this.parameter = parameter;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }


        ctor_4208(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode, context: SyntaxFactoryContext): SimpleLambdaExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
            }
            this.AdjustFlagsAndWidth(parameter);
            this.parameter = parameter;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }


        ctor_6581(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): SimpleLambdaExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
            }
            this.AdjustFlagsAndWidth(parameter);
            this.parameter = parameter;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }

        public get AsyncKeyword(): SyntaxToken { return this.asyncKeyword; }
        public get Parameter(): ParameterSyntax { return this.parameter; }
        public get ArrowToken(): SyntaxToken { return this.arrowToken; }
        public get Body(): CSharpSyntaxNode { return this.body; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.asyncKeyword;
                case 1: return this.parameter;
                case 2: return this.arrowToken;
                case 3: return this.body;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.SimpleLambdaExpressionSyntax().ctor_1697(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitSimpleLambdaExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitSimpleLambdaExpression(this);
        }

        public Update(asyncKeyword: SyntaxToken, parameter: ParameterSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): SimpleLambdaExpressionSyntax {
            if (asyncKeyword != this.AsyncKeyword || parameter != this.Parameter || arrowToken != this.ArrowToken || body != this.Body) {
                var newNode = SyntaxFactory.SimpleLambdaExpression(asyncKeyword, parameter, arrowToken, body);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new SimpleLambdaExpressionSyntax().ctor_3608(this.Kind, this.asyncKeyword, this.parameter, this.arrowToken, this.body, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new SimpleLambdaExpressionSyntax().ctor_3608(this.Kind, this.asyncKeyword, this.parameter, this.arrowToken, this.body, this.GetDiagnostics(), annotations);
        }

        public ctor_5210(reader: Roslyn.Utilities.ObjectReader): SimpleLambdaExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var asyncKeyword = <SyntaxToken>reader.ReadValue();
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
                return this;
            }
            var parameter = <ParameterSyntax>reader.ReadValue();
            if (parameter != null) {
                this.AdjustFlagsAndWidth(parameter);
                this.parameter = parameter;
                return this;
            }
            var arrowToken = <SyntaxToken>reader.ReadValue();
            if (arrowToken != null) {
                this.AdjustFlagsAndWidth(arrowToken);
                this.arrowToken = arrowToken;
                return this;
            }
            var body = <CSharpSyntaxNode>reader.ReadValue();
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.asyncKeyword);
            writer.WriteValue(this.parameter);
            writer.WriteValue(this.arrowToken);
            writer.WriteValue(this.body);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new SimpleLambdaExpressionSyntax().ctor_5210(r);
        }
    }

    export class ParenthesizedLambdaExpressionSyntax extends ExpressionSyntax {
        asyncKeyword: SyntaxToken;
        parameterList: ParameterListSyntax;
        arrowToken: SyntaxToken;
        body: CSharpSyntaxNode;

        constructor() { super(); }
        ctor_6894(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ParenthesizedLambdaExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }


        ctor_1719(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode, context: SyntaxFactoryContext): ParenthesizedLambdaExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }


        ctor_1888(kind: SyntaxKind, asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): ParenthesizedLambdaExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }

        public get AsyncKeyword(): SyntaxToken { return this.asyncKeyword; }
        public get ParameterList(): ParameterListSyntax { return this.parameterList; }
        public get ArrowToken(): SyntaxToken { return this.arrowToken; }
        public get Body(): CSharpSyntaxNode { return this.body; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.asyncKeyword;
                case 1: return this.parameterList;
                case 2: return this.arrowToken;
                case 3: return this.body;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ParenthesizedLambdaExpressionSyntax().ctor_1854(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitParenthesizedLambdaExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitParenthesizedLambdaExpression(this);
        }

        public Update(asyncKeyword: SyntaxToken, parameterList: ParameterListSyntax, arrowToken: SyntaxToken, body: CSharpSyntaxNode): ParenthesizedLambdaExpressionSyntax {
            if (asyncKeyword != this.AsyncKeyword || parameterList != this.ParameterList || arrowToken != this.ArrowToken || body != this.Body) {
                var newNode = SyntaxFactory.ParenthesizedLambdaExpression(asyncKeyword, parameterList, arrowToken, body);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ParenthesizedLambdaExpressionSyntax().ctor_6894(this.Kind, this.asyncKeyword, this.parameterList, this.arrowToken, this.body, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ParenthesizedLambdaExpressionSyntax().ctor_6894(this.Kind, this.asyncKeyword, this.parameterList, this.arrowToken, this.body, this.GetDiagnostics(), annotations);
        }

        public ctor_1193(reader: Roslyn.Utilities.ObjectReader): ParenthesizedLambdaExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var asyncKeyword = <SyntaxToken>reader.ReadValue();
            if (asyncKeyword != null) {
                this.AdjustFlagsAndWidth(asyncKeyword);
                this.asyncKeyword = asyncKeyword;
                return this;
            }
            var parameterList = <ParameterListSyntax>reader.ReadValue();
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
                return this;
            }
            var arrowToken = <SyntaxToken>reader.ReadValue();
            if (arrowToken != null) {
                this.AdjustFlagsAndWidth(arrowToken);
                this.arrowToken = arrowToken;
                return this;
            }
            var body = <CSharpSyntaxNode>reader.ReadValue();
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.asyncKeyword);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.arrowToken);
            writer.WriteValue(this.body);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ParenthesizedLambdaExpressionSyntax().ctor_1193(r);
        }
    }

    export class InitializerExpressionSyntax extends ExpressionSyntax {
        openBraceToken: SyntaxToken;
        expressions: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;

        constructor() { super(); }
        ctor_1022(kind: SyntaxKind, openBraceToken: SyntaxToken, expressions: CSharpSyntaxNode, closeBraceToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InitializerExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (expressions != null) {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }


        ctor_1546(kind: SyntaxKind, openBraceToken: SyntaxToken, expressions: CSharpSyntaxNode, closeBraceToken: SyntaxToken, context: SyntaxFactoryContext): InitializerExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (expressions != null) {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }


        ctor_8197(kind: SyntaxKind, openBraceToken: SyntaxToken, expressions: CSharpSyntaxNode, closeBraceToken: SyntaxToken): InitializerExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (expressions != null) {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }

        public get OpenBraceToken(): SyntaxToken { return this.openBraceToken; }
        public get Expressions(): SeparatedSyntaxList<ExpressionSyntax> { return new SeparatedSyntaxList<ExpressionSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.expressions)); }
        public get CloseBraceToken(): SyntaxToken { return this.closeBraceToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openBraceToken;
                case 1: return this.expressions;
                case 2: return this.closeBraceToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.InitializerExpressionSyntax().ctor_9252(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitInitializerExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitInitializerExpression(this);
        }

        public Update(openBraceToken: SyntaxToken, expressions: SeparatedSyntaxList<ExpressionSyntax>, closeBraceToken: SyntaxToken): InitializerExpressionSyntax {
            if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken) {
                var newNode = SyntaxFactory.InitializerExpression(this.Kind, openBraceToken, expressions, closeBraceToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new InitializerExpressionSyntax().ctor_1022(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new InitializerExpressionSyntax().ctor_1022(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1325(reader: Roslyn.Utilities.ObjectReader): InitializerExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 3;
            var openBraceToken = <SyntaxToken>reader.ReadValue();
            if (openBraceToken != null) {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
                return this;
            }
            var expressions = <CSharpSyntaxNode>reader.ReadValue();
            if (expressions != null) {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
                return this;
            }
            var closeBraceToken = <SyntaxToken>reader.ReadValue();
            if (closeBraceToken != null) {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.expressions);
            writer.WriteValue(this.closeBraceToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new InitializerExpressionSyntax().ctor_1325(r);
        }
    }

    export class ObjectCreationExpressionSyntax extends ExpressionSyntax {
        newKeyword: SyntaxToken;
        type: TypeSyntax;
        argumentList: ArgumentListSyntax;
        initializer: InitializerExpressionSyntax;

        constructor() { super(); }
        ctor_1691(kind: SyntaxKind, newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ObjectCreationExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            return this;
        }


        ctor_6392(kind: SyntaxKind, newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax, context: SyntaxFactoryContext): ObjectCreationExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            return this;
        }


        ctor_9625(kind: SyntaxKind, newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax): ObjectCreationExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            return this;
        }

        public get NewKeyword(): SyntaxToken { return this.newKeyword; }
        public get Type(): TypeSyntax { return this.type; }
        public get ArgumentList(): ArgumentListSyntax { return this.argumentList; }
        public get Initializer(): InitializerExpressionSyntax { return this.initializer; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.newKeyword;
                case 1: return this.type;
                case 2: return this.argumentList;
                case 3: return this.initializer;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ObjectCreationExpressionSyntax().ctor_2065(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitObjectCreationExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitObjectCreationExpression(this);
        }

        public Update(newKeyword: SyntaxToken, type: TypeSyntax, argumentList: ArgumentListSyntax, initializer: InitializerExpressionSyntax): ObjectCreationExpressionSyntax {
            if (newKeyword != this.NewKeyword || type != this.Type || argumentList != this.ArgumentList || initializer != this.Initializer) {
                var newNode = SyntaxFactory.ObjectCreationExpression(newKeyword, type, argumentList, initializer);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ObjectCreationExpressionSyntax().ctor_1691(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ObjectCreationExpressionSyntax().ctor_1691(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, this.GetDiagnostics(), annotations);
        }

        public ctor_1028(reader: Roslyn.Utilities.ObjectReader): ObjectCreationExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var newKeyword = <SyntaxToken>reader.ReadValue();
            if (newKeyword != null) {
                this.AdjustFlagsAndWidth(newKeyword);
                this.newKeyword = newKeyword;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var argumentList = <ArgumentListSyntax>reader.ReadValue();
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
                return this;
            }
            var initializer = <InitializerExpressionSyntax>reader.ReadValue();
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.argumentList);
            writer.WriteValue(this.initializer);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ObjectCreationExpressionSyntax().ctor_1028(r);
        }
    }

    export class AnonymousObjectMemberDeclaratorSyntax extends CSharpSyntaxNode {
        nameEquals: NameEqualsSyntax;
        expression: ExpressionSyntax;

        constructor() { super(); }
        ctor_6386(kind: SyntaxKind, nameEquals: NameEqualsSyntax, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AnonymousObjectMemberDeclaratorSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            if (nameEquals != null) {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_8617(kind: SyntaxKind, nameEquals: NameEqualsSyntax, expression: ExpressionSyntax, context: SyntaxFactoryContext): AnonymousObjectMemberDeclaratorSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            if (nameEquals != null) {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_5919(kind: SyntaxKind, nameEquals: NameEqualsSyntax, expression: ExpressionSyntax): AnonymousObjectMemberDeclaratorSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            if (nameEquals != null) {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }

        public get NameEquals(): NameEqualsSyntax { return this.nameEquals; }
        public get Expression(): ExpressionSyntax { return this.expression; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.nameEquals;
                case 1: return this.expression;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax().ctor_5348(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAnonymousObjectMemberDeclarator(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAnonymousObjectMemberDeclarator(this);
        }

        public Update(nameEquals: NameEqualsSyntax, expression: ExpressionSyntax): AnonymousObjectMemberDeclaratorSyntax {
            if (nameEquals != this.NameEquals || expression != this.Expression) {
                var newNode = SyntaxFactory.AnonymousObjectMemberDeclarator(nameEquals, expression);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AnonymousObjectMemberDeclaratorSyntax().ctor_6386(this.Kind, this.nameEquals, this.expression, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AnonymousObjectMemberDeclaratorSyntax().ctor_6386(this.Kind, this.nameEquals, this.expression, this.GetDiagnostics(), annotations);
        }

        public ctor_5169(reader: Roslyn.Utilities.ObjectReader): AnonymousObjectMemberDeclaratorSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var nameEquals = <NameEqualsSyntax>reader.ReadValue();
            if (nameEquals != null) {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.nameEquals);
            writer.WriteValue(this.expression);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AnonymousObjectMemberDeclaratorSyntax().ctor_5169(r);
        }
    }

    export class AnonymousObjectCreationExpressionSyntax extends ExpressionSyntax {
        newKeyword: SyntaxToken;
        openBraceToken: SyntaxToken;
        initializers: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;

        constructor() { super(); }
        ctor_9039(kind: SyntaxKind, newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: CSharpSyntaxNode, closeBraceToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AnonymousObjectCreationExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (initializers != null) {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }


        ctor_8489(kind: SyntaxKind, newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: CSharpSyntaxNode, closeBraceToken: SyntaxToken, context: SyntaxFactoryContext): AnonymousObjectCreationExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (initializers != null) {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }


        ctor_1877(kind: SyntaxKind, newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: CSharpSyntaxNode, closeBraceToken: SyntaxToken): AnonymousObjectCreationExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (initializers != null) {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }

        public get NewKeyword(): SyntaxToken { return this.newKeyword; }
        public get OpenBraceToken(): SyntaxToken { return this.openBraceToken; }
        public get Initializers(): SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> { return new SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.initializers)); }
        public get CloseBraceToken(): SyntaxToken { return this.closeBraceToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.newKeyword;
                case 1: return this.openBraceToken;
                case 2: return this.initializers;
                case 3: return this.closeBraceToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AnonymousObjectCreationExpressionSyntax().ctor_1554(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAnonymousObjectCreationExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAnonymousObjectCreationExpression(this);
        }

        public Update(newKeyword: SyntaxToken, openBraceToken: SyntaxToken, initializers: SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>, closeBraceToken: SyntaxToken): AnonymousObjectCreationExpressionSyntax {
            if (newKeyword != this.NewKeyword || openBraceToken != this.OpenBraceToken || initializers != this.Initializers || closeBraceToken != this.CloseBraceToken) {
                var newNode = SyntaxFactory.AnonymousObjectCreationExpression(newKeyword, openBraceToken, initializers, closeBraceToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AnonymousObjectCreationExpressionSyntax().ctor_9039(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AnonymousObjectCreationExpressionSyntax().ctor_9039(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2376(reader: Roslyn.Utilities.ObjectReader): AnonymousObjectCreationExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 4;
            var newKeyword = <SyntaxToken>reader.ReadValue();
            if (newKeyword != null) {
                this.AdjustFlagsAndWidth(newKeyword);
                this.newKeyword = newKeyword;
                return this;
            }
            var openBraceToken = <SyntaxToken>reader.ReadValue();
            if (openBraceToken != null) {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
                return this;
            }
            var initializers = <CSharpSyntaxNode>reader.ReadValue();
            if (initializers != null) {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
                return this;
            }
            var closeBraceToken = <SyntaxToken>reader.ReadValue();
            if (closeBraceToken != null) {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.initializers);
            writer.WriteValue(this.closeBraceToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AnonymousObjectCreationExpressionSyntax().ctor_2376(r);
        }
    }

    export class ArrayCreationExpressionSyntax extends ExpressionSyntax {
        newKeyword: SyntaxToken;
        type: ArrayTypeSyntax;
        initializer: InitializerExpressionSyntax;

        constructor() { super(); }
        ctor_9880(kind: SyntaxKind, newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArrayCreationExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            return this;
        }


        ctor_8413(kind: SyntaxKind, newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax, context: SyntaxFactoryContext): ArrayCreationExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            return this;
        }


        ctor_1874(kind: SyntaxKind, newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax): ArrayCreationExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            return this;
        }

        public get NewKeyword(): SyntaxToken { return this.newKeyword; }
        public get Type(): ArrayTypeSyntax { return this.type; }
        public get Initializer(): InitializerExpressionSyntax { return this.initializer; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.newKeyword;
                case 1: return this.type;
                case 2: return this.initializer;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ArrayCreationExpressionSyntax().ctor_4775(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitArrayCreationExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitArrayCreationExpression(this);
        }

        public Update(newKeyword: SyntaxToken, type: ArrayTypeSyntax, initializer: InitializerExpressionSyntax): ArrayCreationExpressionSyntax {
            if (newKeyword != this.NewKeyword || type != this.Type || initializer != this.Initializer) {
                var newNode = SyntaxFactory.ArrayCreationExpression(newKeyword, type, initializer);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ArrayCreationExpressionSyntax().ctor_9880(this.Kind, this.newKeyword, this.type, this.initializer, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ArrayCreationExpressionSyntax().ctor_9880(this.Kind, this.newKeyword, this.type, this.initializer, this.GetDiagnostics(), annotations);
        }

        public ctor_1440(reader: Roslyn.Utilities.ObjectReader): ArrayCreationExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 3;
            var newKeyword = <SyntaxToken>reader.ReadValue();
            if (newKeyword != null) {
                this.AdjustFlagsAndWidth(newKeyword);
                this.newKeyword = newKeyword;
                return this;
            }
            var type = <ArrayTypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var initializer = <InitializerExpressionSyntax>reader.ReadValue();
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.initializer);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ArrayCreationExpressionSyntax().ctor_1440(r);
        }
    }

    export class ImplicitArrayCreationExpressionSyntax extends ExpressionSyntax {
        newKeyword: SyntaxToken;
        openBracketToken: SyntaxToken;
        commas: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;
        initializer: InitializerExpressionSyntax;

        constructor() { super(); }
        ctor_4848(kind: SyntaxKind, newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: CSharpSyntaxNode, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ImplicitArrayCreationExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (commas != null) {
                this.AdjustFlagsAndWidth(commas);
                this.commas = commas;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
            return this;
        }


        ctor_2068(kind: SyntaxKind, newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: CSharpSyntaxNode, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax, context: SyntaxFactoryContext): ImplicitArrayCreationExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (commas != null) {
                this.AdjustFlagsAndWidth(commas);
                this.commas = commas;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
            return this;
        }


        ctor_1986(kind: SyntaxKind, newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: CSharpSyntaxNode, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax): ImplicitArrayCreationExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (commas != null) {
                this.AdjustFlagsAndWidth(commas);
                this.commas = commas;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
            return this;
        }

        public get NewKeyword(): SyntaxToken { return this.newKeyword; }
        public get OpenBracketToken(): SyntaxToken { return this.openBracketToken; }
        public get Commas(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.commas); }
        public get CloseBracketToken(): SyntaxToken { return this.closeBracketToken; }
        public get Initializer(): InitializerExpressionSyntax { return this.initializer; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.newKeyword;
                case 1: return this.openBracketToken;
                case 2: return this.commas;
                case 3: return this.closeBracketToken;
                case 4: return this.initializer;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ImplicitArrayCreationExpressionSyntax().ctor_1315(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitImplicitArrayCreationExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitImplicitArrayCreationExpression(this);
        }

        public Update(newKeyword: SyntaxToken, openBracketToken: SyntaxToken, commas: SyntaxList<SyntaxToken>, closeBracketToken: SyntaxToken, initializer: InitializerExpressionSyntax): ImplicitArrayCreationExpressionSyntax {
            if (newKeyword != this.NewKeyword || openBracketToken != this.OpenBracketToken || commas != this.Commas || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer) {
                var newNode = SyntaxFactory.ImplicitArrayCreationExpression(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ImplicitArrayCreationExpressionSyntax().ctor_4848(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ImplicitArrayCreationExpressionSyntax().ctor_4848(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, this.GetDiagnostics(), annotations);
        }

        public ctor_9483(reader: Roslyn.Utilities.ObjectReader): ImplicitArrayCreationExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 5;
            var newKeyword = <SyntaxToken>reader.ReadValue();
            if (newKeyword != null) {
                this.AdjustFlagsAndWidth(newKeyword);
                this.newKeyword = newKeyword;
                return this;
            }
            var openBracketToken = <SyntaxToken>reader.ReadValue();
            if (openBracketToken != null) {
                this.AdjustFlagsAndWidth(openBracketToken);
                this.openBracketToken = openBracketToken;
                return this;
            }
            var commas = <CSharpSyntaxNode>reader.ReadValue();
            if (commas != null) {
                this.AdjustFlagsAndWidth(commas);
                this.commas = commas;
                return this;
            }
            var closeBracketToken = <SyntaxToken>reader.ReadValue();
            if (closeBracketToken != null) {
                this.AdjustFlagsAndWidth(closeBracketToken);
                this.closeBracketToken = closeBracketToken;
                return this;
            }
            var initializer = <InitializerExpressionSyntax>reader.ReadValue();
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.commas);
            writer.WriteValue(this.closeBracketToken);
            writer.WriteValue(this.initializer);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ImplicitArrayCreationExpressionSyntax().ctor_9483(r);
        }
    }

    export class StackAllocArrayCreationExpressionSyntax extends ExpressionSyntax {
        stackAllocKeyword: SyntaxToken;
        type: TypeSyntax;

        constructor() { super(); }
        ctor_3935(kind: SyntaxKind, stackAllocKeyword: SyntaxToken, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): StackAllocArrayCreationExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }


        ctor_7608(kind: SyntaxKind, stackAllocKeyword: SyntaxToken, type: TypeSyntax, context: SyntaxFactoryContext): StackAllocArrayCreationExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }


        ctor_4738(kind: SyntaxKind, stackAllocKeyword: SyntaxToken, type: TypeSyntax): StackAllocArrayCreationExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }

        public get StackAllocKeyword(): SyntaxToken { return this.stackAllocKeyword; }
        public get Type(): TypeSyntax { return this.type; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.stackAllocKeyword;
                case 1: return this.type;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.StackAllocArrayCreationExpressionSyntax().ctor_1350(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitStackAllocArrayCreationExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitStackAllocArrayCreationExpression(this);
        }

        public Update(stackAllocKeyword: SyntaxToken, type: TypeSyntax): StackAllocArrayCreationExpressionSyntax {
            if (stackAllocKeyword != this.StackAllocKeyword || type != this.Type) {
                var newNode = SyntaxFactory.StackAllocArrayCreationExpression(stackAllocKeyword, type);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new StackAllocArrayCreationExpressionSyntax().ctor_3935(this.Kind, this.stackAllocKeyword, this.type, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new StackAllocArrayCreationExpressionSyntax().ctor_3935(this.Kind, this.stackAllocKeyword, this.type, this.GetDiagnostics(), annotations);
        }

        public ctor_1294(reader: Roslyn.Utilities.ObjectReader): StackAllocArrayCreationExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 2;
            var stackAllocKeyword = <SyntaxToken>reader.ReadValue();
            if (stackAllocKeyword != null) {
                this.AdjustFlagsAndWidth(stackAllocKeyword);
                this.stackAllocKeyword = stackAllocKeyword;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.stackAllocKeyword);
            writer.WriteValue(this.type);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new StackAllocArrayCreationExpressionSyntax().ctor_1294(r);
        }
    }

    export class QueryClauseSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_1932(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QueryClauseSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_1564(kind: SyntaxKind): QueryClauseSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_1866(reader: Roslyn.Utilities.ObjectReader): QueryClauseSyntax {
            super.ctor_4942(reader);
            return this;
        }
    }

    export class SelectOrGroupClauseSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_7482(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SelectOrGroupClauseSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_1930(kind: SyntaxKind): SelectOrGroupClauseSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_3529(reader: Roslyn.Utilities.ObjectReader): SelectOrGroupClauseSyntax {
            super.ctor_4942(reader);
            return this;
        }
    }

    export class QueryExpressionSyntax extends ExpressionSyntax {
        fromClause: FromClauseSyntax;
        body: QueryBodySyntax;

        constructor() { super(); }
        ctor_3053(kind: SyntaxKind, fromClause: FromClauseSyntax, body: QueryBodySyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QueryExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(fromClause);
            this.fromClause = fromClause;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }


        ctor_5301(kind: SyntaxKind, fromClause: FromClauseSyntax, body: QueryBodySyntax, context: SyntaxFactoryContext): QueryExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(fromClause);
            this.fromClause = fromClause;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }


        ctor_2030(kind: SyntaxKind, fromClause: FromClauseSyntax, body: QueryBodySyntax): QueryExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(fromClause);
            this.fromClause = fromClause;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }

        public get FromClause(): FromClauseSyntax { return this.fromClause; }
        public get Body(): QueryBodySyntax { return this.body; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.fromClause;
                case 1: return this.body;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.QueryExpressionSyntax().ctor_1529(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitQueryExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitQueryExpression(this);
        }

        public Update(fromClause: FromClauseSyntax, body: QueryBodySyntax): QueryExpressionSyntax {
            if (fromClause != this.FromClause || body != this.Body) {
                var newNode = SyntaxFactory.QueryExpression(fromClause, body);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new QueryExpressionSyntax().ctor_3053(this.Kind, this.fromClause, this.body, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new QueryExpressionSyntax().ctor_3053(this.Kind, this.fromClause, this.body, this.GetDiagnostics(), annotations);
        }

        public ctor_3825(reader: Roslyn.Utilities.ObjectReader): QueryExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 2;
            var fromClause = <FromClauseSyntax>reader.ReadValue();
            if (fromClause != null) {
                this.AdjustFlagsAndWidth(fromClause);
                this.fromClause = fromClause;
                return this;
            }
            var body = <QueryBodySyntax>reader.ReadValue();
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.fromClause);
            writer.WriteValue(this.body);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new QueryExpressionSyntax().ctor_3825(r);
        }
    }

    export class QueryBodySyntax extends CSharpSyntaxNode {
        clauses: CSharpSyntaxNode;
        selectOrGroup: SelectOrGroupClauseSyntax;
        continuation: QueryContinuationSyntax;

        constructor() { super(); }
        ctor_7438(kind: SyntaxKind, clauses: CSharpSyntaxNode, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QueryBodySyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            if (clauses != null) {
                this.AdjustFlagsAndWidth(clauses);
                this.clauses = clauses;
            }
            this.AdjustFlagsAndWidth(selectOrGroup);
            this.selectOrGroup = selectOrGroup;
            if (continuation != null) {
                this.AdjustFlagsAndWidth(continuation);
                this.continuation = continuation;
            }
            return this;
        }


        ctor_7581(kind: SyntaxKind, clauses: CSharpSyntaxNode, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax, context: SyntaxFactoryContext): QueryBodySyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            if (clauses != null) {
                this.AdjustFlagsAndWidth(clauses);
                this.clauses = clauses;
            }
            this.AdjustFlagsAndWidth(selectOrGroup);
            this.selectOrGroup = selectOrGroup;
            if (continuation != null) {
                this.AdjustFlagsAndWidth(continuation);
                this.continuation = continuation;
            }
            return this;
        }


        ctor_1652(kind: SyntaxKind, clauses: CSharpSyntaxNode, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax): QueryBodySyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            if (clauses != null) {
                this.AdjustFlagsAndWidth(clauses);
                this.clauses = clauses;
            }
            this.AdjustFlagsAndWidth(selectOrGroup);
            this.selectOrGroup = selectOrGroup;
            if (continuation != null) {
                this.AdjustFlagsAndWidth(continuation);
                this.continuation = continuation;
            }
            return this;
        }

        public get Clauses(): SyntaxList<QueryClauseSyntax> { return new SyntaxList<QueryClauseSyntax>().ctor_1319(this.clauses); }
        public get SelectOrGroup(): SelectOrGroupClauseSyntax { return this.selectOrGroup; }
        public get Continuation(): QueryContinuationSyntax { return this.continuation; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.clauses;
                case 1: return this.selectOrGroup;
                case 2: return this.continuation;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.QueryBodySyntax().ctor_1968(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitQueryBody(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitQueryBody(this);
        }

        public Update(clauses: SyntaxList<QueryClauseSyntax>, selectOrGroup: SelectOrGroupClauseSyntax, continuation: QueryContinuationSyntax): QueryBodySyntax {
            if (clauses != this.Clauses || selectOrGroup != this.SelectOrGroup || continuation != this.Continuation) {
                var newNode = SyntaxFactory.QueryBody(clauses, selectOrGroup, continuation);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new QueryBodySyntax().ctor_7438(this.Kind, this.clauses, this.selectOrGroup, this.continuation, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new QueryBodySyntax().ctor_7438(this.Kind, this.clauses, this.selectOrGroup, this.continuation, this.GetDiagnostics(), annotations);
        }

        public ctor_2679(reader: Roslyn.Utilities.ObjectReader): QueryBodySyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var clauses = <CSharpSyntaxNode>reader.ReadValue();
            if (clauses != null) {
                this.AdjustFlagsAndWidth(clauses);
                this.clauses = clauses;
                return this;
            }
            var selectOrGroup = <SelectOrGroupClauseSyntax>reader.ReadValue();
            if (selectOrGroup != null) {
                this.AdjustFlagsAndWidth(selectOrGroup);
                this.selectOrGroup = selectOrGroup;
                return this;
            }
            var continuation = <QueryContinuationSyntax>reader.ReadValue();
            if (continuation != null) {
                this.AdjustFlagsAndWidth(continuation);
                this.continuation = continuation;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.clauses);
            writer.WriteValue(this.selectOrGroup);
            writer.WriteValue(this.continuation);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new QueryBodySyntax().ctor_2679(r);
        }
    }

    export class FromClauseSyntax extends QueryClauseSyntax {
        fromKeyword: SyntaxToken;
        type: TypeSyntax;
        identifier: SyntaxToken;
        inKeyword: SyntaxToken;
        expression: ExpressionSyntax;

        constructor() { super(); }
        ctor_3554(kind: SyntaxKind, fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): FromClauseSyntax {
            super.ctor_1932(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1976(kind: SyntaxKind, fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): FromClauseSyntax {
            super.ctor_1564(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1051(kind: SyntaxKind, fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax): FromClauseSyntax {
            super.ctor_1564(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }

        public get FromKeyword(): SyntaxToken { return this.fromKeyword; }
        public get Type(): TypeSyntax { return this.type; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get InKeyword(): SyntaxToken { return this.inKeyword; }
        public get Expression(): ExpressionSyntax { return this.expression; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.fromKeyword;
                case 1: return this.type;
                case 2: return this.identifier;
                case 3: return this.inKeyword;
                case 4: return this.expression;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.FromClauseSyntax().ctor_1530(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitFromClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitFromClause(this);
        }

        public Update(fromKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax): FromClauseSyntax {
            if (fromKeyword != this.FromKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression) {
                var newNode = SyntaxFactory.FromClause(fromKeyword, type, identifier, inKeyword, expression);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new FromClauseSyntax().ctor_3554(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new FromClauseSyntax().ctor_3554(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, this.GetDiagnostics(), annotations);
        }

        public ctor_1931(reader: Roslyn.Utilities.ObjectReader): FromClauseSyntax {
            super.ctor_1866(reader);
            this.SlotCount = 5;
            var fromKeyword = <SyntaxToken>reader.ReadValue();
            if (fromKeyword != null) {
                this.AdjustFlagsAndWidth(fromKeyword);
                this.fromKeyword = fromKeyword;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var inKeyword = <SyntaxToken>reader.ReadValue();
            if (inKeyword != null) {
                this.AdjustFlagsAndWidth(inKeyword);
                this.inKeyword = inKeyword;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.fromKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.expression);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new FromClauseSyntax().ctor_1931(r);
        }
    }

    export class LetClauseSyntax extends QueryClauseSyntax {
        letKeyword: SyntaxToken;
        identifier: SyntaxToken;
        equalsToken: SyntaxToken;
        expression: ExpressionSyntax;

        constructor() { super(); }
        ctor_1276(kind: SyntaxKind, letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LetClauseSyntax {
            super.ctor_1932(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(letKeyword);
            this.letKeyword = letKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_2126_C(kind: SyntaxKind, letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): LetClauseSyntax {
            super.ctor_1564(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(letKeyword);
            this.letKeyword = letKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1414(kind: SyntaxKind, letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax): LetClauseSyntax {
            super.ctor_1564(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(letKeyword);
            this.letKeyword = letKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }

        public get LetKeyword(): SyntaxToken { return this.letKeyword; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get EqualsToken(): SyntaxToken { return this.equalsToken; }
        public get Expression(): ExpressionSyntax { return this.expression; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.letKeyword;
                case 1: return this.identifier;
                case 2: return this.equalsToken;
                case 3: return this.expression;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.LetClauseSyntax().ctor_7080(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitLetClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitLetClause(this);
        }

        public Update(letKeyword: SyntaxToken, identifier: SyntaxToken, equalsToken: SyntaxToken, expression: ExpressionSyntax): LetClauseSyntax {
            if (letKeyword != this.LetKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || expression != this.Expression) {
                var newNode = SyntaxFactory.LetClause(letKeyword, identifier, equalsToken, expression);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new LetClauseSyntax().ctor_1276(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new LetClauseSyntax().ctor_1276(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, this.GetDiagnostics(), annotations);
        }

        public ctor_9915(reader: Roslyn.Utilities.ObjectReader): LetClauseSyntax {
            super.ctor_1866(reader);
            this.SlotCount = 4;
            var letKeyword = <SyntaxToken>reader.ReadValue();
            if (letKeyword != null) {
                this.AdjustFlagsAndWidth(letKeyword);
                this.letKeyword = letKeyword;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var equalsToken = <SyntaxToken>reader.ReadValue();
            if (equalsToken != null) {
                this.AdjustFlagsAndWidth(equalsToken);
                this.equalsToken = equalsToken;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.letKeyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.expression);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new LetClauseSyntax().ctor_9915(r);
        }
    }

    export class JoinClauseSyntax extends QueryClauseSyntax {
        joinKeyword: SyntaxToken;
        type: TypeSyntax;
        identifier: SyntaxToken;
        inKeyword: SyntaxToken;
        inExpression: ExpressionSyntax;
        onKeyword: SyntaxToken;
        leftExpression: ExpressionSyntax;
        equalsKeyword: SyntaxToken;
        rightExpression: ExpressionSyntax;
        into: JoinIntoClauseSyntax;

        constructor() { super(); }
        ctor_8701(kind: SyntaxKind, joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): JoinClauseSyntax {
            super.ctor_1932(kind, diagnostics, annotations);
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(joinKeyword);
            this.joinKeyword = joinKeyword;
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(inExpression);
            this.inExpression = inExpression;
            this.AdjustFlagsAndWidth(onKeyword);
            this.onKeyword = onKeyword;
            this.AdjustFlagsAndWidth(leftExpression);
            this.leftExpression = leftExpression;
            this.AdjustFlagsAndWidth(equalsKeyword);
            this.equalsKeyword = equalsKeyword;
            this.AdjustFlagsAndWidth(rightExpression);
            this.rightExpression = rightExpression;
            if (into != null) {
                this.AdjustFlagsAndWidth(into);
                this.into = into;
            }
            return this;
        }


        ctor_1488(kind: SyntaxKind, joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax, context: SyntaxFactoryContext): JoinClauseSyntax {
            super.ctor_1564(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(joinKeyword);
            this.joinKeyword = joinKeyword;
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(inExpression);
            this.inExpression = inExpression;
            this.AdjustFlagsAndWidth(onKeyword);
            this.onKeyword = onKeyword;
            this.AdjustFlagsAndWidth(leftExpression);
            this.leftExpression = leftExpression;
            this.AdjustFlagsAndWidth(equalsKeyword);
            this.equalsKeyword = equalsKeyword;
            this.AdjustFlagsAndWidth(rightExpression);
            this.rightExpression = rightExpression;
            if (into != null) {
                this.AdjustFlagsAndWidth(into);
                this.into = into;
            }
            return this;
        }


        ctor_8909(kind: SyntaxKind, joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax): JoinClauseSyntax {
            super.ctor_1564(kind);
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(joinKeyword);
            this.joinKeyword = joinKeyword;
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(inExpression);
            this.inExpression = inExpression;
            this.AdjustFlagsAndWidth(onKeyword);
            this.onKeyword = onKeyword;
            this.AdjustFlagsAndWidth(leftExpression);
            this.leftExpression = leftExpression;
            this.AdjustFlagsAndWidth(equalsKeyword);
            this.equalsKeyword = equalsKeyword;
            this.AdjustFlagsAndWidth(rightExpression);
            this.rightExpression = rightExpression;
            if (into != null) {
                this.AdjustFlagsAndWidth(into);
                this.into = into;
            }
            return this;
        }

        public get JoinKeyword(): SyntaxToken { return this.joinKeyword; }
        public get Type(): TypeSyntax { return this.type; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get InKeyword(): SyntaxToken { return this.inKeyword; }
        public get InExpression(): ExpressionSyntax { return this.inExpression; }
        public get OnKeyword(): SyntaxToken { return this.onKeyword; }
        public get LeftExpression(): ExpressionSyntax { return this.leftExpression; }
        public get EqualsKeyword(): SyntaxToken { return this.equalsKeyword; }
        public get RightExpression(): ExpressionSyntax { return this.rightExpression; }
        public get Into(): JoinIntoClauseSyntax { return this.into; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.joinKeyword;
                case 1: return this.type;
                case 2: return this.identifier;
                case 3: return this.inKeyword;
                case 4: return this.inExpression;
                case 5: return this.onKeyword;
                case 6: return this.leftExpression;
                case 7: return this.equalsKeyword;
                case 8: return this.rightExpression;
                case 9: return this.into;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.JoinClauseSyntax().ctor_1474(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitJoinClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitJoinClause(this);
        }

        public Update(joinKeyword: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, inExpression: ExpressionSyntax, onKeyword: SyntaxToken, leftExpression: ExpressionSyntax, equalsKeyword: SyntaxToken, rightExpression: ExpressionSyntax, into: JoinIntoClauseSyntax): JoinClauseSyntax {
            if (joinKeyword != this.JoinKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || inExpression != this.InExpression || onKeyword != this.OnKeyword || leftExpression != this.LeftExpression || equalsKeyword != this.EqualsKeyword || rightExpression != this.RightExpression || into != this.Into) {
                var newNode = SyntaxFactory.JoinClause(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new JoinClauseSyntax().ctor_8701(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new JoinClauseSyntax().ctor_8701(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, this.GetDiagnostics(), annotations);
        }

        public ctor_1603(reader: Roslyn.Utilities.ObjectReader): JoinClauseSyntax {
            super.ctor_1866(reader);
            this.SlotCount = 10;
            var joinKeyword = <SyntaxToken>reader.ReadValue();
            if (joinKeyword != null) {
                this.AdjustFlagsAndWidth(joinKeyword);
                this.joinKeyword = joinKeyword;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var inKeyword = <SyntaxToken>reader.ReadValue();
            if (inKeyword != null) {
                this.AdjustFlagsAndWidth(inKeyword);
                this.inKeyword = inKeyword;
                return this;
            }
            var inExpression = <ExpressionSyntax>reader.ReadValue();
            if (inExpression != null) {
                this.AdjustFlagsAndWidth(inExpression);
                this.inExpression = inExpression;
                return this;
            }
            var onKeyword = <SyntaxToken>reader.ReadValue();
            if (onKeyword != null) {
                this.AdjustFlagsAndWidth(onKeyword);
                this.onKeyword = onKeyword;
                return this;
            }
            var leftExpression = <ExpressionSyntax>reader.ReadValue();
            if (leftExpression != null) {
                this.AdjustFlagsAndWidth(leftExpression);
                this.leftExpression = leftExpression;
                return this;
            }
            var equalsKeyword = <SyntaxToken>reader.ReadValue();
            if (equalsKeyword != null) {
                this.AdjustFlagsAndWidth(equalsKeyword);
                this.equalsKeyword = equalsKeyword;
                return this;
            }
            var rightExpression = <ExpressionSyntax>reader.ReadValue();
            if (rightExpression != null) {
                this.AdjustFlagsAndWidth(rightExpression);
                this.rightExpression = rightExpression;
                return this;
            }
            var into = <JoinIntoClauseSyntax>reader.ReadValue();
            if (into != null) {
                this.AdjustFlagsAndWidth(into);
                this.into = into;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.joinKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.inExpression);
            writer.WriteValue(this.onKeyword);
            writer.WriteValue(this.leftExpression);
            writer.WriteValue(this.equalsKeyword);
            writer.WriteValue(this.rightExpression);
            writer.WriteValue(this.into);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new JoinClauseSyntax().ctor_1603(r);
        }
    }

    export class JoinIntoClauseSyntax extends CSharpSyntaxNode {
        intoKeyword: SyntaxToken;
        identifier: SyntaxToken;

        constructor() { super(); }
        ctor_1709(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): JoinIntoClauseSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            return this;
        }


        ctor_1921(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken, context: SyntaxFactoryContext): JoinIntoClauseSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            return this;
        }


        ctor_7536(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken): JoinIntoClauseSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            return this;
        }

        public get IntoKeyword(): SyntaxToken { return this.intoKeyword; }
        public get Identifier(): SyntaxToken { return this.identifier; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.intoKeyword;
                case 1: return this.identifier;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.JoinIntoClauseSyntax().ctor_3874(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitJoinIntoClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitJoinIntoClause(this);
        }

        public Update(intoKeyword: SyntaxToken, identifier: SyntaxToken): JoinIntoClauseSyntax {
            if (intoKeyword != this.IntoKeyword || identifier != this.Identifier) {
                var newNode = SyntaxFactory.JoinIntoClause(intoKeyword, identifier);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new JoinIntoClauseSyntax().ctor_1709(this.Kind, this.intoKeyword, this.identifier, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new JoinIntoClauseSyntax().ctor_1709(this.Kind, this.intoKeyword, this.identifier, this.GetDiagnostics(), annotations);
        }

        public ctor_8645(reader: Roslyn.Utilities.ObjectReader): JoinIntoClauseSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var intoKeyword = <SyntaxToken>reader.ReadValue();
            if (intoKeyword != null) {
                this.AdjustFlagsAndWidth(intoKeyword);
                this.intoKeyword = intoKeyword;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.intoKeyword);
            writer.WriteValue(this.identifier);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new JoinIntoClauseSyntax().ctor_8645(r);
        }
    }

    export class WhereClauseSyntax extends QueryClauseSyntax {
        whereKeyword: SyntaxToken;
        condition: ExpressionSyntax;

        constructor() { super(); }
        ctor_6935(kind: SyntaxKind, whereKeyword: SyntaxToken, condition: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): WhereClauseSyntax {
            super.ctor_1932(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            return this;
        }


        ctor_9416(kind: SyntaxKind, whereKeyword: SyntaxToken, condition: ExpressionSyntax, context: SyntaxFactoryContext): WhereClauseSyntax {
            super.ctor_1564(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            return this;
        }


        ctor_4278(kind: SyntaxKind, whereKeyword: SyntaxToken, condition: ExpressionSyntax): WhereClauseSyntax {
            super.ctor_1564(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            return this;
        }

        public get WhereKeyword(): SyntaxToken { return this.whereKeyword; }
        public get Condition(): ExpressionSyntax { return this.condition; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.whereKeyword;
                case 1: return this.condition;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.WhereClauseSyntax().ctor_6964(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitWhereClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitWhereClause(this);
        }

        public Update(whereKeyword: SyntaxToken, condition: ExpressionSyntax): WhereClauseSyntax {
            if (whereKeyword != this.WhereKeyword || condition != this.Condition) {
                var newNode = SyntaxFactory.WhereClause(whereKeyword, condition);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new WhereClauseSyntax().ctor_6935(this.Kind, this.whereKeyword, this.condition, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new WhereClauseSyntax().ctor_6935(this.Kind, this.whereKeyword, this.condition, this.GetDiagnostics(), annotations);
        }

        public ctor_1570(reader: Roslyn.Utilities.ObjectReader): WhereClauseSyntax {
            super.ctor_1866(reader);
            this.SlotCount = 2;
            var whereKeyword = <SyntaxToken>reader.ReadValue();
            if (whereKeyword != null) {
                this.AdjustFlagsAndWidth(whereKeyword);
                this.whereKeyword = whereKeyword;
                return this;
            }
            var condition = <ExpressionSyntax>reader.ReadValue();
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.whereKeyword);
            writer.WriteValue(this.condition);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new WhereClauseSyntax().ctor_1570(r);
        }
    }

    export class OrderByClauseSyntax extends QueryClauseSyntax {
        orderByKeyword: SyntaxToken;
        orderings: CSharpSyntaxNode;

        constructor() { super(); }
        ctor_1884(kind: SyntaxKind, orderByKeyword: SyntaxToken, orderings: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OrderByClauseSyntax {
            super.ctor_1932(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(orderByKeyword);
            this.orderByKeyword = orderByKeyword;
            if (orderings != null) {
                this.AdjustFlagsAndWidth(orderings);
                this.orderings = orderings;
            }
            return this;
        }


        ctor_6779(kind: SyntaxKind, orderByKeyword: SyntaxToken, orderings: CSharpSyntaxNode, context: SyntaxFactoryContext): OrderByClauseSyntax {
            super.ctor_1564(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(orderByKeyword);
            this.orderByKeyword = orderByKeyword;
            if (orderings != null) {
                this.AdjustFlagsAndWidth(orderings);
                this.orderings = orderings;
            }
            return this;
        }


        ctor_1533(kind: SyntaxKind, orderByKeyword: SyntaxToken, orderings: CSharpSyntaxNode): OrderByClauseSyntax {
            super.ctor_1564(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(orderByKeyword);
            this.orderByKeyword = orderByKeyword;
            if (orderings != null) {
                this.AdjustFlagsAndWidth(orderings);
                this.orderings = orderings;
            }
            return this;
        }

        public get OrderByKeyword(): SyntaxToken { return this.orderByKeyword; }
        public get Orderings(): SeparatedSyntaxList<OrderingSyntax> { return new SeparatedSyntaxList<OrderingSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.orderings)); }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.orderByKeyword;
                case 1: return this.orderings;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.OrderByClauseSyntax().ctor_7165(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitOrderByClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitOrderByClause(this);
        }

        public Update(orderByKeyword: SyntaxToken, orderings: SeparatedSyntaxList<OrderingSyntax>): OrderByClauseSyntax {
            if (orderByKeyword != this.OrderByKeyword || orderings != this.Orderings) {
                var newNode = SyntaxFactory.OrderByClause(orderByKeyword, orderings);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new OrderByClauseSyntax().ctor_1884(this.Kind, this.orderByKeyword, this.orderings, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new OrderByClauseSyntax().ctor_1884(this.Kind, this.orderByKeyword, this.orderings, this.GetDiagnostics(), annotations);
        }

        public ctor_1045(reader: Roslyn.Utilities.ObjectReader): OrderByClauseSyntax {
            super.ctor_1866(reader);
            this.SlotCount = 2;
            var orderByKeyword = <SyntaxToken>reader.ReadValue();
            if (orderByKeyword != null) {
                this.AdjustFlagsAndWidth(orderByKeyword);
                this.orderByKeyword = orderByKeyword;
                return this;
            }
            var orderings = <CSharpSyntaxNode>reader.ReadValue();
            if (orderings != null) {
                this.AdjustFlagsAndWidth(orderings);
                this.orderings = orderings;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.orderByKeyword);
            writer.WriteValue(this.orderings);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new OrderByClauseSyntax().ctor_1045(r);
        }
    }

    export class OrderingSyntax extends CSharpSyntaxNode {
        expression: ExpressionSyntax;
        ascendingOrDescendingKeyword: SyntaxToken;

        constructor() { super(); }
        ctor_6381(kind: SyntaxKind, expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OrderingSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (ascendingOrDescendingKeyword != null) {
                this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
                this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
            }
            return this;
        }


        ctor_7726(kind: SyntaxKind, expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken, context: SyntaxFactoryContext): OrderingSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (ascendingOrDescendingKeyword != null) {
                this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
                this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
            }
            return this;
        }


        ctor_1862(kind: SyntaxKind, expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken): OrderingSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (ascendingOrDescendingKeyword != null) {
                this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
                this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
            }
            return this;
        }

        public get Expression(): ExpressionSyntax { return this.expression; }
        public get AscendingOrDescendingKeyword(): SyntaxToken { return this.ascendingOrDescendingKeyword; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.expression;
                case 1: return this.ascendingOrDescendingKeyword;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.OrderingSyntax().ctor_1222(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitOrdering(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitOrdering(this);
        }

        public Update(expression: ExpressionSyntax, ascendingOrDescendingKeyword: SyntaxToken): OrderingSyntax {
            if (expression != this.Expression || ascendingOrDescendingKeyword != this.AscendingOrDescendingKeyword) {
                var newNode = SyntaxFactory.Ordering(this.Kind, expression, ascendingOrDescendingKeyword);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new OrderingSyntax().ctor_6381(this.Kind, this.expression, this.ascendingOrDescendingKeyword, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new OrderingSyntax().ctor_6381(this.Kind, this.expression, this.ascendingOrDescendingKeyword, this.GetDiagnostics(), annotations);
        }

        public ctor_2023(reader: Roslyn.Utilities.ObjectReader): OrderingSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var ascendingOrDescendingKeyword = <SyntaxToken>reader.ReadValue();
            if (ascendingOrDescendingKeyword != null) {
                this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
                this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.ascendingOrDescendingKeyword);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new OrderingSyntax().ctor_2023(r);
        }
    }

    export class SelectClauseSyntax extends SelectOrGroupClauseSyntax {
        selectKeyword: SyntaxToken;
        expression: ExpressionSyntax;

        constructor() { super(); }
        ctor_2623(kind: SyntaxKind, selectKeyword: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SelectClauseSyntax {
            super.ctor_7482(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(selectKeyword);
            this.selectKeyword = selectKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1469(kind: SyntaxKind, selectKeyword: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): SelectClauseSyntax {
            super.ctor_1930(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(selectKeyword);
            this.selectKeyword = selectKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_3738(kind: SyntaxKind, selectKeyword: SyntaxToken, expression: ExpressionSyntax): SelectClauseSyntax {
            super.ctor_1930(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(selectKeyword);
            this.selectKeyword = selectKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }

        public get SelectKeyword(): SyntaxToken { return this.selectKeyword; }
        public get Expression(): ExpressionSyntax { return this.expression; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.selectKeyword;
                case 1: return this.expression;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.SelectClauseSyntax().ctor_2370(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitSelectClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitSelectClause(this);
        }

        public Update(selectKeyword: SyntaxToken, expression: ExpressionSyntax): SelectClauseSyntax {
            if (selectKeyword != this.SelectKeyword || expression != this.Expression) {
                var newNode = SyntaxFactory.SelectClause(selectKeyword, expression);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new SelectClauseSyntax().ctor_2623(this.Kind, this.selectKeyword, this.expression, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new SelectClauseSyntax().ctor_2623(this.Kind, this.selectKeyword, this.expression, this.GetDiagnostics(), annotations);
        }

        public ctor_6921(reader: Roslyn.Utilities.ObjectReader): SelectClauseSyntax {
            super.ctor_3529(reader);
            this.SlotCount = 2;
            var selectKeyword = <SyntaxToken>reader.ReadValue();
            if (selectKeyword != null) {
                this.AdjustFlagsAndWidth(selectKeyword);
                this.selectKeyword = selectKeyword;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.selectKeyword);
            writer.WriteValue(this.expression);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new SelectClauseSyntax().ctor_6921(r);
        }
    }

    export class GroupClauseSyntax extends SelectOrGroupClauseSyntax {
        groupKeyword: SyntaxToken;
        groupExpression: ExpressionSyntax;
        byKeyword: SyntaxToken;
        byExpression: ExpressionSyntax;

        constructor() { super(); }
        ctor_3590(kind: SyntaxKind, groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): GroupClauseSyntax {
            super.ctor_7482(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(groupKeyword);
            this.groupKeyword = groupKeyword;
            this.AdjustFlagsAndWidth(groupExpression);
            this.groupExpression = groupExpression;
            this.AdjustFlagsAndWidth(byKeyword);
            this.byKeyword = byKeyword;
            this.AdjustFlagsAndWidth(byExpression);
            this.byExpression = byExpression;
            return this;
        }


        ctor_9376(kind: SyntaxKind, groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax, context: SyntaxFactoryContext): GroupClauseSyntax {
            super.ctor_1930(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(groupKeyword);
            this.groupKeyword = groupKeyword;
            this.AdjustFlagsAndWidth(groupExpression);
            this.groupExpression = groupExpression;
            this.AdjustFlagsAndWidth(byKeyword);
            this.byKeyword = byKeyword;
            this.AdjustFlagsAndWidth(byExpression);
            this.byExpression = byExpression;
            return this;
        }


        ctor_7027(kind: SyntaxKind, groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax): GroupClauseSyntax {
            super.ctor_1930(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(groupKeyword);
            this.groupKeyword = groupKeyword;
            this.AdjustFlagsAndWidth(groupExpression);
            this.groupExpression = groupExpression;
            this.AdjustFlagsAndWidth(byKeyword);
            this.byKeyword = byKeyword;
            this.AdjustFlagsAndWidth(byExpression);
            this.byExpression = byExpression;
            return this;
        }

        public get GroupKeyword(): SyntaxToken { return this.groupKeyword; }
        public get GroupExpression(): ExpressionSyntax { return this.groupExpression; }
        public get ByKeyword(): SyntaxToken { return this.byKeyword; }
        public get ByExpression(): ExpressionSyntax { return this.byExpression; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.groupKeyword;
                case 1: return this.groupExpression;
                case 2: return this.byKeyword;
                case 3: return this.byExpression;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.GroupClauseSyntax().ctor_3745(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitGroupClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitGroupClause(this);
        }

        public Update(groupKeyword: SyntaxToken, groupExpression: ExpressionSyntax, byKeyword: SyntaxToken, byExpression: ExpressionSyntax): GroupClauseSyntax {
            if (groupKeyword != this.GroupKeyword || groupExpression != this.GroupExpression || byKeyword != this.ByKeyword || byExpression != this.ByExpression) {
                var newNode = SyntaxFactory.GroupClause(groupKeyword, groupExpression, byKeyword, byExpression);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new GroupClauseSyntax().ctor_3590(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new GroupClauseSyntax().ctor_3590(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, this.GetDiagnostics(), annotations);
        }

        public ctor_6249(reader: Roslyn.Utilities.ObjectReader): GroupClauseSyntax {
            super.ctor_3529(reader);
            this.SlotCount = 4;
            var groupKeyword = <SyntaxToken>reader.ReadValue();
            if (groupKeyword != null) {
                this.AdjustFlagsAndWidth(groupKeyword);
                this.groupKeyword = groupKeyword;
                return this;
            }
            var groupExpression = <ExpressionSyntax>reader.ReadValue();
            if (groupExpression != null) {
                this.AdjustFlagsAndWidth(groupExpression);
                this.groupExpression = groupExpression;
                return this;
            }
            var byKeyword = <SyntaxToken>reader.ReadValue();
            if (byKeyword != null) {
                this.AdjustFlagsAndWidth(byKeyword);
                this.byKeyword = byKeyword;
                return this;
            }
            var byExpression = <ExpressionSyntax>reader.ReadValue();
            if (byExpression != null) {
                this.AdjustFlagsAndWidth(byExpression);
                this.byExpression = byExpression;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.groupKeyword);
            writer.WriteValue(this.groupExpression);
            writer.WriteValue(this.byKeyword);
            writer.WriteValue(this.byExpression);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new GroupClauseSyntax().ctor_6249(r);
        }
    }

    export class QueryContinuationSyntax extends CSharpSyntaxNode {
        intoKeyword: SyntaxToken;
        identifier: SyntaxToken;
        body: QueryBodySyntax;

        constructor() { super(); }
        ctor_1957(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QueryContinuationSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }


        ctor_5032(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax, context: SyntaxFactoryContext): QueryContinuationSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }


        ctor_1004(kind: SyntaxKind, intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax): QueryContinuationSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
            return this;
        }

        public get IntoKeyword(): SyntaxToken { return this.intoKeyword; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get Body(): QueryBodySyntax { return this.body; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.intoKeyword;
                case 1: return this.identifier;
                case 2: return this.body;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.QueryContinuationSyntax().ctor_9699(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitQueryContinuation(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitQueryContinuation(this);
        }

        public Update(intoKeyword: SyntaxToken, identifier: SyntaxToken, body: QueryBodySyntax): QueryContinuationSyntax {
            if (intoKeyword != this.IntoKeyword || identifier != this.Identifier || body != this.Body) {
                var newNode = SyntaxFactory.QueryContinuation(intoKeyword, identifier, body);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new QueryContinuationSyntax().ctor_1957(this.Kind, this.intoKeyword, this.identifier, this.body, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new QueryContinuationSyntax().ctor_1957(this.Kind, this.intoKeyword, this.identifier, this.body, this.GetDiagnostics(), annotations);
        }

        public ctor_1980(reader: Roslyn.Utilities.ObjectReader): QueryContinuationSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var intoKeyword = <SyntaxToken>reader.ReadValue();
            if (intoKeyword != null) {
                this.AdjustFlagsAndWidth(intoKeyword);
                this.intoKeyword = intoKeyword;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var body = <QueryBodySyntax>reader.ReadValue();
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.intoKeyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.body);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new QueryContinuationSyntax().ctor_1980(r);
        }
    }

    export class OmittedArraySizeExpressionSyntax extends ExpressionSyntax {
        omittedArraySizeExpressionToken: SyntaxToken;

        constructor() { super(); }
        ctor_6606(kind: SyntaxKind, omittedArraySizeExpressionToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OmittedArraySizeExpressionSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
            return this;
        }


        ctor_1827(kind: SyntaxKind, omittedArraySizeExpressionToken: SyntaxToken, context: SyntaxFactoryContext): OmittedArraySizeExpressionSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
            return this;
        }


        ctor_7988(kind: SyntaxKind, omittedArraySizeExpressionToken: SyntaxToken): OmittedArraySizeExpressionSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
            return this;
        }

        public get OmittedArraySizeExpressionToken(): SyntaxToken { return this.omittedArraySizeExpressionToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.omittedArraySizeExpressionToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.OmittedArraySizeExpressionSyntax().ctor_1950(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitOmittedArraySizeExpression(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitOmittedArraySizeExpression(this);
        }

        public Update(omittedArraySizeExpressionToken: SyntaxToken): OmittedArraySizeExpressionSyntax {
            if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken) {
                var newNode = SyntaxFactory.OmittedArraySizeExpression(omittedArraySizeExpressionToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new OmittedArraySizeExpressionSyntax().ctor_6606(this.Kind, this.omittedArraySizeExpressionToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new OmittedArraySizeExpressionSyntax().ctor_6606(this.Kind, this.omittedArraySizeExpressionToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2118(reader: Roslyn.Utilities.ObjectReader): OmittedArraySizeExpressionSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 1;
            var omittedArraySizeExpressionToken = <SyntaxToken>reader.ReadValue();
            if (omittedArraySizeExpressionToken != null) {
                this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
                this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.omittedArraySizeExpressionToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new OmittedArraySizeExpressionSyntax().ctor_2118(r);
        }
    }

    export class GlobalStatementSyntax extends MemberDeclarationSyntax {
        statement: StatementSyntax;

        constructor() { super(); }
        ctor_2457(kind: SyntaxKind, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): GlobalStatementSyntax {
            super.ctor_1870(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_1585(kind: SyntaxKind, statement: StatementSyntax, context: SyntaxFactoryContext): GlobalStatementSyntax {
            super.ctor_9655(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_1329(kind: SyntaxKind, statement: StatementSyntax): GlobalStatementSyntax {
            super.ctor_9655(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }

        public get Statement(): StatementSyntax { return this.statement; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.statement;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.GlobalStatementSyntax().ctor_1315(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitGlobalStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitGlobalStatement(this);
        }

        public Update(statement: StatementSyntax): GlobalStatementSyntax {
            if (statement != this.Statement) {
                var newNode = SyntaxFactory.GlobalStatement(statement);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new GlobalStatementSyntax().ctor_2457(this.Kind, this.statement, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new GlobalStatementSyntax().ctor_2457(this.Kind, this.statement, this.GetDiagnostics(), annotations);
        }

        public ctor_1383(reader: Roslyn.Utilities.ObjectReader): GlobalStatementSyntax {
            super.ctor_3031(reader);
            this.SlotCount = 1;
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.statement);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new GlobalStatementSyntax().ctor_1383(r);
        }
    }

    export class StatementSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_1815(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): StatementSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_9228(kind: SyntaxKind): StatementSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_1667(reader: Roslyn.Utilities.ObjectReader): StatementSyntax {
            super.ctor_4942(reader);
            return this;
        }
    }

    export class BlockSyntax extends StatementSyntax {
        openBraceToken: SyntaxToken;
        statements: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;

        constructor() { super(); }
        ctor_1043(kind: SyntaxKind, openBraceToken: SyntaxToken, statements: CSharpSyntaxNode, closeBraceToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BlockSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (statements != null) {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }


        ctor_2029(kind: SyntaxKind, openBraceToken: SyntaxToken, statements: CSharpSyntaxNode, closeBraceToken: SyntaxToken, context: SyntaxFactoryContext): BlockSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (statements != null) {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }


        ctor_6549(kind: SyntaxKind, openBraceToken: SyntaxToken, statements: CSharpSyntaxNode, closeBraceToken: SyntaxToken): BlockSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (statements != null) {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }

        public get OpenBraceToken(): SyntaxToken { return this.openBraceToken; }
        public get Statements(): SyntaxList<StatementSyntax> { return new SyntaxList<StatementSyntax>().ctor_1319(this.statements); }
        public get CloseBraceToken(): SyntaxToken { return this.closeBraceToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openBraceToken;
                case 1: return this.statements;
                case 2: return this.closeBraceToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.BlockSyntax().ctor_2388(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitBlock(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitBlock(this);
        }

        public Update(openBraceToken: SyntaxToken, statements: SyntaxList<StatementSyntax>, closeBraceToken: SyntaxToken): BlockSyntax {
            if (openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken) {
                var newNode = SyntaxFactory.Block(openBraceToken, statements, closeBraceToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new BlockSyntax().ctor_1043(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new BlockSyntax().ctor_1043(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, this.GetDiagnostics(), annotations);
        }

        public ctor_4813(reader: Roslyn.Utilities.ObjectReader): BlockSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 3;
            var openBraceToken = <SyntaxToken>reader.ReadValue();
            if (openBraceToken != null) {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
                return this;
            }
            var statements = <CSharpSyntaxNode>reader.ReadValue();
            if (statements != null) {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
                return this;
            }
            var closeBraceToken = <SyntaxToken>reader.ReadValue();
            if (closeBraceToken != null) {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.statements);
            writer.WriteValue(this.closeBraceToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new BlockSyntax().ctor_4813(r);
        }
    }

    export class LocalDeclarationStatementSyntax extends StatementSyntax {
        modifiers: CSharpSyntaxNode;
        declaration: VariableDeclarationSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1925(kind: SyntaxKind, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LocalDeclarationStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 3;
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_4906(kind: SyntaxKind, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): LocalDeclarationStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1978(kind: SyntaxKind, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): LocalDeclarationStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 3;
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Declaration(): VariableDeclarationSyntax { return this.declaration; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.modifiers;
                case 1: return this.declaration;
                case 2: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.LocalDeclarationStatementSyntax().ctor_1590(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitLocalDeclarationStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitLocalDeclarationStatement(this);
        }

        public Update(modifiers: SyntaxList<SyntaxToken>, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): LocalDeclarationStatementSyntax {
            if (modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.LocalDeclarationStatement(modifiers, declaration, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new LocalDeclarationStatementSyntax().ctor_1925(this.Kind, this.modifiers, this.declaration, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new LocalDeclarationStatementSyntax().ctor_1925(this.Kind, this.modifiers, this.declaration, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1933(reader: Roslyn.Utilities.ObjectReader): LocalDeclarationStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 3;
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var declaration = <VariableDeclarationSyntax>reader.ReadValue();
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new LocalDeclarationStatementSyntax().ctor_1933(r);
        }
    }

    export class VariableDeclarationSyntax extends CSharpSyntaxNode {
        type: TypeSyntax;
        variables: CSharpSyntaxNode;

        constructor() { super(); }
        ctor_5501(kind: SyntaxKind, type: TypeSyntax, variables: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): VariableDeclarationSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (variables != null) {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
            return this;
        }


        ctor_1234(kind: SyntaxKind, type: TypeSyntax, variables: CSharpSyntaxNode, context: SyntaxFactoryContext): VariableDeclarationSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (variables != null) {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
            return this;
        }


        ctor_1870(kind: SyntaxKind, type: TypeSyntax, variables: CSharpSyntaxNode): VariableDeclarationSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (variables != null) {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
            return this;
        }

        public get Type(): TypeSyntax { return this.type; }
        public get Variables(): SeparatedSyntaxList<VariableDeclaratorSyntax> { return new SeparatedSyntaxList<VariableDeclaratorSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.variables)); }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.type;
                case 1: return this.variables;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.VariableDeclarationSyntax().ctor_3026(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitVariableDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitVariableDeclaration(this);
        }

        public Update(type: TypeSyntax, variables: SeparatedSyntaxList<VariableDeclaratorSyntax>): VariableDeclarationSyntax {
            if (type != this.Type || variables != this.Variables) {
                var newNode = SyntaxFactory.VariableDeclaration(type, variables);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new VariableDeclarationSyntax().ctor_5501(this.Kind, this.type, this.variables, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new VariableDeclarationSyntax().ctor_5501(this.Kind, this.type, this.variables, this.GetDiagnostics(), annotations);
        }

        public ctor_1709(reader: Roslyn.Utilities.ObjectReader): VariableDeclarationSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var variables = <CSharpSyntaxNode>reader.ReadValue();
            if (variables != null) {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.type);
            writer.WriteValue(this.variables);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new VariableDeclarationSyntax().ctor_1709(r);
        }
    }

    export class VariableDeclaratorSyntax extends CSharpSyntaxNode {
        identifier: SyntaxToken;
        argumentList: BracketedArgumentListSyntax;
        initializer: EqualsValueClauseSyntax;

        constructor() { super(); }
        ctor_1671(kind: SyntaxKind, identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): VariableDeclaratorSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            return this;
        }


        ctor_3449(kind: SyntaxKind, identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax, context: SyntaxFactoryContext): VariableDeclaratorSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            return this;
        }


        ctor_4771(kind: SyntaxKind, identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax): VariableDeclaratorSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            return this;
        }

        public get Identifier(): SyntaxToken { return this.identifier; }
        public get ArgumentList(): BracketedArgumentListSyntax { return this.argumentList; }
        public get Initializer(): EqualsValueClauseSyntax { return this.initializer; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.identifier;
                case 1: return this.argumentList;
                case 2: return this.initializer;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.VariableDeclaratorSyntax().ctor_1406(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitVariableDeclarator(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitVariableDeclarator(this);
        }

        public Update(identifier: SyntaxToken, argumentList: BracketedArgumentListSyntax, initializer: EqualsValueClauseSyntax): VariableDeclaratorSyntax {
            if (identifier != this.Identifier || argumentList != this.ArgumentList || initializer != this.Initializer) {
                var newNode = SyntaxFactory.VariableDeclarator(identifier, argumentList, initializer);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new VariableDeclaratorSyntax().ctor_1671(this.Kind, this.identifier, this.argumentList, this.initializer, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new VariableDeclaratorSyntax().ctor_1671(this.Kind, this.identifier, this.argumentList, this.initializer, this.GetDiagnostics(), annotations);
        }

        public ctor_2045(reader: Roslyn.Utilities.ObjectReader): VariableDeclaratorSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var argumentList = <BracketedArgumentListSyntax>reader.ReadValue();
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
                return this;
            }
            var initializer = <EqualsValueClauseSyntax>reader.ReadValue();
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.argumentList);
            writer.WriteValue(this.initializer);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new VariableDeclaratorSyntax().ctor_2045(r);
        }
    }

    export class EqualsValueClauseSyntax extends CSharpSyntaxNode {
        equalsToken: SyntaxToken;
        value: ExpressionSyntax;

        constructor() { super(); }
        ctor_1858(kind: SyntaxKind, equalsToken: SyntaxToken, value: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EqualsValueClauseSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
            return this;
        }


        ctor_1366(kind: SyntaxKind, equalsToken: SyntaxToken, value: ExpressionSyntax, context: SyntaxFactoryContext): EqualsValueClauseSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
            return this;
        }


        ctor_3240(kind: SyntaxKind, equalsToken: SyntaxToken, value: ExpressionSyntax): EqualsValueClauseSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
            return this;
        }

        public get EqualsToken(): SyntaxToken { return this.equalsToken; }
        public get Value(): ExpressionSyntax { return this.value; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.equalsToken;
                case 1: return this.value;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.EqualsValueClauseSyntax().ctor_9464(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitEqualsValueClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitEqualsValueClause(this);
        }

        public Update(equalsToken: SyntaxToken, value: ExpressionSyntax): EqualsValueClauseSyntax {
            if (equalsToken != this.EqualsToken || value != this.Value) {
                var newNode = SyntaxFactory.EqualsValueClause(equalsToken, value);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new EqualsValueClauseSyntax().ctor_1858(this.Kind, this.equalsToken, this.value, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new EqualsValueClauseSyntax().ctor_1858(this.Kind, this.equalsToken, this.value, this.GetDiagnostics(), annotations);
        }

        public ctor_7287(reader: Roslyn.Utilities.ObjectReader): EqualsValueClauseSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var equalsToken = <SyntaxToken>reader.ReadValue();
            if (equalsToken != null) {
                this.AdjustFlagsAndWidth(equalsToken);
                this.equalsToken = equalsToken;
                return this;
            }
            var value = <ExpressionSyntax>reader.ReadValue();
            if (value != null) {
                this.AdjustFlagsAndWidth(value);
                this.value = value;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.value);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new EqualsValueClauseSyntax().ctor_7287(r);
        }
    }

    export class ExpressionStatementSyntax extends StatementSyntax {
        expression: ExpressionSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1452(kind: SyntaxKind, expression: ExpressionSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ExpressionStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_5488(kind: SyntaxKind, expression: ExpressionSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ExpressionStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_9739(kind: SyntaxKind, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ExpressionStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get Expression(): ExpressionSyntax { return this.expression; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.expression;
                case 1: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ExpressionStatementSyntax().ctor_1290(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitExpressionStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitExpressionStatement(this);
        }

        public Update(expression: ExpressionSyntax, semicolonToken: SyntaxToken): ExpressionStatementSyntax {
            if (expression != this.Expression || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.ExpressionStatement(expression, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ExpressionStatementSyntax().ctor_1452(this.Kind, this.expression, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ExpressionStatementSyntax().ctor_1452(this.Kind, this.expression, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1639(reader: Roslyn.Utilities.ObjectReader): ExpressionStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 2;
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ExpressionStatementSyntax().ctor_1639(r);
        }
    }

    export class EmptyStatementSyntax extends StatementSyntax {
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1946(kind: SyntaxKind, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EmptyStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1710(kind: SyntaxKind, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): EmptyStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_7923(kind: SyntaxKind, semicolonToken: SyntaxToken): EmptyStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.EmptyStatementSyntax().ctor_1090(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitEmptyStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitEmptyStatement(this);
        }

        public Update(semicolonToken: SyntaxToken): EmptyStatementSyntax {
            if (semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.EmptyStatement(semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new EmptyStatementSyntax().ctor_1946(this.Kind, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new EmptyStatementSyntax().ctor_1946(this.Kind, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_5031(reader: Roslyn.Utilities.ObjectReader): EmptyStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 1;
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new EmptyStatementSyntax().ctor_5031(r);
        }
    }

    export class LabeledStatementSyntax extends StatementSyntax {
        identifier: SyntaxToken;
        colonToken: SyntaxToken;
        statement: StatementSyntax;

        constructor() { super(); }
        ctor_6047(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LabeledStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_1249(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): LabeledStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_7158(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax): LabeledStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }

        public get Identifier(): SyntaxToken { return this.identifier; }
        public get ColonToken(): SyntaxToken { return this.colonToken; }
        public get Statement(): StatementSyntax { return this.statement; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.identifier;
                case 1: return this.colonToken;
                case 2: return this.statement;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.LabeledStatementSyntax().ctor_2895(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitLabeledStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitLabeledStatement(this);
        }

        public Update(identifier: SyntaxToken, colonToken: SyntaxToken, statement: StatementSyntax): LabeledStatementSyntax {
            if (identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement) {
                var newNode = SyntaxFactory.LabeledStatement(identifier, colonToken, statement);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new LabeledStatementSyntax().ctor_6047(this.Kind, this.identifier, this.colonToken, this.statement, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new LabeledStatementSyntax().ctor_6047(this.Kind, this.identifier, this.colonToken, this.statement, this.GetDiagnostics(), annotations);
        }

        public ctor_1985(reader: Roslyn.Utilities.ObjectReader): LabeledStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 3;
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var colonToken = <SyntaxToken>reader.ReadValue();
            if (colonToken != null) {
                this.AdjustFlagsAndWidth(colonToken);
                this.colonToken = colonToken;
                return this;
            }
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.statement);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new LabeledStatementSyntax().ctor_1985(r);
        }
    }

    export class GotoStatementSyntax extends StatementSyntax {
        gotoKeyword: SyntaxToken;
        caseOrDefaultKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1242(kind: SyntaxKind, gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): GotoStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            if (caseOrDefaultKeyword != null) {
                this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1495(kind: SyntaxKind, gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): GotoStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            if (caseOrDefaultKeyword != null) {
                this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1284(kind: SyntaxKind, gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): GotoStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            if (caseOrDefaultKeyword != null) {
                this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get GotoKeyword(): SyntaxToken { return this.gotoKeyword; }
        public get CaseOrDefaultKeyword(): SyntaxToken { return this.caseOrDefaultKeyword; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.gotoKeyword;
                case 1: return this.caseOrDefaultKeyword;
                case 2: return this.expression;
                case 3: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.GotoStatementSyntax().ctor_1317(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitGotoStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitGotoStatement(this);
        }

        public Update(gotoKeyword: SyntaxToken, caseOrDefaultKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): GotoStatementSyntax {
            if (gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.GotoStatement(this.Kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new GotoStatementSyntax().ctor_1242(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new GotoStatementSyntax().ctor_1242(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2036(reader: Roslyn.Utilities.ObjectReader): GotoStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 4;
            var gotoKeyword = <SyntaxToken>reader.ReadValue();
            if (gotoKeyword != null) {
                this.AdjustFlagsAndWidth(gotoKeyword);
                this.gotoKeyword = gotoKeyword;
                return this;
            }
            var caseOrDefaultKeyword = <SyntaxToken>reader.ReadValue();
            if (caseOrDefaultKeyword != null) {
                this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.gotoKeyword);
            writer.WriteValue(this.caseOrDefaultKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new GotoStatementSyntax().ctor_2036(r);
        }
    }

    export class BreakStatementSyntax extends StatementSyntax {
        breakKeyword: SyntaxToken;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_4806(kind: SyntaxKind, breakKeyword: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BreakStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_2038(kind: SyntaxKind, breakKeyword: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): BreakStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1032(kind: SyntaxKind, breakKeyword: SyntaxToken, semicolonToken: SyntaxToken): BreakStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get BreakKeyword(): SyntaxToken { return this.breakKeyword; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.breakKeyword;
                case 1: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.BreakStatementSyntax().ctor_1552(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitBreakStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitBreakStatement(this);
        }

        public Update(breakKeyword: SyntaxToken, semicolonToken: SyntaxToken): BreakStatementSyntax {
            if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.BreakStatement(breakKeyword, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new BreakStatementSyntax().ctor_4806(this.Kind, this.breakKeyword, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new BreakStatementSyntax().ctor_4806(this.Kind, this.breakKeyword, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1195(reader: Roslyn.Utilities.ObjectReader): BreakStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 2;
            var breakKeyword = <SyntaxToken>reader.ReadValue();
            if (breakKeyword != null) {
                this.AdjustFlagsAndWidth(breakKeyword);
                this.breakKeyword = breakKeyword;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.breakKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new BreakStatementSyntax().ctor_1195(r);
        }
    }

    export class ContinueStatementSyntax extends StatementSyntax {
        continueKeyword: SyntaxToken;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1786(kind: SyntaxKind, continueKeyword: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ContinueStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1201(kind: SyntaxKind, continueKeyword: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ContinueStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1547(kind: SyntaxKind, continueKeyword: SyntaxToken, semicolonToken: SyntaxToken): ContinueStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get ContinueKeyword(): SyntaxToken { return this.continueKeyword; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.continueKeyword;
                case 1: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ContinueStatementSyntax().ctor_1832(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitContinueStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitContinueStatement(this);
        }

        public Update(continueKeyword: SyntaxToken, semicolonToken: SyntaxToken): ContinueStatementSyntax {
            if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.ContinueStatement(continueKeyword, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ContinueStatementSyntax().ctor_1786(this.Kind, this.continueKeyword, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ContinueStatementSyntax().ctor_1786(this.Kind, this.continueKeyword, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2051(reader: Roslyn.Utilities.ObjectReader): ContinueStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 2;
            var continueKeyword = <SyntaxToken>reader.ReadValue();
            if (continueKeyword != null) {
                this.AdjustFlagsAndWidth(continueKeyword);
                this.continueKeyword = continueKeyword;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.continueKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ContinueStatementSyntax().ctor_2051(r);
        }
    }

    export class ReturnStatementSyntax extends StatementSyntax {
        returnKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_4085(kind: SyntaxKind, returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ReturnStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1404(kind: SyntaxKind, returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ReturnStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1068(kind: SyntaxKind, returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ReturnStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get ReturnKeyword(): SyntaxToken { return this.returnKeyword; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.returnKeyword;
                case 1: return this.expression;
                case 2: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ReturnStatementSyntax().ctor_7247(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitReturnStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitReturnStatement(this);
        }

        public Update(returnKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ReturnStatementSyntax {
            if (returnKeyword != this.ReturnKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.ReturnStatement(returnKeyword, expression, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ReturnStatementSyntax().ctor_4085(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ReturnStatementSyntax().ctor_4085(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1602(reader: Roslyn.Utilities.ObjectReader): ReturnStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 3;
            var returnKeyword = <SyntaxToken>reader.ReadValue();
            if (returnKeyword != null) {
                this.AdjustFlagsAndWidth(returnKeyword);
                this.returnKeyword = returnKeyword;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.returnKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ReturnStatementSyntax().ctor_1602(r);
        }
    }

    export class ThrowStatementSyntax extends StatementSyntax {
        throwKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1664(kind: SyntaxKind, throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ThrowStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1183(kind: SyntaxKind, throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ThrowStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_5581(kind: SyntaxKind, throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ThrowStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get ThrowKeyword(): SyntaxToken { return this.throwKeyword; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.throwKeyword;
                case 1: return this.expression;
                case 2: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ThrowStatementSyntax().ctor_6630(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitThrowStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitThrowStatement(this);
        }

        public Update(throwKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): ThrowStatementSyntax {
            if (throwKeyword != this.ThrowKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.ThrowStatement(throwKeyword, expression, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ThrowStatementSyntax().ctor_1664(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ThrowStatementSyntax().ctor_1664(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_9419(reader: Roslyn.Utilities.ObjectReader): ThrowStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 3;
            var throwKeyword = <SyntaxToken>reader.ReadValue();
            if (throwKeyword != null) {
                this.AdjustFlagsAndWidth(throwKeyword);
                this.throwKeyword = throwKeyword;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.throwKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ThrowStatementSyntax().ctor_9419(r);
        }
    }

    export class YieldStatementSyntax extends StatementSyntax {
        yieldKeyword: SyntaxToken;
        returnOrBreakKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1739(kind: SyntaxKind, yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): YieldStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            this.AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1922(kind: SyntaxKind, yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): YieldStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            this.AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1318(kind: SyntaxKind, yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): YieldStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            this.AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get YieldKeyword(): SyntaxToken { return this.yieldKeyword; }
        public get ReturnOrBreakKeyword(): SyntaxToken { return this.returnOrBreakKeyword; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.yieldKeyword;
                case 1: return this.returnOrBreakKeyword;
                case 2: return this.expression;
                case 3: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.YieldStatementSyntax().ctor_1958(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitYieldStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitYieldStatement(this);
        }

        public Update(yieldKeyword: SyntaxToken, returnOrBreakKeyword: SyntaxToken, expression: ExpressionSyntax, semicolonToken: SyntaxToken): YieldStatementSyntax {
            if (yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.YieldStatement(this.Kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new YieldStatementSyntax().ctor_1739(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new YieldStatementSyntax().ctor_1739(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1256(reader: Roslyn.Utilities.ObjectReader): YieldStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 4;
            var yieldKeyword = <SyntaxToken>reader.ReadValue();
            if (yieldKeyword != null) {
                this.AdjustFlagsAndWidth(yieldKeyword);
                this.yieldKeyword = yieldKeyword;
                return this;
            }
            var returnOrBreakKeyword = <SyntaxToken>reader.ReadValue();
            if (returnOrBreakKeyword != null) {
                this.AdjustFlagsAndWidth(returnOrBreakKeyword);
                this.returnOrBreakKeyword = returnOrBreakKeyword;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.yieldKeyword);
            writer.WriteValue(this.returnOrBreakKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new YieldStatementSyntax().ctor_1256(r);
        }
    }

    export class WhileStatementSyntax extends StatementSyntax {
        whileKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        condition: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;

        constructor() { super(); }
        ctor_3033(kind: SyntaxKind, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): WhileStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_1212(kind: SyntaxKind, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): WhileStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_1272(kind: SyntaxKind, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): WhileStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }

        public get WhileKeyword(): SyntaxToken { return this.whileKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Condition(): ExpressionSyntax { return this.condition; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }
        public get Statement(): StatementSyntax { return this.statement; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.whileKeyword;
                case 1: return this.openParenToken;
                case 2: return this.condition;
                case 3: return this.closeParenToken;
                case 4: return this.statement;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.WhileStatementSyntax().ctor_1352(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitWhileStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitWhileStatement(this);
        }

        public Update(whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): WhileStatementSyntax {
            if (whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement) {
                var newNode = SyntaxFactory.WhileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new WhileStatementSyntax().ctor_3033(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new WhileStatementSyntax().ctor_3033(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.GetDiagnostics(), annotations);
        }

        public ctor_1465(reader: Roslyn.Utilities.ObjectReader): WhileStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 5;
            var whileKeyword = <SyntaxToken>reader.ReadValue();
            if (whileKeyword != null) {
                this.AdjustFlagsAndWidth(whileKeyword);
                this.whileKeyword = whileKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var condition = <ExpressionSyntax>reader.ReadValue();
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.whileKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new WhileStatementSyntax().ctor_1465(r);
        }
    }

    export class DoStatementSyntax extends StatementSyntax {
        doKeyword: SyntaxToken;
        statement: StatementSyntax;
        whileKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        condition: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1104(kind: SyntaxKind, doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DoStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1155(kind: SyntaxKind, doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): DoStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_2075(kind: SyntaxKind, doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken): DoStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get DoKeyword(): SyntaxToken { return this.doKeyword; }
        public get Statement(): StatementSyntax { return this.statement; }
        public get WhileKeyword(): SyntaxToken { return this.whileKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Condition(): ExpressionSyntax { return this.condition; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.doKeyword;
                case 1: return this.statement;
                case 2: return this.whileKeyword;
                case 3: return this.openParenToken;
                case 4: return this.condition;
                case 5: return this.closeParenToken;
                case 6: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.DoStatementSyntax().ctor_6607(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitDoStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitDoStatement(this);
        }

        public Update(doKeyword: SyntaxToken, statement: StatementSyntax, whileKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, semicolonToken: SyntaxToken): DoStatementSyntax {
            if (doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.DoStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new DoStatementSyntax().ctor_1104(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new DoStatementSyntax().ctor_1104(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1737(reader: Roslyn.Utilities.ObjectReader): DoStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 7;
            var doKeyword = <SyntaxToken>reader.ReadValue();
            if (doKeyword != null) {
                this.AdjustFlagsAndWidth(doKeyword);
                this.doKeyword = doKeyword;
                return this;
            }
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
            var whileKeyword = <SyntaxToken>reader.ReadValue();
            if (whileKeyword != null) {
                this.AdjustFlagsAndWidth(whileKeyword);
                this.whileKeyword = whileKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var condition = <ExpressionSyntax>reader.ReadValue();
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.statement);
            writer.WriteValue(this.whileKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new DoStatementSyntax().ctor_1737(r);
        }
    }

    export class ForStatementSyntax extends StatementSyntax {
        forKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        declaration: VariableDeclarationSyntax;
        initializers: CSharpSyntaxNode;
        firstSemicolonToken: SyntaxToken;
        condition: ExpressionSyntax;
        secondSemicolonToken: SyntaxToken;
        incrementors: CSharpSyntaxNode;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;

        constructor() { super(); }
        ctor_1010(kind: SyntaxKind, forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: CSharpSyntaxNode, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: CSharpSyntaxNode, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ForStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (initializers != null) {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            this.AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            if (incrementors != null) {
                this.AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_2928(kind: SyntaxKind, forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: CSharpSyntaxNode, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: CSharpSyntaxNode, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): ForStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (initializers != null) {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            this.AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            if (incrementors != null) {
                this.AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_2049(kind: SyntaxKind, forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: CSharpSyntaxNode, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: CSharpSyntaxNode, closeParenToken: SyntaxToken, statement: StatementSyntax): ForStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (initializers != null) {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            this.AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            if (incrementors != null) {
                this.AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }

        public get ForKeyword(): SyntaxToken { return this.forKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Declaration(): VariableDeclarationSyntax { return this.declaration; }
        public get Initializers(): SeparatedSyntaxList<ExpressionSyntax> { return new SeparatedSyntaxList<ExpressionSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.initializers)); }
        public get FirstSemicolonToken(): SyntaxToken { return this.firstSemicolonToken; }
        public get Condition(): ExpressionSyntax { return this.condition; }
        public get SecondSemicolonToken(): SyntaxToken { return this.secondSemicolonToken; }
        public get Incrementors(): SeparatedSyntaxList<ExpressionSyntax> { return new SeparatedSyntaxList<ExpressionSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.incrementors)); }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }
        public get Statement(): StatementSyntax { return this.statement; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.forKeyword;
                case 1: return this.openParenToken;
                case 2: return this.declaration;
                case 3: return this.initializers;
                case 4: return this.firstSemicolonToken;
                case 5: return this.condition;
                case 6: return this.secondSemicolonToken;
                case 7: return this.incrementors;
                case 8: return this.closeParenToken;
                case 9: return this.statement;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ForStatementSyntax().ctor_5717(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitForStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitForStatement(this);
        }

        public Update(forKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, initializers: SeparatedSyntaxList<ExpressionSyntax>, firstSemicolonToken: SyntaxToken, condition: ExpressionSyntax, secondSemicolonToken: SyntaxToken, incrementors: SeparatedSyntaxList<ExpressionSyntax>, closeParenToken: SyntaxToken, statement: StatementSyntax): ForStatementSyntax {
            if (forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || initializers != this.Initializers || firstSemicolonToken != this.FirstSemicolonToken || condition != this.Condition || secondSemicolonToken != this.SecondSemicolonToken || incrementors != this.Incrementors || closeParenToken != this.CloseParenToken || statement != this.Statement) {
                var newNode = SyntaxFactory.ForStatement(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ForStatementSyntax().ctor_1010(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ForStatementSyntax().ctor_1010(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, this.GetDiagnostics(), annotations);
        }

        public ctor_9007(reader: Roslyn.Utilities.ObjectReader): ForStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 10;
            var forKeyword = <SyntaxToken>reader.ReadValue();
            if (forKeyword != null) {
                this.AdjustFlagsAndWidth(forKeyword);
                this.forKeyword = forKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var declaration = <VariableDeclarationSyntax>reader.ReadValue();
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
                return this;
            }
            var initializers = <CSharpSyntaxNode>reader.ReadValue();
            if (initializers != null) {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
                return this;
            }
            var firstSemicolonToken = <SyntaxToken>reader.ReadValue();
            if (firstSemicolonToken != null) {
                this.AdjustFlagsAndWidth(firstSemicolonToken);
                this.firstSemicolonToken = firstSemicolonToken;
                return this;
            }
            var condition = <ExpressionSyntax>reader.ReadValue();
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
                return this;
            }
            var secondSemicolonToken = <SyntaxToken>reader.ReadValue();
            if (secondSemicolonToken != null) {
                this.AdjustFlagsAndWidth(secondSemicolonToken);
                this.secondSemicolonToken = secondSemicolonToken;
                return this;
            }
            var incrementors = <CSharpSyntaxNode>reader.ReadValue();
            if (incrementors != null) {
                this.AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.initializers);
            writer.WriteValue(this.firstSemicolonToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.secondSemicolonToken);
            writer.WriteValue(this.incrementors);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ForStatementSyntax().ctor_9007(r);
        }
    }

    export class ForEachStatementSyntax extends StatementSyntax {
        forEachKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        identifier: SyntaxToken;
        inKeyword: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;

        constructor() { super(); }
        ctor_3546(kind: SyntaxKind, forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ForEachStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_2084(kind: SyntaxKind, forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): ForEachStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_1622(kind: SyntaxKind, forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): ForEachStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }

        public get ForEachKeyword(): SyntaxToken { return this.forEachKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Type(): TypeSyntax { return this.type; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get InKeyword(): SyntaxToken { return this.inKeyword; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }
        public get Statement(): StatementSyntax { return this.statement; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.forEachKeyword;
                case 1: return this.openParenToken;
                case 2: return this.type;
                case 3: return this.identifier;
                case 4: return this.inKeyword;
                case 5: return this.expression;
                case 6: return this.closeParenToken;
                case 7: return this.statement;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ForEachStatementSyntax().ctor_5886(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitForEachStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitForEachStatement(this);
        }

        public Update(forEachKeyword: SyntaxToken, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, inKeyword: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): ForEachStatementSyntax {
            if (forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement) {
                var newNode = SyntaxFactory.ForEachStatement(forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ForEachStatementSyntax().ctor_3546(this.Kind, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ForEachStatementSyntax().ctor_3546(this.Kind, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, this.GetDiagnostics(), annotations);
        }

        public ctor_1857(reader: Roslyn.Utilities.ObjectReader): ForEachStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 8;
            var forEachKeyword = <SyntaxToken>reader.ReadValue();
            if (forEachKeyword != null) {
                this.AdjustFlagsAndWidth(forEachKeyword);
                this.forEachKeyword = forEachKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var inKeyword = <SyntaxToken>reader.ReadValue();
            if (inKeyword != null) {
                this.AdjustFlagsAndWidth(inKeyword);
                this.inKeyword = inKeyword;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.forEachKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ForEachStatementSyntax().ctor_1857(r);
        }
    }

    export class UsingStatementSyntax extends StatementSyntax {
        usingKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        declaration: VariableDeclarationSyntax;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;

        constructor() { super(); }
        ctor_6137(kind: SyntaxKind, usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): UsingStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_1513(kind: SyntaxKind, usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): UsingStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_1678(kind: SyntaxKind, usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): UsingStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }

        public get UsingKeyword(): SyntaxToken { return this.usingKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Declaration(): VariableDeclarationSyntax { return this.declaration; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }
        public get Statement(): StatementSyntax { return this.statement; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.usingKeyword;
                case 1: return this.openParenToken;
                case 2: return this.declaration;
                case 3: return this.expression;
                case 4: return this.closeParenToken;
                case 5: return this.statement;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.UsingStatementSyntax().ctor_2075(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitUsingStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitUsingStatement(this);
        }

        public Update(usingKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): UsingStatementSyntax {
            if (usingKeyword != this.UsingKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement) {
                var newNode = SyntaxFactory.UsingStatement(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new UsingStatementSyntax().ctor_6137(this.Kind, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new UsingStatementSyntax().ctor_6137(this.Kind, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, this.GetDiagnostics(), annotations);
        }

        public ctor_1016(reader: Roslyn.Utilities.ObjectReader): UsingStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 6;
            var usingKeyword = <SyntaxToken>reader.ReadValue();
            if (usingKeyword != null) {
                this.AdjustFlagsAndWidth(usingKeyword);
                this.usingKeyword = usingKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var declaration = <VariableDeclarationSyntax>reader.ReadValue();
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.usingKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new UsingStatementSyntax().ctor_1016(r);
        }
    }

    export class FixedStatementSyntax extends StatementSyntax {
        fixedKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        declaration: VariableDeclarationSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;

        constructor() { super(); }
        ctor_1013(kind: SyntaxKind, fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): FixedStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(fixedKeyword);
            this.fixedKeyword = fixedKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_7903(kind: SyntaxKind, fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): FixedStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(fixedKeyword);
            this.fixedKeyword = fixedKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_5060(kind: SyntaxKind, fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): FixedStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(fixedKeyword);
            this.fixedKeyword = fixedKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }

        public get FixedKeyword(): SyntaxToken { return this.fixedKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Declaration(): VariableDeclarationSyntax { return this.declaration; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }
        public get Statement(): StatementSyntax { return this.statement; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.fixedKeyword;
                case 1: return this.openParenToken;
                case 2: return this.declaration;
                case 3: return this.closeParenToken;
                case 4: return this.statement;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.FixedStatementSyntax().ctor_8045(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitFixedStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitFixedStatement(this);
        }

        public Update(fixedKeyword: SyntaxToken, openParenToken: SyntaxToken, declaration: VariableDeclarationSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): FixedStatementSyntax {
            if (fixedKeyword != this.FixedKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || closeParenToken != this.CloseParenToken || statement != this.Statement) {
                var newNode = SyntaxFactory.FixedStatement(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new FixedStatementSyntax().ctor_1013(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new FixedStatementSyntax().ctor_1013(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, this.GetDiagnostics(), annotations);
        }

        public ctor_1457(reader: Roslyn.Utilities.ObjectReader): FixedStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 5;
            var fixedKeyword = <SyntaxToken>reader.ReadValue();
            if (fixedKeyword != null) {
                this.AdjustFlagsAndWidth(fixedKeyword);
                this.fixedKeyword = fixedKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var declaration = <VariableDeclarationSyntax>reader.ReadValue();
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.fixedKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new FixedStatementSyntax().ctor_1457(r);
        }
    }

    export class CheckedStatementSyntax extends StatementSyntax {
        keyword: SyntaxToken;
        block: BlockSyntax;

        constructor() { super(); }
        ctor_9794(kind: SyntaxKind, keyword: SyntaxToken, block: BlockSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CheckedStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }


        ctor_9134(kind: SyntaxKind, keyword: SyntaxToken, block: BlockSyntax, context: SyntaxFactoryContext): CheckedStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }


        ctor_4162(kind: SyntaxKind, keyword: SyntaxToken, block: BlockSyntax): CheckedStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }
        public get Block(): BlockSyntax { return this.block; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                case 1: return this.block;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CheckedStatementSyntax().ctor_5206(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCheckedStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCheckedStatement(this);
        }

        public Update(keyword: SyntaxToken, block: BlockSyntax): CheckedStatementSyntax {
            if (keyword != this.Keyword || block != this.Block) {
                var newNode = SyntaxFactory.CheckedStatement(this.Kind, keyword, block);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CheckedStatementSyntax().ctor_9794(this.Kind, this.keyword, this.block, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CheckedStatementSyntax().ctor_9794(this.Kind, this.keyword, this.block, this.GetDiagnostics(), annotations);
        }

        public ctor_1120(reader: Roslyn.Utilities.ObjectReader): CheckedStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 2;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var block = <BlockSyntax>reader.ReadValue();
            if (block != null) {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.block);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CheckedStatementSyntax().ctor_1120(r);
        }
    }

    export class UnsafeStatementSyntax extends StatementSyntax {
        unsafeKeyword: SyntaxToken;
        block: BlockSyntax;

        constructor() { super(); }
        ctor_1702(kind: SyntaxKind, unsafeKeyword: SyntaxToken, block: BlockSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): UnsafeStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(unsafeKeyword);
            this.unsafeKeyword = unsafeKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }


        ctor_1796(kind: SyntaxKind, unsafeKeyword: SyntaxToken, block: BlockSyntax, context: SyntaxFactoryContext): UnsafeStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(unsafeKeyword);
            this.unsafeKeyword = unsafeKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }


        ctor_9552(kind: SyntaxKind, unsafeKeyword: SyntaxToken, block: BlockSyntax): UnsafeStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(unsafeKeyword);
            this.unsafeKeyword = unsafeKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }

        public get UnsafeKeyword(): SyntaxToken { return this.unsafeKeyword; }
        public get Block(): BlockSyntax { return this.block; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.unsafeKeyword;
                case 1: return this.block;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.UnsafeStatementSyntax().ctor_5623(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitUnsafeStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitUnsafeStatement(this);
        }

        public Update(unsafeKeyword: SyntaxToken, block: BlockSyntax): UnsafeStatementSyntax {
            if (unsafeKeyword != this.UnsafeKeyword || block != this.Block) {
                var newNode = SyntaxFactory.UnsafeStatement(unsafeKeyword, block);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new UnsafeStatementSyntax().ctor_1702(this.Kind, this.unsafeKeyword, this.block, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new UnsafeStatementSyntax().ctor_1702(this.Kind, this.unsafeKeyword, this.block, this.GetDiagnostics(), annotations);
        }

        public ctor_1280(reader: Roslyn.Utilities.ObjectReader): UnsafeStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 2;
            var unsafeKeyword = <SyntaxToken>reader.ReadValue();
            if (unsafeKeyword != null) {
                this.AdjustFlagsAndWidth(unsafeKeyword);
                this.unsafeKeyword = unsafeKeyword;
                return this;
            }
            var block = <BlockSyntax>reader.ReadValue();
            if (block != null) {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.unsafeKeyword);
            writer.WriteValue(this.block);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new UnsafeStatementSyntax().ctor_1280(r);
        }
    }

    export class LockStatementSyntax extends StatementSyntax {
        lockKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;

        constructor() { super(); }
        ctor_2094(kind: SyntaxKind, lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LockStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(lockKeyword);
            this.lockKeyword = lockKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_2931(kind: SyntaxKind, lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): LockStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(lockKeyword);
            this.lockKeyword = lockKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_1320(kind: SyntaxKind, lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): LockStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(lockKeyword);
            this.lockKeyword = lockKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }

        public get LockKeyword(): SyntaxToken { return this.lockKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }
        public get Statement(): StatementSyntax { return this.statement; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.lockKeyword;
                case 1: return this.openParenToken;
                case 2: return this.expression;
                case 3: return this.closeParenToken;
                case 4: return this.statement;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.LockStatementSyntax().ctor_4559(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitLockStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitLockStatement(this);
        }

        public Update(lockKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax): LockStatementSyntax {
            if (lockKeyword != this.LockKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement) {
                var newNode = SyntaxFactory.LockStatement(lockKeyword, openParenToken, expression, closeParenToken, statement);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new LockStatementSyntax().ctor_2094(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new LockStatementSyntax().ctor_2094(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, this.GetDiagnostics(), annotations);
        }

        public ctor_1170(reader: Roslyn.Utilities.ObjectReader): LockStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 5;
            var lockKeyword = <SyntaxToken>reader.ReadValue();
            if (lockKeyword != null) {
                this.AdjustFlagsAndWidth(lockKeyword);
                this.lockKeyword = lockKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.lockKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new LockStatementSyntax().ctor_1170(r);
        }
    }

    export class IfStatementSyntax extends StatementSyntax {
        ifKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        condition: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        statement: StatementSyntax;
        $else: ElseClauseSyntax;

        constructor() { super(); }
        ctor_1524(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IfStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            if ($else != null) {
                this.AdjustFlagsAndWidth($else);
                this.$else = $else;
            }
            return this;
        }


        ctor_2092(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax, context: SyntaxFactoryContext): IfStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            if ($else != null) {
                this.AdjustFlagsAndWidth($else);
                this.$else = $else;
            }
            return this;
        }


        ctor_7562(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax): IfStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            if ($else != null) {
                this.AdjustFlagsAndWidth($else);
                this.$else = $else;
            }
            return this;
        }

        public get IfKeyword(): SyntaxToken { return this.ifKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Condition(): ExpressionSyntax { return this.condition; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }
        public get Statement(): StatementSyntax { return this.statement; }
        public get Else(): ElseClauseSyntax { return this.$else; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.ifKeyword;
                case 1: return this.openParenToken;
                case 2: return this.condition;
                case 3: return this.closeParenToken;
                case 4: return this.statement;
                case 5: return this.$else;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.IfStatementSyntax().ctor_7214(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitIfStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitIfStatement(this);
        }

        public Update(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, condition: ExpressionSyntax, closeParenToken: SyntaxToken, statement: StatementSyntax, $else: ElseClauseSyntax): IfStatementSyntax {
            if (ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement || $else != this.Else) {
                var newNode = SyntaxFactory.IfStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, $else);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new IfStatementSyntax().ctor_1524(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.$else, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new IfStatementSyntax().ctor_1524(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.$else, this.GetDiagnostics(), annotations);
        }

        public ctor_1472(reader: Roslyn.Utilities.ObjectReader): IfStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 6;
            var ifKeyword = <SyntaxToken>reader.ReadValue();
            if (ifKeyword != null) {
                this.AdjustFlagsAndWidth(ifKeyword);
                this.ifKeyword = ifKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var condition = <ExpressionSyntax>reader.ReadValue();
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
            var $else = <ElseClauseSyntax>reader.ReadValue();
            if ($else != null) {
                this.AdjustFlagsAndWidth($else);
                this.$else = $else;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.ifKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
            writer.WriteValue(this.$else);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new IfStatementSyntax().ctor_1472(r);
        }
    }

    export class ElseClauseSyntax extends CSharpSyntaxNode {
        elseKeyword: SyntaxToken;
        statement: StatementSyntax;

        constructor() { super(); }
        ctor_1047(kind: SyntaxKind, elseKeyword: SyntaxToken, statement: StatementSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ElseClauseSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_1278(kind: SyntaxKind, elseKeyword: SyntaxToken, statement: StatementSyntax, context: SyntaxFactoryContext): ElseClauseSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }


        ctor_4115(kind: SyntaxKind, elseKeyword: SyntaxToken, statement: StatementSyntax): ElseClauseSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            return this;
        }

        public get ElseKeyword(): SyntaxToken { return this.elseKeyword; }
        public get Statement(): StatementSyntax { return this.statement; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.elseKeyword;
                case 1: return this.statement;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ElseClauseSyntax().ctor_6425(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitElseClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitElseClause(this);
        }

        public Update(elseKeyword: SyntaxToken, statement: StatementSyntax): ElseClauseSyntax {
            if (elseKeyword != this.ElseKeyword || statement != this.Statement) {
                var newNode = SyntaxFactory.ElseClause(elseKeyword, statement);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ElseClauseSyntax().ctor_1047(this.Kind, this.elseKeyword, this.statement, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ElseClauseSyntax().ctor_1047(this.Kind, this.elseKeyword, this.statement, this.GetDiagnostics(), annotations);
        }

        public ctor_9306(reader: Roslyn.Utilities.ObjectReader): ElseClauseSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var elseKeyword = <SyntaxToken>reader.ReadValue();
            if (elseKeyword != null) {
                this.AdjustFlagsAndWidth(elseKeyword);
                this.elseKeyword = elseKeyword;
                return this;
            }
            var statement = <StatementSyntax>reader.ReadValue();
            if (statement != null) {
                this.AdjustFlagsAndWidth(statement);
                this.statement = statement;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.elseKeyword);
            writer.WriteValue(this.statement);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ElseClauseSyntax().ctor_9306(r);
        }
    }

    export class SwitchStatementSyntax extends StatementSyntax {
        switchKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        expression: ExpressionSyntax;
        closeParenToken: SyntaxToken;
        openBraceToken: SyntaxToken;
        sections: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;

        constructor() { super(); }
        ctor_4949(kind: SyntaxKind, switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: CSharpSyntaxNode, closeBraceToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SwitchStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (sections != null) {
                this.AdjustFlagsAndWidth(sections);
                this.sections = sections;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }


        ctor_1210(kind: SyntaxKind, switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: CSharpSyntaxNode, closeBraceToken: SyntaxToken, context: SyntaxFactoryContext): SwitchStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (sections != null) {
                this.AdjustFlagsAndWidth(sections);
                this.sections = sections;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }


        ctor_4816(kind: SyntaxKind, switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: CSharpSyntaxNode, closeBraceToken: SyntaxToken): SwitchStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (sections != null) {
                this.AdjustFlagsAndWidth(sections);
                this.sections = sections;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }

        public get SwitchKeyword(): SyntaxToken { return this.switchKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Expression(): ExpressionSyntax { return this.expression; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }
        public get OpenBraceToken(): SyntaxToken { return this.openBraceToken; }
        public get Sections(): SyntaxList<SwitchSectionSyntax> { return new SyntaxList<SwitchSectionSyntax>().ctor_1319(this.sections); }
        public get CloseBraceToken(): SyntaxToken { return this.closeBraceToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.switchKeyword;
                case 1: return this.openParenToken;
                case 2: return this.expression;
                case 3: return this.closeParenToken;
                case 4: return this.openBraceToken;
                case 5: return this.sections;
                case 6: return this.closeBraceToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.SwitchStatementSyntax().ctor_1833(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitSwitchStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitSwitchStatement(this);
        }

        public Update(switchKeyword: SyntaxToken, openParenToken: SyntaxToken, expression: ExpressionSyntax, closeParenToken: SyntaxToken, openBraceToken: SyntaxToken, sections: SyntaxList<SwitchSectionSyntax>, closeBraceToken: SyntaxToken): SwitchStatementSyntax {
            if (switchKeyword != this.SwitchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || sections != this.Sections || closeBraceToken != this.CloseBraceToken) {
                var newNode = SyntaxFactory.SwitchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new SwitchStatementSyntax().ctor_4949(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new SwitchStatementSyntax().ctor_4949(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2253(reader: Roslyn.Utilities.ObjectReader): SwitchStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 7;
            var switchKeyword = <SyntaxToken>reader.ReadValue();
            if (switchKeyword != null) {
                this.AdjustFlagsAndWidth(switchKeyword);
                this.switchKeyword = switchKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
            var openBraceToken = <SyntaxToken>reader.ReadValue();
            if (openBraceToken != null) {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
                return this;
            }
            var sections = <CSharpSyntaxNode>reader.ReadValue();
            if (sections != null) {
                this.AdjustFlagsAndWidth(sections);
                this.sections = sections;
                return this;
            }
            var closeBraceToken = <SyntaxToken>reader.ReadValue();
            if (closeBraceToken != null) {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.switchKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.sections);
            writer.WriteValue(this.closeBraceToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new SwitchStatementSyntax().ctor_2253(r);
        }
    }

    export class SwitchSectionSyntax extends CSharpSyntaxNode {
        labels: CSharpSyntaxNode;
        statements: CSharpSyntaxNode;

        constructor() { super(); }
        ctor_6862(kind: SyntaxKind, labels: CSharpSyntaxNode, statements: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SwitchSectionSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            if (labels != null) {
                this.AdjustFlagsAndWidth(labels);
                this.labels = labels;
            }
            if (statements != null) {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            return this;
        }


        ctor_5747(kind: SyntaxKind, labels: CSharpSyntaxNode, statements: CSharpSyntaxNode, context: SyntaxFactoryContext): SwitchSectionSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            if (labels != null) {
                this.AdjustFlagsAndWidth(labels);
                this.labels = labels;
            }
            if (statements != null) {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            return this;
        }


        ctor_8674(kind: SyntaxKind, labels: CSharpSyntaxNode, statements: CSharpSyntaxNode): SwitchSectionSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            if (labels != null) {
                this.AdjustFlagsAndWidth(labels);
                this.labels = labels;
            }
            if (statements != null) {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            return this;
        }

        public get Labels(): SyntaxList<SwitchLabelSyntax> { return new SyntaxList<SwitchLabelSyntax>().ctor_1319(this.labels); }
        public get Statements(): SyntaxList<StatementSyntax> { return new SyntaxList<StatementSyntax>().ctor_1319(this.statements); }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.labels;
                case 1: return this.statements;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.SwitchSectionSyntax().ctor_1124(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitSwitchSection(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitSwitchSection(this);
        }

        public Update(labels: SyntaxList<SwitchLabelSyntax>, statements: SyntaxList<StatementSyntax>): SwitchSectionSyntax {
            if (labels != this.Labels || statements != this.Statements) {
                var newNode = SyntaxFactory.SwitchSection(labels, statements);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new SwitchSectionSyntax().ctor_6862(this.Kind, this.labels, this.statements, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new SwitchSectionSyntax().ctor_6862(this.Kind, this.labels, this.statements, this.GetDiagnostics(), annotations);
        }

        public ctor_1828(reader: Roslyn.Utilities.ObjectReader): SwitchSectionSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var labels = <CSharpSyntaxNode>reader.ReadValue();
            if (labels != null) {
                this.AdjustFlagsAndWidth(labels);
                this.labels = labels;
                return this;
            }
            var statements = <CSharpSyntaxNode>reader.ReadValue();
            if (statements != null) {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.labels);
            writer.WriteValue(this.statements);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new SwitchSectionSyntax().ctor_1828(r);
        }
    }

    export class SwitchLabelSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_1375(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SwitchLabelSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_8342(kind: SyntaxKind): SwitchLabelSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_1946(reader: Roslyn.Utilities.ObjectReader): SwitchLabelSyntax {
            super.ctor_4942(reader);
            return this;
        }

        public Keyword: SyntaxToken;

        public ColonToken: SyntaxToken;
    }

    export class CaseSwitchLabelSyntax extends SwitchLabelSyntax {
        keyword: SyntaxToken;
        value: ExpressionSyntax;
        colonToken: SyntaxToken;

        constructor() { super(); }
        ctor_5679(kind: SyntaxKind, keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CaseSwitchLabelSyntax {
            super.ctor_1375(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }


        ctor_5189(kind: SyntaxKind, keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken, context: SyntaxFactoryContext): CaseSwitchLabelSyntax {
            super.ctor_8342(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }


        ctor_1897(kind: SyntaxKind, keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken): CaseSwitchLabelSyntax {
            super.ctor_8342(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }
        public get Value(): ExpressionSyntax { return this.value; }
        public get ColonToken(): SyntaxToken { return this.colonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                case 1: return this.value;
                case 2: return this.colonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CaseSwitchLabelSyntax().ctor_1688_C(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCaseSwitchLabel(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCaseSwitchLabel(this);
        }

        public Update(keyword: SyntaxToken, value: ExpressionSyntax, colonToken: SyntaxToken): CaseSwitchLabelSyntax {
            if (keyword != this.Keyword || value != this.Value || colonToken != this.ColonToken) {
                var newNode = SyntaxFactory.CaseSwitchLabel(keyword, value, colonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CaseSwitchLabelSyntax().ctor_5679(this.Kind, this.keyword, this.value, this.colonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CaseSwitchLabelSyntax().ctor_5679(this.Kind, this.keyword, this.value, this.colonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_3750(reader: Roslyn.Utilities.ObjectReader): CaseSwitchLabelSyntax {
            super.ctor_1946(reader);
            this.SlotCount = 3;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var value = <ExpressionSyntax>reader.ReadValue();
            if (value != null) {
                this.AdjustFlagsAndWidth(value);
                this.value = value;
                return this;
            }
            var colonToken = <SyntaxToken>reader.ReadValue();
            if (colonToken != null) {
                this.AdjustFlagsAndWidth(colonToken);
                this.colonToken = colonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.value);
            writer.WriteValue(this.colonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CaseSwitchLabelSyntax().ctor_3750(r);
        }
    }

    export class DefaultSwitchLabelSyntax extends SwitchLabelSyntax {
        keyword: SyntaxToken;
        colonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1921(kind: SyntaxKind, keyword: SyntaxToken, colonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DefaultSwitchLabelSyntax {
            super.ctor_1375(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }


        ctor_6195(kind: SyntaxKind, keyword: SyntaxToken, colonToken: SyntaxToken, context: SyntaxFactoryContext): DefaultSwitchLabelSyntax {
            super.ctor_8342(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }


        ctor_8179(kind: SyntaxKind, keyword: SyntaxToken, colonToken: SyntaxToken): DefaultSwitchLabelSyntax {
            super.ctor_8342(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }

        public get Keyword(): SyntaxToken { return this.keyword; }
        public get ColonToken(): SyntaxToken { return this.colonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.keyword;
                case 1: return this.colonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.DefaultSwitchLabelSyntax().ctor_1836(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitDefaultSwitchLabel(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitDefaultSwitchLabel(this);
        }

        public Update(keyword: SyntaxToken, colonToken: SyntaxToken): DefaultSwitchLabelSyntax {
            if (keyword != this.Keyword || colonToken != this.ColonToken) {
                var newNode = SyntaxFactory.DefaultSwitchLabel(keyword, colonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new DefaultSwitchLabelSyntax().ctor_1921(this.Kind, this.keyword, this.colonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new DefaultSwitchLabelSyntax().ctor_1921(this.Kind, this.keyword, this.colonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_8246(reader: Roslyn.Utilities.ObjectReader): DefaultSwitchLabelSyntax {
            super.ctor_1946(reader);
            this.SlotCount = 2;
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var colonToken = <SyntaxToken>reader.ReadValue();
            if (colonToken != null) {
                this.AdjustFlagsAndWidth(colonToken);
                this.colonToken = colonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.colonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new DefaultSwitchLabelSyntax().ctor_8246(r);
        }
    }

    export class TryStatementSyntax extends StatementSyntax {
        tryKeyword: SyntaxToken;
        block: BlockSyntax;
        catches: CSharpSyntaxNode;
        $finally: FinallyClauseSyntax;

        constructor() { super(); }
        ctor_5843(kind: SyntaxKind, tryKeyword: SyntaxToken, block: BlockSyntax, catches: CSharpSyntaxNode, $finally: FinallyClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TryStatementSyntax {
            super.ctor_1815(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (catches != null) {
                this.AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            if ($finally != null) {
                this.AdjustFlagsAndWidth($finally);
                this.$finally = $finally;
            }
            return this;
        }


        ctor_1281(kind: SyntaxKind, tryKeyword: SyntaxToken, block: BlockSyntax, catches: CSharpSyntaxNode, $finally: FinallyClauseSyntax, context: SyntaxFactoryContext): TryStatementSyntax {
            super.ctor_9228(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (catches != null) {
                this.AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            if ($finally != null) {
                this.AdjustFlagsAndWidth($finally);
                this.$finally = $finally;
            }
            return this;
        }


        ctor_1395(kind: SyntaxKind, tryKeyword: SyntaxToken, block: BlockSyntax, catches: CSharpSyntaxNode, $finally: FinallyClauseSyntax): TryStatementSyntax {
            super.ctor_9228(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (catches != null) {
                this.AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            if ($finally != null) {
                this.AdjustFlagsAndWidth($finally);
                this.$finally = $finally;
            }
            return this;
        }

        public get TryKeyword(): SyntaxToken { return this.tryKeyword; }
        public get Block(): BlockSyntax { return this.block; }
        public get Catches(): SyntaxList<CatchClauseSyntax> { return new SyntaxList<CatchClauseSyntax>().ctor_1319(this.catches); }
        public get Finally(): FinallyClauseSyntax { return this.$finally; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.tryKeyword;
                case 1: return this.block;
                case 2: return this.catches;
                case 3: return this.$finally;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.TryStatementSyntax().ctor_1844(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitTryStatement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitTryStatement(this);
        }

        public Update(tryKeyword: SyntaxToken, block: BlockSyntax, catches: SyntaxList<CatchClauseSyntax>, $finally: FinallyClauseSyntax): TryStatementSyntax {
            if (tryKeyword != this.TryKeyword || block != this.Block || catches != this.Catches || $finally != this.Finally) {
                var newNode = SyntaxFactory.TryStatement(tryKeyword, block, catches, $finally);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new TryStatementSyntax().ctor_5843(this.Kind, this.tryKeyword, this.block, this.catches, this.$finally, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new TryStatementSyntax().ctor_5843(this.Kind, this.tryKeyword, this.block, this.catches, this.$finally, this.GetDiagnostics(), annotations);
        }

        public ctor_8206(reader: Roslyn.Utilities.ObjectReader): TryStatementSyntax {
            super.ctor_1667(reader);
            this.SlotCount = 4;
            var tryKeyword = <SyntaxToken>reader.ReadValue();
            if (tryKeyword != null) {
                this.AdjustFlagsAndWidth(tryKeyword);
                this.tryKeyword = tryKeyword;
                return this;
            }
            var block = <BlockSyntax>reader.ReadValue();
            if (block != null) {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
                return this;
            }
            var catches = <CSharpSyntaxNode>reader.ReadValue();
            if (catches != null) {
                this.AdjustFlagsAndWidth(catches);
                this.catches = catches;
                return this;
            }
            var $finally = <FinallyClauseSyntax>reader.ReadValue();
            if ($finally != null) {
                this.AdjustFlagsAndWidth($finally);
                this.$finally = $finally;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.tryKeyword);
            writer.WriteValue(this.block);
            writer.WriteValue(this.catches);
            writer.WriteValue(this.$finally);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new TryStatementSyntax().ctor_8206(r);
        }
    }

    export class CatchClauseSyntax extends CSharpSyntaxNode {
        catchKeyword: SyntaxToken;
        declaration: CatchDeclarationSyntax;
        filter: CatchFilterClauseSyntax;
        block: BlockSyntax;

        constructor() { super(); }
        ctor_1699(kind: SyntaxKind, catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CatchClauseSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (filter != null) {
                this.AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }


        ctor_1246(kind: SyntaxKind, catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax, context: SyntaxFactoryContext): CatchClauseSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (filter != null) {
                this.AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }


        ctor_1985(kind: SyntaxKind, catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax): CatchClauseSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (filter != null) {
                this.AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }

        public get CatchKeyword(): SyntaxToken { return this.catchKeyword; }
        public get Declaration(): CatchDeclarationSyntax { return this.declaration; }
        public get Filter(): CatchFilterClauseSyntax { return this.filter; }
        public get Block(): BlockSyntax { return this.block; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.catchKeyword;
                case 1: return this.declaration;
                case 2: return this.filter;
                case 3: return this.block;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CatchClauseSyntax().ctor_1474(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCatchClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCatchClause(this);
        }

        public Update(catchKeyword: SyntaxToken, declaration: CatchDeclarationSyntax, filter: CatchFilterClauseSyntax, block: BlockSyntax): CatchClauseSyntax {
            if (catchKeyword != this.CatchKeyword || declaration != this.Declaration || filter != this.Filter || block != this.Block) {
                var newNode = SyntaxFactory.CatchClause(catchKeyword, declaration, filter, block);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CatchClauseSyntax().ctor_1699(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CatchClauseSyntax().ctor_1699(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, this.GetDiagnostics(), annotations);
        }

        public ctor_5034(reader: Roslyn.Utilities.ObjectReader): CatchClauseSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 4;
            var catchKeyword = <SyntaxToken>reader.ReadValue();
            if (catchKeyword != null) {
                this.AdjustFlagsAndWidth(catchKeyword);
                this.catchKeyword = catchKeyword;
                return this;
            }
            var declaration = <CatchDeclarationSyntax>reader.ReadValue();
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
                return this;
            }
            var filter = <CatchFilterClauseSyntax>reader.ReadValue();
            if (filter != null) {
                this.AdjustFlagsAndWidth(filter);
                this.filter = filter;
                return this;
            }
            var block = <BlockSyntax>reader.ReadValue();
            if (block != null) {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.catchKeyword);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.filter);
            writer.WriteValue(this.block);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CatchClauseSyntax().ctor_5034(r);
        }
    }

    export class CatchDeclarationSyntax extends CSharpSyntaxNode {
        openParenToken: SyntaxToken;
        type: TypeSyntax;
        identifier: SyntaxToken;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_1412(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CatchDeclarationSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_8016(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): CatchDeclarationSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_2026(kind: SyntaxKind, openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken): CatchDeclarationSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Type(): TypeSyntax { return this.type; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openParenToken;
                case 1: return this.type;
                case 2: return this.identifier;
                case 3: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CatchDeclarationSyntax().ctor_8164(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCatchDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCatchDeclaration(this);
        }

        public Update(openParenToken: SyntaxToken, type: TypeSyntax, identifier: SyntaxToken, closeParenToken: SyntaxToken): CatchDeclarationSyntax {
            if (openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.CatchDeclaration(openParenToken, type, identifier, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CatchDeclarationSyntax().ctor_1412(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CatchDeclarationSyntax().ctor_1412(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_6864(reader: Roslyn.Utilities.ObjectReader): CatchDeclarationSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 4;
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CatchDeclarationSyntax().ctor_6864(r);
        }
    }

    export class CatchFilterClauseSyntax extends CSharpSyntaxNode {
        ifKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        filterExpression: ExpressionSyntax;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_2244(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CatchFilterClauseSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_2083(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): CatchFilterClauseSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1409(kind: SyntaxKind, ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken): CatchFilterClauseSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get IfKeyword(): SyntaxToken { return this.ifKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get FilterExpression(): ExpressionSyntax { return this.filterExpression; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.ifKeyword;
                case 1: return this.openParenToken;
                case 2: return this.filterExpression;
                case 3: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CatchFilterClauseSyntax().ctor_1545(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCatchFilterClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCatchFilterClause(this);
        }

        public Update(ifKeyword: SyntaxToken, openParenToken: SyntaxToken, filterExpression: ExpressionSyntax, closeParenToken: SyntaxToken): CatchFilterClauseSyntax {
            if (ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || filterExpression != this.FilterExpression || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.CatchFilterClause(ifKeyword, openParenToken, filterExpression, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CatchFilterClauseSyntax().ctor_2244(this.Kind, this.ifKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CatchFilterClauseSyntax().ctor_2244(this.Kind, this.ifKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2146(reader: Roslyn.Utilities.ObjectReader): CatchFilterClauseSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 4;
            var ifKeyword = <SyntaxToken>reader.ReadValue();
            if (ifKeyword != null) {
                this.AdjustFlagsAndWidth(ifKeyword);
                this.ifKeyword = ifKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var filterExpression = <ExpressionSyntax>reader.ReadValue();
            if (filterExpression != null) {
                this.AdjustFlagsAndWidth(filterExpression);
                this.filterExpression = filterExpression;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.ifKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.filterExpression);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CatchFilterClauseSyntax().ctor_2146(r);
        }
    }

    export class FinallyClauseSyntax extends CSharpSyntaxNode {
        finallyKeyword: SyntaxToken;
        block: BlockSyntax;

        constructor() { super(); }
        ctor_3647(kind: SyntaxKind, finallyKeyword: SyntaxToken, block: BlockSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): FinallyClauseSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }


        ctor_1675(kind: SyntaxKind, finallyKeyword: SyntaxToken, block: BlockSyntax, context: SyntaxFactoryContext): FinallyClauseSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }


        ctor_1019(kind: SyntaxKind, finallyKeyword: SyntaxToken, block: BlockSyntax): FinallyClauseSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            return this;
        }

        public get FinallyKeyword(): SyntaxToken { return this.finallyKeyword; }
        public get Block(): BlockSyntax { return this.block; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.finallyKeyword;
                case 1: return this.block;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.FinallyClauseSyntax().ctor_1882(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitFinallyClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitFinallyClause(this);
        }

        public Update(finallyKeyword: SyntaxToken, block: BlockSyntax): FinallyClauseSyntax {
            if (finallyKeyword != this.FinallyKeyword || block != this.Block) {
                var newNode = SyntaxFactory.FinallyClause(finallyKeyword, block);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new FinallyClauseSyntax().ctor_3647(this.Kind, this.finallyKeyword, this.block, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new FinallyClauseSyntax().ctor_3647(this.Kind, this.finallyKeyword, this.block, this.GetDiagnostics(), annotations);
        }

        public ctor_1152(reader: Roslyn.Utilities.ObjectReader): FinallyClauseSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var finallyKeyword = <SyntaxToken>reader.ReadValue();
            if (finallyKeyword != null) {
                this.AdjustFlagsAndWidth(finallyKeyword);
                this.finallyKeyword = finallyKeyword;
                return this;
            }
            var block = <BlockSyntax>reader.ReadValue();
            if (block != null) {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.finallyKeyword);
            writer.WriteValue(this.block);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new FinallyClauseSyntax().ctor_1152(r);
        }
    }

    export class CompilationUnitSyntax extends CSharpSyntaxNode {
        externs: CSharpSyntaxNode;
        usings: CSharpSyntaxNode;
        attributeLists: CSharpSyntaxNode;
        members: CSharpSyntaxNode;
        endOfFileToken: SyntaxToken;

        constructor() { super(); }
        ctor_2478(kind: SyntaxKind, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, attributeLists: CSharpSyntaxNode, members: CSharpSyntaxNode, endOfFileToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CompilationUnitSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 5;
            if (externs != null) {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null) {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
            return this;
        }


        ctor_1663(kind: SyntaxKind, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, attributeLists: CSharpSyntaxNode, members: CSharpSyntaxNode, endOfFileToken: SyntaxToken, context: SyntaxFactoryContext): CompilationUnitSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            if (externs != null) {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null) {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
            return this;
        }


        ctor_1196(kind: SyntaxKind, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, attributeLists: CSharpSyntaxNode, members: CSharpSyntaxNode, endOfFileToken: SyntaxToken): CompilationUnitSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 5;
            if (externs != null) {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null) {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
            return this;
        }

        public get Externs(): SyntaxList<ExternAliasDirectiveSyntax> { return new SyntaxList<ExternAliasDirectiveSyntax>().ctor_1319(this.externs); }
        public get Usings(): SyntaxList<UsingDirectiveSyntax> { return new SyntaxList<UsingDirectiveSyntax>().ctor_1319(this.usings); }
        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Members(): SyntaxList<MemberDeclarationSyntax> { return new SyntaxList<MemberDeclarationSyntax>().ctor_1319(this.members); }
        public get EndOfFileToken(): SyntaxToken { return this.endOfFileToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.externs;
                case 1: return this.usings;
                case 2: return this.attributeLists;
                case 3: return this.members;
                case 4: return this.endOfFileToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CompilationUnitSyntax().ctor_7453(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCompilationUnit(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCompilationUnit(this);
        }

        public Update(externs: SyntaxList<ExternAliasDirectiveSyntax>, usings: SyntaxList<UsingDirectiveSyntax>, attributeLists: SyntaxList<AttributeListSyntax>, members: SyntaxList<MemberDeclarationSyntax>, endOfFileToken: SyntaxToken): CompilationUnitSyntax {
            if (externs != this.Externs || usings != this.Usings || attributeLists != this.AttributeLists || members != this.Members || endOfFileToken != this.EndOfFileToken) {
                var newNode = SyntaxFactory.CompilationUnit(externs, usings, attributeLists, members, endOfFileToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CompilationUnitSyntax().ctor_2478(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CompilationUnitSyntax().ctor_2478(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2631(reader: Roslyn.Utilities.ObjectReader): CompilationUnitSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 5;
            var externs = <CSharpSyntaxNode>reader.ReadValue();
            if (externs != null) {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
                return this;
            }
            var usings = <CSharpSyntaxNode>reader.ReadValue();
            if (usings != null) {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
                return this;
            }
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var members = <CSharpSyntaxNode>reader.ReadValue();
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
                return this;
            }
            var endOfFileToken = <SyntaxToken>reader.ReadValue();
            if (endOfFileToken != null) {
                this.AdjustFlagsAndWidth(endOfFileToken);
                this.endOfFileToken = endOfFileToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.externs);
            writer.WriteValue(this.usings);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.members);
            writer.WriteValue(this.endOfFileToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CompilationUnitSyntax().ctor_2631(r);
        }
    }

    export class ExternAliasDirectiveSyntax extends CSharpSyntaxNode {
        externKeyword: SyntaxToken;
        aliasKeyword: SyntaxToken;
        identifier: SyntaxToken;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_5288(kind: SyntaxKind, externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ExternAliasDirectiveSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(externKeyword);
            this.externKeyword = externKeyword;
            this.AdjustFlagsAndWidth(aliasKeyword);
            this.aliasKeyword = aliasKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_9386(kind: SyntaxKind, externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ExternAliasDirectiveSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(externKeyword);
            this.externKeyword = externKeyword;
            this.AdjustFlagsAndWidth(aliasKeyword);
            this.aliasKeyword = aliasKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_9086(kind: SyntaxKind, externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken): ExternAliasDirectiveSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(externKeyword);
            this.externKeyword = externKeyword;
            this.AdjustFlagsAndWidth(aliasKeyword);
            this.aliasKeyword = aliasKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get ExternKeyword(): SyntaxToken { return this.externKeyword; }
        public get AliasKeyword(): SyntaxToken { return this.aliasKeyword; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.externKeyword;
                case 1: return this.aliasKeyword;
                case 2: return this.identifier;
                case 3: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ExternAliasDirectiveSyntax().ctor_2123(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitExternAliasDirective(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitExternAliasDirective(this);
        }

        public Update(externKeyword: SyntaxToken, aliasKeyword: SyntaxToken, identifier: SyntaxToken, semicolonToken: SyntaxToken): ExternAliasDirectiveSyntax {
            if (externKeyword != this.ExternKeyword || aliasKeyword != this.AliasKeyword || identifier != this.Identifier || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.ExternAliasDirective(externKeyword, aliasKeyword, identifier, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ExternAliasDirectiveSyntax().ctor_5288(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ExternAliasDirectiveSyntax().ctor_5288(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1316(reader: Roslyn.Utilities.ObjectReader): ExternAliasDirectiveSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 4;
            var externKeyword = <SyntaxToken>reader.ReadValue();
            if (externKeyword != null) {
                this.AdjustFlagsAndWidth(externKeyword);
                this.externKeyword = externKeyword;
                return this;
            }
            var aliasKeyword = <SyntaxToken>reader.ReadValue();
            if (aliasKeyword != null) {
                this.AdjustFlagsAndWidth(aliasKeyword);
                this.aliasKeyword = aliasKeyword;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.externKeyword);
            writer.WriteValue(this.aliasKeyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ExternAliasDirectiveSyntax().ctor_1316(r);
        }
    }

    export class UsingDirectiveSyntax extends CSharpSyntaxNode {
        usingKeyword: SyntaxToken;
        staticKeyword: SyntaxToken;
        alias: NameEqualsSyntax;
        name: NameSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1096(kind: SyntaxKind, usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): UsingDirectiveSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            if (staticKeyword != null) {
                this.AdjustFlagsAndWidth(staticKeyword);
                this.staticKeyword = staticKeyword;
            }
            if (alias != null) {
                this.AdjustFlagsAndWidth(alias);
                this.alias = alias;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_8988(kind: SyntaxKind, usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): UsingDirectiveSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            if (staticKeyword != null) {
                this.AdjustFlagsAndWidth(staticKeyword);
                this.staticKeyword = staticKeyword;
            }
            if (alias != null) {
                this.AdjustFlagsAndWidth(alias);
                this.alias = alias;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_4334(kind: SyntaxKind, usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken): UsingDirectiveSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            if (staticKeyword != null) {
                this.AdjustFlagsAndWidth(staticKeyword);
                this.staticKeyword = staticKeyword;
            }
            if (alias != null) {
                this.AdjustFlagsAndWidth(alias);
                this.alias = alias;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get UsingKeyword(): SyntaxToken { return this.usingKeyword; }
        public get StaticKeyword(): SyntaxToken { return this.staticKeyword; }
        public get Alias(): NameEqualsSyntax { return this.alias; }
        public get Name(): NameSyntax { return this.name; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.usingKeyword;
                case 1: return this.staticKeyword;
                case 2: return this.alias;
                case 3: return this.name;
                case 4: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.UsingDirectiveSyntax().ctor_1802(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitUsingDirective(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitUsingDirective(this);
        }

        public Update(usingKeyword: SyntaxToken, staticKeyword: SyntaxToken, alias: NameEqualsSyntax, name: NameSyntax, semicolonToken: SyntaxToken): UsingDirectiveSyntax {
            if (usingKeyword != this.UsingKeyword || staticKeyword != this.StaticKeyword || alias != this.Alias || name != this.Name || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.UsingDirective(usingKeyword, staticKeyword, alias, name, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new UsingDirectiveSyntax().ctor_1096(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new UsingDirectiveSyntax().ctor_1096(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_7082(reader: Roslyn.Utilities.ObjectReader): UsingDirectiveSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 5;
            var usingKeyword = <SyntaxToken>reader.ReadValue();
            if (usingKeyword != null) {
                this.AdjustFlagsAndWidth(usingKeyword);
                this.usingKeyword = usingKeyword;
                return this;
            }
            var staticKeyword = <SyntaxToken>reader.ReadValue();
            if (staticKeyword != null) {
                this.AdjustFlagsAndWidth(staticKeyword);
                this.staticKeyword = staticKeyword;
                return this;
            }
            var alias = <NameEqualsSyntax>reader.ReadValue();
            if (alias != null) {
                this.AdjustFlagsAndWidth(alias);
                this.alias = alias;
                return this;
            }
            var name = <NameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.usingKeyword);
            writer.WriteValue(this.staticKeyword);
            writer.WriteValue(this.alias);
            writer.WriteValue(this.name);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new UsingDirectiveSyntax().ctor_7082(r);
        }
    }

    export class NamespaceDeclarationSyntax extends MemberDeclarationSyntax {
        namespaceKeyword: SyntaxToken;
        name: NameSyntax;
        openBraceToken: SyntaxToken;
        externs: CSharpSyntaxNode;
        usings: CSharpSyntaxNode;
        members: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_8254(kind: SyntaxKind, namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NamespaceDeclarationSyntax {
            super.ctor_1870(kind, diagnostics, annotations);
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(namespaceKeyword);
            this.namespaceKeyword = namespaceKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (externs != null) {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null) {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_2049(kind: SyntaxKind, namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): NamespaceDeclarationSyntax {
            super.ctor_9655(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(namespaceKeyword);
            this.namespaceKeyword = namespaceKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (externs != null) {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null) {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_5721(kind: SyntaxKind, namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: CSharpSyntaxNode, usings: CSharpSyntaxNode, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): NamespaceDeclarationSyntax {
            super.ctor_9655(kind);
            this.SlotCount = 8;
            this.AdjustFlagsAndWidth(namespaceKeyword);
            this.namespaceKeyword = namespaceKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (externs != null) {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null) {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get NamespaceKeyword(): SyntaxToken { return this.namespaceKeyword; }
        public get Name(): NameSyntax { return this.name; }
        public get OpenBraceToken(): SyntaxToken { return this.openBraceToken; }
        public get Externs(): SyntaxList<ExternAliasDirectiveSyntax> { return new SyntaxList<ExternAliasDirectiveSyntax>().ctor_1319(this.externs); }
        public get Usings(): SyntaxList<UsingDirectiveSyntax> { return new SyntaxList<UsingDirectiveSyntax>().ctor_1319(this.usings); }
        public get Members(): SyntaxList<MemberDeclarationSyntax> { return new SyntaxList<MemberDeclarationSyntax>().ctor_1319(this.members); }
        public get CloseBraceToken(): SyntaxToken { return this.closeBraceToken; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.namespaceKeyword;
                case 1: return this.name;
                case 2: return this.openBraceToken;
                case 3: return this.externs;
                case 4: return this.usings;
                case 5: return this.members;
                case 6: return this.closeBraceToken;
                case 7: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.NamespaceDeclarationSyntax().ctor_1862(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitNamespaceDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitNamespaceDeclaration(this);
        }

        public Update(namespaceKeyword: SyntaxToken, name: NameSyntax, openBraceToken: SyntaxToken, externs: SyntaxList<ExternAliasDirectiveSyntax>, usings: SyntaxList<UsingDirectiveSyntax>, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): NamespaceDeclarationSyntax {
            if (namespaceKeyword != this.NamespaceKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || externs != this.Externs || usings != this.Usings || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.NamespaceDeclaration(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new NamespaceDeclarationSyntax().ctor_8254(this.Kind, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new NamespaceDeclarationSyntax().ctor_8254(this.Kind, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1212(reader: Roslyn.Utilities.ObjectReader): NamespaceDeclarationSyntax {
            super.ctor_3031(reader);
            this.SlotCount = 8;
            var namespaceKeyword = <SyntaxToken>reader.ReadValue();
            if (namespaceKeyword != null) {
                this.AdjustFlagsAndWidth(namespaceKeyword);
                this.namespaceKeyword = namespaceKeyword;
                return this;
            }
            var name = <NameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var openBraceToken = <SyntaxToken>reader.ReadValue();
            if (openBraceToken != null) {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
                return this;
            }
            var externs = <CSharpSyntaxNode>reader.ReadValue();
            if (externs != null) {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
                return this;
            }
            var usings = <CSharpSyntaxNode>reader.ReadValue();
            if (usings != null) {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
                return this;
            }
            var members = <CSharpSyntaxNode>reader.ReadValue();
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
                return this;
            }
            var closeBraceToken = <SyntaxToken>reader.ReadValue();
            if (closeBraceToken != null) {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.namespaceKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.externs);
            writer.WriteValue(this.usings);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new NamespaceDeclarationSyntax().ctor_1212(r);
        }
    }

    export class AttributeListSyntax extends CSharpSyntaxNode {
        openBracketToken: SyntaxToken;
        target: AttributeTargetSpecifierSyntax;
        attributes: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;

        constructor() { super(); }
        ctor_1146(kind: SyntaxKind, openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: CSharpSyntaxNode, closeBracketToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AttributeListSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (target != null) {
                this.AdjustFlagsAndWidth(target);
                this.target = target;
            }
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }


        ctor_2120(kind: SyntaxKind, openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: CSharpSyntaxNode, closeBracketToken: SyntaxToken, context: SyntaxFactoryContext): AttributeListSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (target != null) {
                this.AdjustFlagsAndWidth(target);
                this.target = target;
            }
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }


        ctor_7159(kind: SyntaxKind, openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: CSharpSyntaxNode, closeBracketToken: SyntaxToken): AttributeListSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (target != null) {
                this.AdjustFlagsAndWidth(target);
                this.target = target;
            }
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }

        public get OpenBracketToken(): SyntaxToken { return this.openBracketToken; }
        public get Target(): AttributeTargetSpecifierSyntax { return this.target; }
        public get Attributes(): SeparatedSyntaxList<AttributeSyntax> { return new SeparatedSyntaxList<AttributeSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.attributes)); }
        public get CloseBracketToken(): SyntaxToken { return this.closeBracketToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openBracketToken;
                case 1: return this.target;
                case 2: return this.attributes;
                case 3: return this.closeBracketToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AttributeListSyntax().ctor_3299(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAttributeList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAttributeList(this);
        }

        public Update(openBracketToken: SyntaxToken, target: AttributeTargetSpecifierSyntax, attributes: SeparatedSyntaxList<AttributeSyntax>, closeBracketToken: SyntaxToken): AttributeListSyntax {
            if (openBracketToken != this.OpenBracketToken || target != this.Target || attributes != this.Attributes || closeBracketToken != this.CloseBracketToken) {
                var newNode = SyntaxFactory.AttributeList(openBracketToken, target, attributes, closeBracketToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AttributeListSyntax().ctor_1146(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AttributeListSyntax().ctor_1146(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1570(reader: Roslyn.Utilities.ObjectReader): AttributeListSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 4;
            var openBracketToken = <SyntaxToken>reader.ReadValue();
            if (openBracketToken != null) {
                this.AdjustFlagsAndWidth(openBracketToken);
                this.openBracketToken = openBracketToken;
                return this;
            }
            var target = <AttributeTargetSpecifierSyntax>reader.ReadValue();
            if (target != null) {
                this.AdjustFlagsAndWidth(target);
                this.target = target;
                return this;
            }
            var attributes = <CSharpSyntaxNode>reader.ReadValue();
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
                return this;
            }
            var closeBracketToken = <SyntaxToken>reader.ReadValue();
            if (closeBracketToken != null) {
                this.AdjustFlagsAndWidth(closeBracketToken);
                this.closeBracketToken = closeBracketToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.target);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.closeBracketToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AttributeListSyntax().ctor_1570(r);
        }
    }

    export class AttributeTargetSpecifierSyntax extends CSharpSyntaxNode {
        identifier: SyntaxToken;
        colonToken: SyntaxToken;

        constructor() { super(); }
        ctor_3966(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AttributeTargetSpecifierSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }


        ctor_1154(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken, context: SyntaxFactoryContext): AttributeTargetSpecifierSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }


        ctor_7732(kind: SyntaxKind, identifier: SyntaxToken, colonToken: SyntaxToken): AttributeTargetSpecifierSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }

        public get Identifier(): SyntaxToken { return this.identifier; }
        public get ColonToken(): SyntaxToken { return this.colonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.identifier;
                case 1: return this.colonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AttributeTargetSpecifierSyntax().ctor_2639(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAttributeTargetSpecifier(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAttributeTargetSpecifier(this);
        }

        public Update(identifier: SyntaxToken, colonToken: SyntaxToken): AttributeTargetSpecifierSyntax {
            if (identifier != this.Identifier || colonToken != this.ColonToken) {
                var newNode = SyntaxFactory.AttributeTargetSpecifier(identifier, colonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AttributeTargetSpecifierSyntax().ctor_3966(this.Kind, this.identifier, this.colonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AttributeTargetSpecifierSyntax().ctor_3966(this.Kind, this.identifier, this.colonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1078(reader: Roslyn.Utilities.ObjectReader): AttributeTargetSpecifierSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var colonToken = <SyntaxToken>reader.ReadValue();
            if (colonToken != null) {
                this.AdjustFlagsAndWidth(colonToken);
                this.colonToken = colonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.colonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AttributeTargetSpecifierSyntax().ctor_1078(r);
        }
    }

    export class AttributeSyntax extends CSharpSyntaxNode {
        name: NameSyntax;
        argumentList: AttributeArgumentListSyntax;

        constructor() { super(); }
        ctor_1902(kind: SyntaxKind, name: NameSyntax, argumentList: AttributeArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AttributeSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            return this;
        }


        ctor_8644(kind: SyntaxKind, name: NameSyntax, argumentList: AttributeArgumentListSyntax, context: SyntaxFactoryContext): AttributeSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            return this;
        }


        ctor_1785(kind: SyntaxKind, name: NameSyntax, argumentList: AttributeArgumentListSyntax): AttributeSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            return this;
        }

        public get Name(): NameSyntax { return this.name; }
        public get ArgumentList(): AttributeArgumentListSyntax { return this.argumentList; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.name;
                case 1: return this.argumentList;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AttributeSyntax().ctor_1064(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAttribute(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAttribute(this);
        }

        public Update(name: NameSyntax, argumentList: AttributeArgumentListSyntax): AttributeSyntax {
            if (name != this.Name || argumentList != this.ArgumentList) {
                var newNode = SyntaxFactory.Attribute(name, argumentList);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AttributeSyntax().ctor_1902(this.Kind, this.name, this.argumentList, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AttributeSyntax().ctor_1902(this.Kind, this.name, this.argumentList, this.GetDiagnostics(), annotations);
        }

        public ctor_4619(reader: Roslyn.Utilities.ObjectReader): AttributeSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var name = <NameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var argumentList = <AttributeArgumentListSyntax>reader.ReadValue();
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.argumentList);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AttributeSyntax().ctor_4619(r);
        }
    }

    export class AttributeArgumentListSyntax extends CSharpSyntaxNode {
        openParenToken: SyntaxToken;
        arguments: CSharpSyntaxNode;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_6518(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AttributeArgumentListSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1825(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): AttributeArgumentListSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_7160(kind: SyntaxKind, openParenToken: SyntaxToken, arguments: CSharpSyntaxNode, closeParenToken: SyntaxToken): AttributeArgumentListSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Arguments(): SeparatedSyntaxList<AttributeArgumentSyntax> { return new SeparatedSyntaxList<AttributeArgumentSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.arguments)); }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openParenToken;
                case 1: return this.arguments;
                case 2: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AttributeArgumentListSyntax().ctor_6570(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAttributeArgumentList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAttributeArgumentList(this);
        }

        public Update(openParenToken: SyntaxToken, arguments: SeparatedSyntaxList<AttributeArgumentSyntax>, closeParenToken: SyntaxToken): AttributeArgumentListSyntax {
            if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.AttributeArgumentList(openParenToken, arguments, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AttributeArgumentListSyntax().ctor_6518(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AttributeArgumentListSyntax().ctor_6518(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1195(reader: Roslyn.Utilities.ObjectReader): AttributeArgumentListSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var arguments = <CSharpSyntaxNode>reader.ReadValue();
            if (arguments != null) {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AttributeArgumentListSyntax().ctor_1195(r);
        }
    }

    export class AttributeArgumentSyntax extends CSharpSyntaxNode {
        nameEquals: NameEqualsSyntax;
        nameColon: NameColonSyntax;
        expression: ExpressionSyntax;

        constructor() { super(); }
        ctor_1391(kind: SyntaxKind, nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AttributeArgumentSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            if (nameEquals != null) {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            if (nameColon != null) {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_2711(kind: SyntaxKind, nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax, context: SyntaxFactoryContext): AttributeArgumentSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            if (nameEquals != null) {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            if (nameColon != null) {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1277(kind: SyntaxKind, nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax): AttributeArgumentSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            if (nameEquals != null) {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            if (nameColon != null) {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }

        public get NameEquals(): NameEqualsSyntax { return this.nameEquals; }
        public get NameColon(): NameColonSyntax { return this.nameColon; }
        public get Expression(): ExpressionSyntax { return this.expression; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.nameEquals;
                case 1: return this.nameColon;
                case 2: return this.expression;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AttributeArgumentSyntax().ctor_1819(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAttributeArgument(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAttributeArgument(this);
        }

        public Update(nameEquals: NameEqualsSyntax, nameColon: NameColonSyntax, expression: ExpressionSyntax): AttributeArgumentSyntax {
            if (nameEquals != this.NameEquals || nameColon != this.NameColon || expression != this.Expression) {
                var newNode = SyntaxFactory.AttributeArgument(nameEquals, nameColon, expression);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AttributeArgumentSyntax().ctor_1391(this.Kind, this.nameEquals, this.nameColon, this.expression, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AttributeArgumentSyntax().ctor_1391(this.Kind, this.nameEquals, this.nameColon, this.expression, this.GetDiagnostics(), annotations);
        }

        public ctor_1998(reader: Roslyn.Utilities.ObjectReader): AttributeArgumentSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var nameEquals = <NameEqualsSyntax>reader.ReadValue();
            if (nameEquals != null) {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
                return this;
            }
            var nameColon = <NameColonSyntax>reader.ReadValue();
            if (nameColon != null) {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.nameEquals);
            writer.WriteValue(this.nameColon);
            writer.WriteValue(this.expression);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AttributeArgumentSyntax().ctor_1998(r);
        }
    }

    export class NameEqualsSyntax extends CSharpSyntaxNode {
        name: IdentifierNameSyntax;
        equalsToken: SyntaxToken;

        constructor() { super(); }
        ctor_8031(kind: SyntaxKind, name: IdentifierNameSyntax, equalsToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NameEqualsSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            return this;
        }


        ctor_8701(kind: SyntaxKind, name: IdentifierNameSyntax, equalsToken: SyntaxToken, context: SyntaxFactoryContext): NameEqualsSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            return this;
        }


        ctor_1747(kind: SyntaxKind, name: IdentifierNameSyntax, equalsToken: SyntaxToken): NameEqualsSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            return this;
        }

        public get Name(): IdentifierNameSyntax { return this.name; }
        public get EqualsToken(): SyntaxToken { return this.equalsToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.name;
                case 1: return this.equalsToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.NameEqualsSyntax().ctor_8735(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitNameEquals(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitNameEquals(this);
        }

        public Update(name: IdentifierNameSyntax, equalsToken: SyntaxToken): NameEqualsSyntax {
            if (name != this.Name || equalsToken != this.EqualsToken) {
                var newNode = SyntaxFactory.NameEquals(name, equalsToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new NameEqualsSyntax().ctor_8031(this.Kind, this.name, this.equalsToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new NameEqualsSyntax().ctor_8031(this.Kind, this.name, this.equalsToken, this.GetDiagnostics(), annotations);
        }

        public ctor_8818(reader: Roslyn.Utilities.ObjectReader): NameEqualsSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var name = <IdentifierNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var equalsToken = <SyntaxToken>reader.ReadValue();
            if (equalsToken != null) {
                this.AdjustFlagsAndWidth(equalsToken);
                this.equalsToken = equalsToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new NameEqualsSyntax().ctor_8818(r);
        }
    }

    export class TypeParameterListSyntax extends CSharpSyntaxNode {
        lessThanToken: SyntaxToken;
        parameters: CSharpSyntaxNode;
        greaterThanToken: SyntaxToken;

        constructor() { super(); }
        ctor_1188(kind: SyntaxKind, lessThanToken: SyntaxToken, parameters: CSharpSyntaxNode, greaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeParameterListSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }


        ctor_1045(kind: SyntaxKind, lessThanToken: SyntaxToken, parameters: CSharpSyntaxNode, greaterThanToken: SyntaxToken, context: SyntaxFactoryContext): TypeParameterListSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }


        ctor_1238(kind: SyntaxKind, lessThanToken: SyntaxToken, parameters: CSharpSyntaxNode, greaterThanToken: SyntaxToken): TypeParameterListSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }

        public get LessThanToken(): SyntaxToken { return this.lessThanToken; }
        public get Parameters(): SeparatedSyntaxList<TypeParameterSyntax> { return new SeparatedSyntaxList<TypeParameterSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.parameters)); }
        public get GreaterThanToken(): SyntaxToken { return this.greaterThanToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.lessThanToken;
                case 1: return this.parameters;
                case 2: return this.greaterThanToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.TypeParameterListSyntax().ctor_2009(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitTypeParameterList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitTypeParameterList(this);
        }

        public Update(lessThanToken: SyntaxToken, parameters: SeparatedSyntaxList<TypeParameterSyntax>, greaterThanToken: SyntaxToken): TypeParameterListSyntax {
            if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken) {
                var newNode = SyntaxFactory.TypeParameterList(lessThanToken, parameters, greaterThanToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new TypeParameterListSyntax().ctor_1188(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new TypeParameterListSyntax().ctor_1188(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1484(reader: Roslyn.Utilities.ObjectReader): TypeParameterListSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var lessThanToken = <SyntaxToken>reader.ReadValue();
            if (lessThanToken != null) {
                this.AdjustFlagsAndWidth(lessThanToken);
                this.lessThanToken = lessThanToken;
                return this;
            }
            var parameters = <CSharpSyntaxNode>reader.ReadValue();
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
                return this;
            }
            var greaterThanToken = <SyntaxToken>reader.ReadValue();
            if (greaterThanToken != null) {
                this.AdjustFlagsAndWidth(greaterThanToken);
                this.greaterThanToken = greaterThanToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.greaterThanToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new TypeParameterListSyntax().ctor_1484(r);
        }
    }

    export class TypeParameterSyntax extends CSharpSyntaxNode {
        attributeLists: CSharpSyntaxNode;
        varianceKeyword: SyntaxToken;
        identifier: SyntaxToken;

        constructor() { super(); }
        ctor_1707(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, varianceKeyword: SyntaxToken, identifier: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeParameterSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (varianceKeyword != null) {
                this.AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            return this;
        }


        ctor_6048(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, varianceKeyword: SyntaxToken, identifier: SyntaxToken, context: SyntaxFactoryContext): TypeParameterSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (varianceKeyword != null) {
                this.AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            return this;
        }


        ctor_1702(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, varianceKeyword: SyntaxToken, identifier: SyntaxToken): TypeParameterSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (varianceKeyword != null) {
                this.AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get VarianceKeyword(): SyntaxToken { return this.varianceKeyword; }
        public get Identifier(): SyntaxToken { return this.identifier; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.varianceKeyword;
                case 2: return this.identifier;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.TypeParameterSyntax().ctor_1706(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitTypeParameter(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitTypeParameter(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, varianceKeyword: SyntaxToken, identifier: SyntaxToken): TypeParameterSyntax {
            if (attributeLists != this.AttributeLists || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier) {
                var newNode = SyntaxFactory.TypeParameter(attributeLists, varianceKeyword, identifier);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new TypeParameterSyntax().ctor_1707(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new TypeParameterSyntax().ctor_1707(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, this.GetDiagnostics(), annotations);
        }

        public ctor_5018(reader: Roslyn.Utilities.ObjectReader): TypeParameterSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var varianceKeyword = <SyntaxToken>reader.ReadValue();
            if (varianceKeyword != null) {
                this.AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.varianceKeyword);
            writer.WriteValue(this.identifier);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new TypeParameterSyntax().ctor_5018(r);
        }
    }

    export class BaseTypeDeclarationSyntax extends MemberDeclarationSyntax {
        constructor() { super(); }
        ctor_6723(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseTypeDeclarationSyntax {
            super.ctor_1870(kind, diagnostics, annotations);
            return this;
        }
        ctor_1217(kind: SyntaxKind): BaseTypeDeclarationSyntax {
            super.ctor_9655(kind);
            return this;
        }

        ctor_6865(reader: Roslyn.Utilities.ObjectReader): BaseTypeDeclarationSyntax {
            super.ctor_3031(reader);
            return this;
        }

        public AttributeLists: SyntaxList<AttributeListSyntax>;

        public Modifiers: SyntaxList<SyntaxToken>;

        public Identifier: SyntaxToken;

        public BaseList: BaseListSyntax;

        public OpenBraceToken: SyntaxToken;

        public CloseBraceToken: SyntaxToken;

        public SemicolonToken: SyntaxToken;
    }

    export class TypeDeclarationSyntax extends BaseTypeDeclarationSyntax {
        constructor() { super(); }
        ctor_1185(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeDeclarationSyntax {
            super.ctor_6723(kind, diagnostics, annotations);
            return this;
        }
        ctor_1477(kind: SyntaxKind): TypeDeclarationSyntax {
            super.ctor_1217(kind);
            return this;
        }

        ctor_7894(reader: Roslyn.Utilities.ObjectReader): TypeDeclarationSyntax {
            super.ctor_6865(reader);
            return this;
        }

        public Keyword: SyntaxToken;

        public TypeParameterList: TypeParameterListSyntax;

        public ConstraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>;

        public Members: SyntaxList<MemberDeclarationSyntax>;
    }

    export class ClassDeclarationSyntax extends TypeDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        keyword: SyntaxToken;
        identifier: SyntaxToken;
        typeParameterList: TypeParameterListSyntax;
        baseList: BaseListSyntax;
        constraintClauses: CSharpSyntaxNode;
        openBraceToken: SyntaxToken;
        members: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_6165(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ClassDeclarationSyntax {
            super.ctor_1185(kind, diagnostics, annotations);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_9117(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ClassDeclarationSyntax {
            super.ctor_1477(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1033(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): ClassDeclarationSyntax {
            super.ctor_1477(kind);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Keyword(): SyntaxToken { return this.keyword; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get TypeParameterList(): TypeParameterListSyntax { return this.typeParameterList; }
        public get BaseList(): BaseListSyntax { return this.baseList; }
        public get ConstraintClauses(): SyntaxList<TypeParameterConstraintClauseSyntax> { return new SyntaxList<TypeParameterConstraintClauseSyntax>().ctor_1319(this.constraintClauses); }
        public get OpenBraceToken(): SyntaxToken { return this.openBraceToken; }
        public get Members(): SyntaxList<MemberDeclarationSyntax> { return new SyntaxList<MemberDeclarationSyntax>().ctor_1319(this.members); }
        public get CloseBraceToken(): SyntaxToken { return this.closeBraceToken; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.keyword;
                case 3: return this.identifier;
                case 4: return this.typeParameterList;
                case 5: return this.baseList;
                case 6: return this.constraintClauses;
                case 7: return this.openBraceToken;
                case 8: return this.members;
                case 9: return this.closeBraceToken;
                case 10: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ClassDeclarationSyntax().ctor_1093(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitClassDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitClassDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): ClassDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.ClassDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ClassDeclarationSyntax().ctor_6165(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ClassDeclarationSyntax().ctor_6165(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_8597(reader: Roslyn.Utilities.ObjectReader): ClassDeclarationSyntax {
            super.ctor_7894(reader);
            this.SlotCount = 11;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var typeParameterList = <TypeParameterListSyntax>reader.ReadValue();
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
                return this;
            }
            var baseList = <BaseListSyntax>reader.ReadValue();
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
                return this;
            }
            var constraintClauses = <CSharpSyntaxNode>reader.ReadValue();
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
                return this;
            }
            var openBraceToken = <SyntaxToken>reader.ReadValue();
            if (openBraceToken != null) {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
                return this;
            }
            var members = <CSharpSyntaxNode>reader.ReadValue();
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
                return this;
            }
            var closeBraceToken = <SyntaxToken>reader.ReadValue();
            if (closeBraceToken != null) {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.baseList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ClassDeclarationSyntax().ctor_8597(r);
        }
    }

    export class StructDeclarationSyntax extends TypeDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        keyword: SyntaxToken;
        identifier: SyntaxToken;
        typeParameterList: TypeParameterListSyntax;
        baseList: BaseListSyntax;
        constraintClauses: CSharpSyntaxNode;
        openBraceToken: SyntaxToken;
        members: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_9339(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): StructDeclarationSyntax {
            super.ctor_1185(kind, diagnostics, annotations);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1044(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): StructDeclarationSyntax {
            super.ctor_1477(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_2110(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): StructDeclarationSyntax {
            super.ctor_1477(kind);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Keyword(): SyntaxToken { return this.keyword; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get TypeParameterList(): TypeParameterListSyntax { return this.typeParameterList; }
        public get BaseList(): BaseListSyntax { return this.baseList; }
        public get ConstraintClauses(): SyntaxList<TypeParameterConstraintClauseSyntax> { return new SyntaxList<TypeParameterConstraintClauseSyntax>().ctor_1319(this.constraintClauses); }
        public get OpenBraceToken(): SyntaxToken { return this.openBraceToken; }
        public get Members(): SyntaxList<MemberDeclarationSyntax> { return new SyntaxList<MemberDeclarationSyntax>().ctor_1319(this.members); }
        public get CloseBraceToken(): SyntaxToken { return this.closeBraceToken; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.keyword;
                case 3: return this.identifier;
                case 4: return this.typeParameterList;
                case 5: return this.baseList;
                case 6: return this.constraintClauses;
                case 7: return this.openBraceToken;
                case 8: return this.members;
                case 9: return this.closeBraceToken;
                case 10: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.StructDeclarationSyntax().ctor_1296(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitStructDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitStructDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): StructDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.StructDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new StructDeclarationSyntax().ctor_9339(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new StructDeclarationSyntax().ctor_9339(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1785(reader: Roslyn.Utilities.ObjectReader): StructDeclarationSyntax {
            super.ctor_7894(reader);
            this.SlotCount = 11;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var typeParameterList = <TypeParameterListSyntax>reader.ReadValue();
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
                return this;
            }
            var baseList = <BaseListSyntax>reader.ReadValue();
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
                return this;
            }
            var constraintClauses = <CSharpSyntaxNode>reader.ReadValue();
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
                return this;
            }
            var openBraceToken = <SyntaxToken>reader.ReadValue();
            if (openBraceToken != null) {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
                return this;
            }
            var members = <CSharpSyntaxNode>reader.ReadValue();
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
                return this;
            }
            var closeBraceToken = <SyntaxToken>reader.ReadValue();
            if (closeBraceToken != null) {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.baseList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new StructDeclarationSyntax().ctor_1785(r);
        }
    }

    export class InterfaceDeclarationSyntax extends TypeDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        keyword: SyntaxToken;
        identifier: SyntaxToken;
        typeParameterList: TypeParameterListSyntax;
        baseList: BaseListSyntax;
        constraintClauses: CSharpSyntaxNode;
        openBraceToken: SyntaxToken;
        members: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_7253(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InterfaceDeclarationSyntax {
            super.ctor_1185(kind, diagnostics, annotations);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1608(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): InterfaceDeclarationSyntax {
            super.ctor_1477(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1999(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: CSharpSyntaxNode, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): InterfaceDeclarationSyntax {
            super.ctor_1477(kind);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Keyword(): SyntaxToken { return this.keyword; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get TypeParameterList(): TypeParameterListSyntax { return this.typeParameterList; }
        public get BaseList(): BaseListSyntax { return this.baseList; }
        public get ConstraintClauses(): SyntaxList<TypeParameterConstraintClauseSyntax> { return new SyntaxList<TypeParameterConstraintClauseSyntax>().ctor_1319(this.constraintClauses); }
        public get OpenBraceToken(): SyntaxToken { return this.openBraceToken; }
        public get Members(): SyntaxList<MemberDeclarationSyntax> { return new SyntaxList<MemberDeclarationSyntax>().ctor_1319(this.members); }
        public get CloseBraceToken(): SyntaxToken { return this.closeBraceToken; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.keyword;
                case 3: return this.identifier;
                case 4: return this.typeParameterList;
                case 5: return this.baseList;
                case 6: return this.constraintClauses;
                case 7: return this.openBraceToken;
                case 8: return this.members;
                case 9: return this.closeBraceToken;
                case 10: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.InterfaceDeclarationSyntax().ctor_6961(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitInterfaceDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitInterfaceDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, baseList: BaseListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, openBraceToken: SyntaxToken, members: SyntaxList<MemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): InterfaceDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.InterfaceDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new InterfaceDeclarationSyntax().ctor_7253(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new InterfaceDeclarationSyntax().ctor_7253(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1997(reader: Roslyn.Utilities.ObjectReader): InterfaceDeclarationSyntax {
            super.ctor_7894(reader);
            this.SlotCount = 11;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var typeParameterList = <TypeParameterListSyntax>reader.ReadValue();
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
                return this;
            }
            var baseList = <BaseListSyntax>reader.ReadValue();
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
                return this;
            }
            var constraintClauses = <CSharpSyntaxNode>reader.ReadValue();
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
                return this;
            }
            var openBraceToken = <SyntaxToken>reader.ReadValue();
            if (openBraceToken != null) {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
                return this;
            }
            var members = <CSharpSyntaxNode>reader.ReadValue();
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
                return this;
            }
            var closeBraceToken = <SyntaxToken>reader.ReadValue();
            if (closeBraceToken != null) {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.baseList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new InterfaceDeclarationSyntax().ctor_1997(r);
        }
    }

    export class EnumDeclarationSyntax extends BaseTypeDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        enumKeyword: SyntaxToken;
        identifier: SyntaxToken;
        baseList: BaseListSyntax;
        openBraceToken: SyntaxToken;
        members: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1399(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EnumDeclarationSyntax {
            super.ctor_6723(kind, diagnostics, annotations);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(enumKeyword);
            this.enumKeyword = enumKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1300(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): EnumDeclarationSyntax {
            super.ctor_1217(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(enumKeyword);
            this.enumKeyword = enumKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_5779(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: CSharpSyntaxNode, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): EnumDeclarationSyntax {
            super.ctor_1217(kind);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(enumKeyword);
            this.enumKeyword = enumKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get EnumKeyword(): SyntaxToken { return this.enumKeyword; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get BaseList(): BaseListSyntax { return this.baseList; }
        public get OpenBraceToken(): SyntaxToken { return this.openBraceToken; }
        public get Members(): SeparatedSyntaxList<EnumMemberDeclarationSyntax> { return new SeparatedSyntaxList<EnumMemberDeclarationSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.members)); }
        public get CloseBraceToken(): SyntaxToken { return this.closeBraceToken; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.enumKeyword;
                case 3: return this.identifier;
                case 4: return this.baseList;
                case 5: return this.openBraceToken;
                case 6: return this.members;
                case 7: return this.closeBraceToken;
                case 8: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.EnumDeclarationSyntax().ctor_1697(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitEnumDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitEnumDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, enumKeyword: SyntaxToken, identifier: SyntaxToken, baseList: BaseListSyntax, openBraceToken: SyntaxToken, members: SeparatedSyntaxList<EnumMemberDeclarationSyntax>, closeBraceToken: SyntaxToken, semicolonToken: SyntaxToken): EnumDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || enumKeyword != this.EnumKeyword || identifier != this.Identifier || baseList != this.BaseList || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.EnumDeclaration(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new EnumDeclarationSyntax().ctor_1399(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new EnumDeclarationSyntax().ctor_1399(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2479(reader: Roslyn.Utilities.ObjectReader): EnumDeclarationSyntax {
            super.ctor_6865(reader);
            this.SlotCount = 9;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var enumKeyword = <SyntaxToken>reader.ReadValue();
            if (enumKeyword != null) {
                this.AdjustFlagsAndWidth(enumKeyword);
                this.enumKeyword = enumKeyword;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var baseList = <BaseListSyntax>reader.ReadValue();
            if (baseList != null) {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
                return this;
            }
            var openBraceToken = <SyntaxToken>reader.ReadValue();
            if (openBraceToken != null) {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
                return this;
            }
            var members = <CSharpSyntaxNode>reader.ReadValue();
            if (members != null) {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
                return this;
            }
            var closeBraceToken = <SyntaxToken>reader.ReadValue();
            if (closeBraceToken != null) {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.enumKeyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.baseList);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new EnumDeclarationSyntax().ctor_2479(r);
        }
    }

    export class DelegateDeclarationSyntax extends MemberDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        delegateKeyword: SyntaxToken;
        returnType: TypeSyntax;
        identifier: SyntaxToken;
        typeParameterList: TypeParameterListSyntax;
        parameterList: ParameterListSyntax;
        constraintClauses: CSharpSyntaxNode;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1428(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DelegateDeclarationSyntax {
            super.ctor_1870(kind, diagnostics, annotations);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1031(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): DelegateDeclarationSyntax {
            super.ctor_9655(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_4290(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, semicolonToken: SyntaxToken): DelegateDeclarationSyntax {
            super.ctor_9655(kind);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get DelegateKeyword(): SyntaxToken { return this.delegateKeyword; }
        public get ReturnType(): TypeSyntax { return this.returnType; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get TypeParameterList(): TypeParameterListSyntax { return this.typeParameterList; }
        public get ParameterList(): ParameterListSyntax { return this.parameterList; }
        public get ConstraintClauses(): SyntaxList<TypeParameterConstraintClauseSyntax> { return new SyntaxList<TypeParameterConstraintClauseSyntax>().ctor_1319(this.constraintClauses); }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.delegateKeyword;
                case 3: return this.returnType;
                case 4: return this.identifier;
                case 5: return this.typeParameterList;
                case 6: return this.parameterList;
                case 7: return this.constraintClauses;
                case 8: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.DelegateDeclarationSyntax().ctor_1095(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitDelegateDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitDelegateDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, delegateKeyword: SyntaxToken, returnType: TypeSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, semicolonToken: SyntaxToken): DelegateDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || delegateKeyword != this.DelegateKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.DelegateDeclaration(attributeLists, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new DelegateDeclarationSyntax().ctor_1428(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new DelegateDeclarationSyntax().ctor_1428(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_4089(reader: Roslyn.Utilities.ObjectReader): DelegateDeclarationSyntax {
            super.ctor_3031(reader);
            this.SlotCount = 9;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var delegateKeyword = <SyntaxToken>reader.ReadValue();
            if (delegateKeyword != null) {
                this.AdjustFlagsAndWidth(delegateKeyword);
                this.delegateKeyword = delegateKeyword;
                return this;
            }
            var returnType = <TypeSyntax>reader.ReadValue();
            if (returnType != null) {
                this.AdjustFlagsAndWidth(returnType);
                this.returnType = returnType;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var typeParameterList = <TypeParameterListSyntax>reader.ReadValue();
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
                return this;
            }
            var parameterList = <ParameterListSyntax>reader.ReadValue();
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
                return this;
            }
            var constraintClauses = <CSharpSyntaxNode>reader.ReadValue();
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.delegateKeyword);
            writer.WriteValue(this.returnType);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new DelegateDeclarationSyntax().ctor_4089(r);
        }
    }

    export class EnumMemberDeclarationSyntax extends MemberDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        identifier: SyntaxToken;
        equalsValue: EqualsValueClauseSyntax;

        constructor() { super(); }
        ctor_1311(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EnumMemberDeclarationSyntax {
            super.ctor_1870(kind, diagnostics, annotations);
            this.SlotCount = 3;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (equalsValue != null) {
                this.AdjustFlagsAndWidth(equalsValue);
                this.equalsValue = equalsValue;
            }
            return this;
        }


        ctor_1553(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax, context: SyntaxFactoryContext): EnumMemberDeclarationSyntax {
            super.ctor_9655(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (equalsValue != null) {
                this.AdjustFlagsAndWidth(equalsValue);
                this.equalsValue = equalsValue;
            }
            return this;
        }


        ctor_2110(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax): EnumMemberDeclarationSyntax {
            super.ctor_9655(kind);
            this.SlotCount = 3;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (equalsValue != null) {
                this.AdjustFlagsAndWidth(equalsValue);
                this.equalsValue = equalsValue;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get EqualsValue(): EqualsValueClauseSyntax { return this.equalsValue; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.identifier;
                case 2: return this.equalsValue;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.EnumMemberDeclarationSyntax().ctor_9853(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitEnumMemberDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitEnumMemberDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, identifier: SyntaxToken, equalsValue: EqualsValueClauseSyntax): EnumMemberDeclarationSyntax {
            if (attributeLists != this.AttributeLists || identifier != this.Identifier || equalsValue != this.EqualsValue) {
                var newNode = SyntaxFactory.EnumMemberDeclaration(attributeLists, identifier, equalsValue);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new EnumMemberDeclarationSyntax().ctor_1311(this.Kind, this.attributeLists, this.identifier, this.equalsValue, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new EnumMemberDeclarationSyntax().ctor_1311(this.Kind, this.attributeLists, this.identifier, this.equalsValue, this.GetDiagnostics(), annotations);
        }

        public ctor_1255(reader: Roslyn.Utilities.ObjectReader): EnumMemberDeclarationSyntax {
            super.ctor_3031(reader);
            this.SlotCount = 3;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var equalsValue = <EqualsValueClauseSyntax>reader.ReadValue();
            if (equalsValue != null) {
                this.AdjustFlagsAndWidth(equalsValue);
                this.equalsValue = equalsValue;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.equalsValue);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new EnumMemberDeclarationSyntax().ctor_1255(r);
        }
    }

    export class BaseListSyntax extends CSharpSyntaxNode {
        colonToken: SyntaxToken;
        types: CSharpSyntaxNode;

        constructor() { super(); }
        ctor_7378(kind: SyntaxKind, colonToken: SyntaxToken, types: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseListSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (types != null) {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
            return this;
        }


        ctor_6846(kind: SyntaxKind, colonToken: SyntaxToken, types: CSharpSyntaxNode, context: SyntaxFactoryContext): BaseListSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (types != null) {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
            return this;
        }


        ctor_4637(kind: SyntaxKind, colonToken: SyntaxToken, types: CSharpSyntaxNode): BaseListSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (types != null) {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
            return this;
        }

        public get ColonToken(): SyntaxToken { return this.colonToken; }
        public get Types(): SeparatedSyntaxList<BaseTypeSyntax> { return new SeparatedSyntaxList<BaseTypeSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.types)); }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.colonToken;
                case 1: return this.types;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.BaseListSyntax().ctor_1136(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitBaseList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitBaseList(this);
        }

        public Update(colonToken: SyntaxToken, types: SeparatedSyntaxList<BaseTypeSyntax>): BaseListSyntax {
            if (colonToken != this.ColonToken || types != this.Types) {
                var newNode = SyntaxFactory.BaseList(colonToken, types);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new BaseListSyntax().ctor_7378(this.Kind, this.colonToken, this.types, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new BaseListSyntax().ctor_7378(this.Kind, this.colonToken, this.types, this.GetDiagnostics(), annotations);
        }

        public ctor_2054(reader: Roslyn.Utilities.ObjectReader): BaseListSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var colonToken = <SyntaxToken>reader.ReadValue();
            if (colonToken != null) {
                this.AdjustFlagsAndWidth(colonToken);
                this.colonToken = colonToken;
                return this;
            }
            var types = <CSharpSyntaxNode>reader.ReadValue();
            if (types != null) {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.types);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new BaseListSyntax().ctor_2054(r);
        }
    }

    export class BaseTypeSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_1077(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseTypeSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_5303(kind: SyntaxKind): BaseTypeSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_1167(reader: Roslyn.Utilities.ObjectReader): BaseTypeSyntax {
            super.ctor_4942(reader);
            return this;
        }

        public Type: TypeSyntax;
    }

    export class SimpleBaseTypeSyntax extends BaseTypeSyntax {
        type: TypeSyntax;

        constructor() { super(); }
        ctor_1317(kind: SyntaxKind, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SimpleBaseTypeSyntax {
            super.ctor_1077(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }


        ctor_1905(kind: SyntaxKind, type: TypeSyntax, context: SyntaxFactoryContext): SimpleBaseTypeSyntax {
            super.ctor_5303(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }


        ctor_2816(kind: SyntaxKind, type: TypeSyntax): SimpleBaseTypeSyntax {
            super.ctor_5303(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }

        public get Type(): TypeSyntax { return this.type; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.type;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.SimpleBaseTypeSyntax().ctor_1308(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitSimpleBaseType(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitSimpleBaseType(this);
        }

        public Update(type: TypeSyntax): SimpleBaseTypeSyntax {
            if (type != this.Type) {
                var newNode = SyntaxFactory.SimpleBaseType(type);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new SimpleBaseTypeSyntax().ctor_1317(this.Kind, this.type, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new SimpleBaseTypeSyntax().ctor_1317(this.Kind, this.type, this.GetDiagnostics(), annotations);
        }

        public ctor_1769(reader: Roslyn.Utilities.ObjectReader): SimpleBaseTypeSyntax {
            super.ctor_1167(reader);
            this.SlotCount = 1;
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.type);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new SimpleBaseTypeSyntax().ctor_1769(r);
        }
    }

    export class TypeParameterConstraintClauseSyntax extends CSharpSyntaxNode {
        whereKeyword: SyntaxToken;
        name: IdentifierNameSyntax;
        colonToken: SyntaxToken;
        constraints: CSharpSyntaxNode;

        constructor() { super(); }
        ctor_7439(kind: SyntaxKind, whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeParameterConstraintClauseSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (constraints != null) {
                this.AdjustFlagsAndWidth(constraints);
                this.constraints = constraints;
            }
            return this;
        }


        ctor_8985(kind: SyntaxKind, whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: CSharpSyntaxNode, context: SyntaxFactoryContext): TypeParameterConstraintClauseSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (constraints != null) {
                this.AdjustFlagsAndWidth(constraints);
                this.constraints = constraints;
            }
            return this;
        }


        ctor_7998(kind: SyntaxKind, whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: CSharpSyntaxNode): TypeParameterConstraintClauseSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (constraints != null) {
                this.AdjustFlagsAndWidth(constraints);
                this.constraints = constraints;
            }
            return this;
        }

        public get WhereKeyword(): SyntaxToken { return this.whereKeyword; }
        public get Name(): IdentifierNameSyntax { return this.name; }
        public get ColonToken(): SyntaxToken { return this.colonToken; }
        public get Constraints(): SeparatedSyntaxList<TypeParameterConstraintSyntax> { return new SeparatedSyntaxList<TypeParameterConstraintSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.constraints)); }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.whereKeyword;
                case 1: return this.name;
                case 2: return this.colonToken;
                case 3: return this.constraints;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.TypeParameterConstraintClauseSyntax().ctor_2081(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitTypeParameterConstraintClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitTypeParameterConstraintClause(this);
        }

        public Update(whereKeyword: SyntaxToken, name: IdentifierNameSyntax, colonToken: SyntaxToken, constraints: SeparatedSyntaxList<TypeParameterConstraintSyntax>): TypeParameterConstraintClauseSyntax {
            if (whereKeyword != this.WhereKeyword || name != this.Name || colonToken != this.ColonToken || constraints != this.Constraints) {
                var newNode = SyntaxFactory.TypeParameterConstraintClause(whereKeyword, name, colonToken, constraints);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new TypeParameterConstraintClauseSyntax().ctor_7439(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new TypeParameterConstraintClauseSyntax().ctor_7439(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, this.GetDiagnostics(), annotations);
        }

        public ctor_7463(reader: Roslyn.Utilities.ObjectReader): TypeParameterConstraintClauseSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 4;
            var whereKeyword = <SyntaxToken>reader.ReadValue();
            if (whereKeyword != null) {
                this.AdjustFlagsAndWidth(whereKeyword);
                this.whereKeyword = whereKeyword;
                return this;
            }
            var name = <IdentifierNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var colonToken = <SyntaxToken>reader.ReadValue();
            if (colonToken != null) {
                this.AdjustFlagsAndWidth(colonToken);
                this.colonToken = colonToken;
                return this;
            }
            var constraints = <CSharpSyntaxNode>reader.ReadValue();
            if (constraints != null) {
                this.AdjustFlagsAndWidth(constraints);
                this.constraints = constraints;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.whereKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.constraints);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new TypeParameterConstraintClauseSyntax().ctor_7463(r);
        }
    }

    export class TypeParameterConstraintSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_5924(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeParameterConstraintSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_1641(kind: SyntaxKind): TypeParameterConstraintSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_2140(reader: Roslyn.Utilities.ObjectReader): TypeParameterConstraintSyntax {
            super.ctor_4942(reader);
            return this;
        }
    }

    export class ConstructorConstraintSyntax extends TypeParameterConstraintSyntax {
        newKeyword: SyntaxToken;
        openParenToken: SyntaxToken;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_3835(kind: SyntaxKind, newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConstructorConstraintSyntax {
            super.ctor_5924(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1843(kind: SyntaxKind, newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): ConstructorConstraintSyntax {
            super.ctor_1641(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_2123(kind: SyntaxKind, newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken): ConstructorConstraintSyntax {
            super.ctor_1641(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get NewKeyword(): SyntaxToken { return this.newKeyword; }
        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.newKeyword;
                case 1: return this.openParenToken;
                case 2: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ConstructorConstraintSyntax().ctor_4479(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitConstructorConstraint(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitConstructorConstraint(this);
        }

        public Update(newKeyword: SyntaxToken, openParenToken: SyntaxToken, closeParenToken: SyntaxToken): ConstructorConstraintSyntax {
            if (newKeyword != this.NewKeyword || openParenToken != this.OpenParenToken || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.ConstructorConstraint(newKeyword, openParenToken, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ConstructorConstraintSyntax().ctor_3835(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ConstructorConstraintSyntax().ctor_3835(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1192(reader: Roslyn.Utilities.ObjectReader): ConstructorConstraintSyntax {
            super.ctor_2140(reader);
            this.SlotCount = 3;
            var newKeyword = <SyntaxToken>reader.ReadValue();
            if (newKeyword != null) {
                this.AdjustFlagsAndWidth(newKeyword);
                this.newKeyword = newKeyword;
                return this;
            }
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ConstructorConstraintSyntax().ctor_1192(r);
        }
    }

    export class ClassOrStructConstraintSyntax extends TypeParameterConstraintSyntax {
        classOrStructKeyword: SyntaxToken;

        constructor() { super(); }
        ctor_1261(kind: SyntaxKind, classOrStructKeyword: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ClassOrStructConstraintSyntax {
            super.ctor_5924(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(classOrStructKeyword);
            this.classOrStructKeyword = classOrStructKeyword;
            return this;
        }


        ctor_1041(kind: SyntaxKind, classOrStructKeyword: SyntaxToken, context: SyntaxFactoryContext): ClassOrStructConstraintSyntax {
            super.ctor_1641(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(classOrStructKeyword);
            this.classOrStructKeyword = classOrStructKeyword;
            return this;
        }


        ctor_1052(kind: SyntaxKind, classOrStructKeyword: SyntaxToken): ClassOrStructConstraintSyntax {
            super.ctor_1641(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(classOrStructKeyword);
            this.classOrStructKeyword = classOrStructKeyword;
            return this;
        }

        public get ClassOrStructKeyword(): SyntaxToken { return this.classOrStructKeyword; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.classOrStructKeyword;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ClassOrStructConstraintSyntax().ctor_1223(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitClassOrStructConstraint(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitClassOrStructConstraint(this);
        }

        public Update(classOrStructKeyword: SyntaxToken): ClassOrStructConstraintSyntax {
            if (classOrStructKeyword != this.ClassOrStructKeyword) {
                var newNode = SyntaxFactory.ClassOrStructConstraint(this.Kind, classOrStructKeyword);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ClassOrStructConstraintSyntax().ctor_1261(this.Kind, this.classOrStructKeyword, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ClassOrStructConstraintSyntax().ctor_1261(this.Kind, this.classOrStructKeyword, this.GetDiagnostics(), annotations);
        }

        public ctor_2023(reader: Roslyn.Utilities.ObjectReader): ClassOrStructConstraintSyntax {
            super.ctor_2140(reader);
            this.SlotCount = 1;
            var classOrStructKeyword = <SyntaxToken>reader.ReadValue();
            if (classOrStructKeyword != null) {
                this.AdjustFlagsAndWidth(classOrStructKeyword);
                this.classOrStructKeyword = classOrStructKeyword;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.classOrStructKeyword);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ClassOrStructConstraintSyntax().ctor_2023(r);
        }
    }

    export class TypeConstraintSyntax extends TypeParameterConstraintSyntax {
        type: TypeSyntax;

        constructor() { super(); }
        ctor_1014(kind: SyntaxKind, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeConstraintSyntax {
            super.ctor_5924(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }


        ctor_1460(kind: SyntaxKind, type: TypeSyntax, context: SyntaxFactoryContext): TypeConstraintSyntax {
            super.ctor_1641(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }


        ctor_9926(kind: SyntaxKind, type: TypeSyntax): TypeConstraintSyntax {
            super.ctor_1641(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }

        public get Type(): TypeSyntax { return this.type; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.type;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.TypeConstraintSyntax().ctor_2135(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitTypeConstraint(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitTypeConstraint(this);
        }

        public Update(type: TypeSyntax): TypeConstraintSyntax {
            if (type != this.Type) {
                var newNode = SyntaxFactory.TypeConstraint(type);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new TypeConstraintSyntax().ctor_1014(this.Kind, this.type, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new TypeConstraintSyntax().ctor_1014(this.Kind, this.type, this.GetDiagnostics(), annotations);
        }

        public ctor_6116(reader: Roslyn.Utilities.ObjectReader): TypeConstraintSyntax {
            super.ctor_2140(reader);
            this.SlotCount = 1;
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.type);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new TypeConstraintSyntax().ctor_6116(r);
        }
    }

    export class BaseFieldDeclarationSyntax extends MemberDeclarationSyntax {
        constructor() { super(); }
        ctor_1443(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseFieldDeclarationSyntax {
            super.ctor_1870(kind, diagnostics, annotations);
            return this;
        }
        ctor_1119(kind: SyntaxKind): BaseFieldDeclarationSyntax {
            super.ctor_9655(kind);
            return this;
        }

        ctor_7157(reader: Roslyn.Utilities.ObjectReader): BaseFieldDeclarationSyntax {
            super.ctor_3031(reader);
            return this;
        }

        public AttributeLists: SyntaxList<AttributeListSyntax>;

        public Modifiers: SyntaxList<SyntaxToken>;

        public Declaration: VariableDeclarationSyntax;

        public SemicolonToken: SyntaxToken;
    }

    export class FieldDeclarationSyntax extends BaseFieldDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        declaration: VariableDeclarationSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_6145(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): FieldDeclarationSyntax {
            super.ctor_1443(kind, diagnostics, annotations);
            this.SlotCount = 4;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_6503(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): FieldDeclarationSyntax {
            super.ctor_1119(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1980(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): FieldDeclarationSyntax {
            super.ctor_1119(kind);
            this.SlotCount = 4;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Declaration(): VariableDeclarationSyntax { return this.declaration; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.declaration;
                case 3: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.FieldDeclarationSyntax().ctor_1589(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitFieldDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitFieldDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): FieldDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.FieldDeclaration(attributeLists, modifiers, declaration, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new FieldDeclarationSyntax().ctor_6145(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new FieldDeclarationSyntax().ctor_6145(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_8559(reader: Roslyn.Utilities.ObjectReader): FieldDeclarationSyntax {
            super.ctor_7157(reader);
            this.SlotCount = 4;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var declaration = <VariableDeclarationSyntax>reader.ReadValue();
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new FieldDeclarationSyntax().ctor_8559(r);
        }
    }

    export class EventFieldDeclarationSyntax extends BaseFieldDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        eventKeyword: SyntaxToken;
        declaration: VariableDeclarationSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1250(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EventFieldDeclarationSyntax {
            super.ctor_1443(kind, diagnostics, annotations);
            this.SlotCount = 5;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_1041(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): EventFieldDeclarationSyntax {
            super.ctor_1119(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }


        ctor_3359(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): EventFieldDeclarationSyntax {
            super.ctor_1119(kind);
            this.SlotCount = 5;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get EventKeyword(): SyntaxToken { return this.eventKeyword; }
        public get Declaration(): VariableDeclarationSyntax { return this.declaration; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.eventKeyword;
                case 3: return this.declaration;
                case 4: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.EventFieldDeclarationSyntax().ctor_1583(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitEventFieldDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitEventFieldDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, eventKeyword: SyntaxToken, declaration: VariableDeclarationSyntax, semicolonToken: SyntaxToken): EventFieldDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || declaration != this.Declaration || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.EventFieldDeclaration(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new EventFieldDeclarationSyntax().ctor_1250(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new EventFieldDeclarationSyntax().ctor_1250(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2799(reader: Roslyn.Utilities.ObjectReader): EventFieldDeclarationSyntax {
            super.ctor_7157(reader);
            this.SlotCount = 5;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var eventKeyword = <SyntaxToken>reader.ReadValue();
            if (eventKeyword != null) {
                this.AdjustFlagsAndWidth(eventKeyword);
                this.eventKeyword = eventKeyword;
                return this;
            }
            var declaration = <VariableDeclarationSyntax>reader.ReadValue();
            if (declaration != null) {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.eventKeyword);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new EventFieldDeclarationSyntax().ctor_2799(r);
        }
    }

    export class ExplicitInterfaceSpecifierSyntax extends CSharpSyntaxNode {
        name: NameSyntax;
        dotToken: SyntaxToken;

        constructor() { super(); }
        ctor_2893(kind: SyntaxKind, name: NameSyntax, dotToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ExplicitInterfaceSpecifierSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            return this;
        }


        ctor_1307(kind: SyntaxKind, name: NameSyntax, dotToken: SyntaxToken, context: SyntaxFactoryContext): ExplicitInterfaceSpecifierSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            return this;
        }


        ctor_1329(kind: SyntaxKind, name: NameSyntax, dotToken: SyntaxToken): ExplicitInterfaceSpecifierSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            return this;
        }

        public get Name(): NameSyntax { return this.name; }
        public get DotToken(): SyntaxToken { return this.dotToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.name;
                case 1: return this.dotToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ExplicitInterfaceSpecifierSyntax().ctor_1299(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitExplicitInterfaceSpecifier(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitExplicitInterfaceSpecifier(this);
        }

        public Update(name: NameSyntax, dotToken: SyntaxToken): ExplicitInterfaceSpecifierSyntax {
            if (name != this.Name || dotToken != this.DotToken) {
                var newNode = SyntaxFactory.ExplicitInterfaceSpecifier(name, dotToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ExplicitInterfaceSpecifierSyntax().ctor_2893(this.Kind, this.name, this.dotToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ExplicitInterfaceSpecifierSyntax().ctor_2893(this.Kind, this.name, this.dotToken, this.GetDiagnostics(), annotations);
        }

        public ctor_4143(reader: Roslyn.Utilities.ObjectReader): ExplicitInterfaceSpecifierSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var name = <NameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var dotToken = <SyntaxToken>reader.ReadValue();
            if (dotToken != null) {
                this.AdjustFlagsAndWidth(dotToken);
                this.dotToken = dotToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.dotToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ExplicitInterfaceSpecifierSyntax().ctor_4143(r);
        }
    }

    export class BaseMethodDeclarationSyntax extends MemberDeclarationSyntax {
        constructor() { super(); }
        ctor_1388(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseMethodDeclarationSyntax {
            super.ctor_1870(kind, diagnostics, annotations);
            return this;
        }
        ctor_1934(kind: SyntaxKind): BaseMethodDeclarationSyntax {
            super.ctor_9655(kind);
            return this;
        }

        ctor_5703(reader: Roslyn.Utilities.ObjectReader): BaseMethodDeclarationSyntax {
            super.ctor_3031(reader);
            return this;
        }

        public AttributeLists: SyntaxList<AttributeListSyntax>;

        public Modifiers: SyntaxList<SyntaxToken>;

        public ParameterList: ParameterListSyntax;

        public Body: BlockSyntax;

        public SemicolonToken: SyntaxToken;
    }

    export class MethodDeclarationSyntax extends BaseMethodDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        returnType: TypeSyntax;
        explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        identifier: SyntaxToken;
        typeParameterList: TypeParameterListSyntax;
        parameterList: ParameterListSyntax;
        constraintClauses: CSharpSyntaxNode;
        body: BlockSyntax;
        expressionBody: ArrowExpressionClauseSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_2048(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MethodDeclarationSyntax {
            super.ctor_1388(kind, diagnostics, annotations);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1209(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): MethodDeclarationSyntax {
            super.ctor_1934(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1010(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: CSharpSyntaxNode, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): MethodDeclarationSyntax {
            super.ctor_1934(kind);
            this.SlotCount = 11;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get ReturnType(): TypeSyntax { return this.returnType; }
        public get ExplicitInterfaceSpecifier(): ExplicitInterfaceSpecifierSyntax { return this.explicitInterfaceSpecifier; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get TypeParameterList(): TypeParameterListSyntax { return this.typeParameterList; }
        public get ParameterList(): ParameterListSyntax { return this.parameterList; }
        public get ConstraintClauses(): SyntaxList<TypeParameterConstraintClauseSyntax> { return new SyntaxList<TypeParameterConstraintClauseSyntax>().ctor_1319(this.constraintClauses); }
        public get Body(): BlockSyntax { return this.body; }
        public get ExpressionBody(): ArrowExpressionClauseSyntax { return this.expressionBody; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.returnType;
                case 3: return this.explicitInterfaceSpecifier;
                case 4: return this.identifier;
                case 5: return this.typeParameterList;
                case 6: return this.parameterList;
                case 7: return this.constraintClauses;
                case 8: return this.body;
                case 9: return this.expressionBody;
                case 10: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.MethodDeclarationSyntax().ctor_4143(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitMethodDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitMethodDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, returnType: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, constraintClauses: SyntaxList<TypeParameterConstraintClauseSyntax>, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): MethodDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.MethodDeclaration(attributeLists, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new MethodDeclarationSyntax().ctor_2048(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new MethodDeclarationSyntax().ctor_2048(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2033(reader: Roslyn.Utilities.ObjectReader): MethodDeclarationSyntax {
            super.ctor_5703(reader);
            this.SlotCount = 11;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var returnType = <TypeSyntax>reader.ReadValue();
            if (returnType != null) {
                this.AdjustFlagsAndWidth(returnType);
                this.returnType = returnType;
                return this;
            }
            var explicitInterfaceSpecifier = <ExplicitInterfaceSpecifierSyntax>reader.ReadValue();
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var typeParameterList = <TypeParameterListSyntax>reader.ReadValue();
            if (typeParameterList != null) {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
                return this;
            }
            var parameterList = <ParameterListSyntax>reader.ReadValue();
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
                return this;
            }
            var constraintClauses = <CSharpSyntaxNode>reader.ReadValue();
            if (constraintClauses != null) {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
                return this;
            }
            var body = <BlockSyntax>reader.ReadValue();
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
                return this;
            }
            var expressionBody = <ArrowExpressionClauseSyntax>reader.ReadValue();
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.returnType);
            writer.WriteValue(this.explicitInterfaceSpecifier);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new MethodDeclarationSyntax().ctor_2033(r);
        }
    }

    export class OperatorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        returnType: TypeSyntax;
        operatorKeyword: SyntaxToken;
        operatorToken: SyntaxToken;
        parameterList: ParameterListSyntax;
        body: BlockSyntax;
        expressionBody: ArrowExpressionClauseSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1250(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OperatorDeclarationSyntax {
            super.ctor_1388(kind, diagnostics, annotations);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1074(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): OperatorDeclarationSyntax {
            super.ctor_1934(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1579(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): OperatorDeclarationSyntax {
            super.ctor_1934(kind);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get ReturnType(): TypeSyntax { return this.returnType; }
        public get OperatorKeyword(): SyntaxToken { return this.operatorKeyword; }
        public get OperatorToken(): SyntaxToken { return this.operatorToken; }
        public get ParameterList(): ParameterListSyntax { return this.parameterList; }
        public get Body(): BlockSyntax { return this.body; }
        public get ExpressionBody(): ArrowExpressionClauseSyntax { return this.expressionBody; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.returnType;
                case 3: return this.operatorKeyword;
                case 4: return this.operatorToken;
                case 5: return this.parameterList;
                case 6: return this.body;
                case 7: return this.expressionBody;
                case 8: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.OperatorDeclarationSyntax().ctor_4027(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitOperatorDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitOperatorDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, returnType: TypeSyntax, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): OperatorDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.OperatorDeclaration(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new OperatorDeclarationSyntax().ctor_1250(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new OperatorDeclarationSyntax().ctor_1250(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1136(reader: Roslyn.Utilities.ObjectReader): OperatorDeclarationSyntax {
            super.ctor_5703(reader);
            this.SlotCount = 9;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var returnType = <TypeSyntax>reader.ReadValue();
            if (returnType != null) {
                this.AdjustFlagsAndWidth(returnType);
                this.returnType = returnType;
                return this;
            }
            var operatorKeyword = <SyntaxToken>reader.ReadValue();
            if (operatorKeyword != null) {
                this.AdjustFlagsAndWidth(operatorKeyword);
                this.operatorKeyword = operatorKeyword;
                return this;
            }
            var operatorToken = <SyntaxToken>reader.ReadValue();
            if (operatorToken != null) {
                this.AdjustFlagsAndWidth(operatorToken);
                this.operatorToken = operatorToken;
                return this;
            }
            var parameterList = <ParameterListSyntax>reader.ReadValue();
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
                return this;
            }
            var body = <BlockSyntax>reader.ReadValue();
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
                return this;
            }
            var expressionBody = <ArrowExpressionClauseSyntax>reader.ReadValue();
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.returnType);
            writer.WriteValue(this.operatorKeyword);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new OperatorDeclarationSyntax().ctor_1136(r);
        }
    }

    export class ConversionOperatorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        implicitOrExplicitKeyword: SyntaxToken;
        operatorKeyword: SyntaxToken;
        type: TypeSyntax;
        parameterList: ParameterListSyntax;
        body: BlockSyntax;
        expressionBody: ArrowExpressionClauseSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_3968(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConversionOperatorDeclarationSyntax {
            super.ctor_1388(kind, diagnostics, annotations);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1454(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ConversionOperatorDeclarationSyntax {
            super.ctor_1934(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_8245(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): ConversionOperatorDeclarationSyntax {
            super.ctor_1934(kind);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get ImplicitOrExplicitKeyword(): SyntaxToken { return this.implicitOrExplicitKeyword; }
        public get OperatorKeyword(): SyntaxToken { return this.operatorKeyword; }
        public get Type(): TypeSyntax { return this.type; }
        public get ParameterList(): ParameterListSyntax { return this.parameterList; }
        public get Body(): BlockSyntax { return this.body; }
        public get ExpressionBody(): ArrowExpressionClauseSyntax { return this.expressionBody; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.implicitOrExplicitKeyword;
                case 3: return this.operatorKeyword;
                case 4: return this.type;
                case 5: return this.parameterList;
                case 6: return this.body;
                case 7: return this.expressionBody;
                case 8: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ConversionOperatorDeclarationSyntax().ctor_4050(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitConversionOperatorDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitConversionOperatorDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameterList: ParameterListSyntax, body: BlockSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolonToken: SyntaxToken): ConversionOperatorDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.ConversionOperatorDeclaration(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ConversionOperatorDeclarationSyntax().ctor_3968(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ConversionOperatorDeclarationSyntax().ctor_3968(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1363(reader: Roslyn.Utilities.ObjectReader): ConversionOperatorDeclarationSyntax {
            super.ctor_5703(reader);
            this.SlotCount = 9;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var implicitOrExplicitKeyword = <SyntaxToken>reader.ReadValue();
            if (implicitOrExplicitKeyword != null) {
                this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
                this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
                return this;
            }
            var operatorKeyword = <SyntaxToken>reader.ReadValue();
            if (operatorKeyword != null) {
                this.AdjustFlagsAndWidth(operatorKeyword);
                this.operatorKeyword = operatorKeyword;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var parameterList = <ParameterListSyntax>reader.ReadValue();
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
                return this;
            }
            var body = <BlockSyntax>reader.ReadValue();
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
                return this;
            }
            var expressionBody = <ArrowExpressionClauseSyntax>reader.ReadValue();
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.implicitOrExplicitKeyword);
            writer.WriteValue(this.operatorKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ConversionOperatorDeclarationSyntax().ctor_1363(r);
        }
    }

    export class ConstructorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        identifier: SyntaxToken;
        parameterList: ParameterListSyntax;
        initializer: ConstructorInitializerSyntax;
        body: BlockSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1590(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConstructorDeclarationSyntax {
            super.ctor_1388(kind, diagnostics, annotations);
            this.SlotCount = 7;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1430(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): ConstructorDeclarationSyntax {
            super.ctor_1934(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 7;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1123(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): ConstructorDeclarationSyntax {
            super.ctor_1934(kind);
            this.SlotCount = 7;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get ParameterList(): ParameterListSyntax { return this.parameterList; }
        public get Initializer(): ConstructorInitializerSyntax { return this.initializer; }
        public get Body(): BlockSyntax { return this.body; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.identifier;
                case 3: return this.parameterList;
                case 4: return this.initializer;
                case 5: return this.body;
                case 6: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ConstructorDeclarationSyntax().ctor_1279(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitConstructorDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitConstructorDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, identifier: SyntaxToken, parameterList: ParameterListSyntax, initializer: ConstructorInitializerSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): ConstructorDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || identifier != this.Identifier || parameterList != this.ParameterList || initializer != this.Initializer || body != this.Body || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.ConstructorDeclaration(attributeLists, modifiers, identifier, parameterList, initializer, body, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ConstructorDeclarationSyntax().ctor_1590(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ConstructorDeclarationSyntax().ctor_1590(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1438(reader: Roslyn.Utilities.ObjectReader): ConstructorDeclarationSyntax {
            super.ctor_5703(reader);
            this.SlotCount = 7;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var parameterList = <ParameterListSyntax>reader.ReadValue();
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
                return this;
            }
            var initializer = <ConstructorInitializerSyntax>reader.ReadValue();
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
                return this;
            }
            var body = <BlockSyntax>reader.ReadValue();
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.initializer);
            writer.WriteValue(this.body);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ConstructorDeclarationSyntax().ctor_1438(r);
        }
    }

    export class ConstructorInitializerSyntax extends CSharpSyntaxNode {
        colonToken: SyntaxToken;
        thisOrBaseKeyword: SyntaxToken;
        argumentList: ArgumentListSyntax;

        constructor() { super(); }
        ctor_1065(kind: SyntaxKind, colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConstructorInitializerSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(thisOrBaseKeyword);
            this.thisOrBaseKeyword = thisOrBaseKeyword;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }


        ctor_9502(kind: SyntaxKind, colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax, context: SyntaxFactoryContext): ConstructorInitializerSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(thisOrBaseKeyword);
            this.thisOrBaseKeyword = thisOrBaseKeyword;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }


        ctor_6726(kind: SyntaxKind, colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax): ConstructorInitializerSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(thisOrBaseKeyword);
            this.thisOrBaseKeyword = thisOrBaseKeyword;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            return this;
        }

        public get ColonToken(): SyntaxToken { return this.colonToken; }
        public get ThisOrBaseKeyword(): SyntaxToken { return this.thisOrBaseKeyword; }
        public get ArgumentList(): ArgumentListSyntax { return this.argumentList; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.colonToken;
                case 1: return this.thisOrBaseKeyword;
                case 2: return this.argumentList;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ConstructorInitializerSyntax().ctor_7521(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitConstructorInitializer(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitConstructorInitializer(this);
        }

        public Update(colonToken: SyntaxToken, thisOrBaseKeyword: SyntaxToken, argumentList: ArgumentListSyntax): ConstructorInitializerSyntax {
            if (colonToken != this.ColonToken || thisOrBaseKeyword != this.ThisOrBaseKeyword || argumentList != this.ArgumentList) {
                var newNode = SyntaxFactory.ConstructorInitializer(this.Kind, colonToken, thisOrBaseKeyword, argumentList);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ConstructorInitializerSyntax().ctor_1065(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ConstructorInitializerSyntax().ctor_1065(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, this.GetDiagnostics(), annotations);
        }

        public ctor_2076(reader: Roslyn.Utilities.ObjectReader): ConstructorInitializerSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var colonToken = <SyntaxToken>reader.ReadValue();
            if (colonToken != null) {
                this.AdjustFlagsAndWidth(colonToken);
                this.colonToken = colonToken;
                return this;
            }
            var thisOrBaseKeyword = <SyntaxToken>reader.ReadValue();
            if (thisOrBaseKeyword != null) {
                this.AdjustFlagsAndWidth(thisOrBaseKeyword);
                this.thisOrBaseKeyword = thisOrBaseKeyword;
                return this;
            }
            var argumentList = <ArgumentListSyntax>reader.ReadValue();
            if (argumentList != null) {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.thisOrBaseKeyword);
            writer.WriteValue(this.argumentList);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ConstructorInitializerSyntax().ctor_2076(r);
        }
    }

    export class DestructorDeclarationSyntax extends BaseMethodDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        tildeToken: SyntaxToken;
        identifier: SyntaxToken;
        parameterList: ParameterListSyntax;
        body: BlockSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_4916(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DestructorDeclarationSyntax {
            super.ctor_1388(kind, diagnostics, annotations);
            this.SlotCount = 7;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(tildeToken);
            this.tildeToken = tildeToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1525(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): DestructorDeclarationSyntax {
            super.ctor_1934(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 7;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(tildeToken);
            this.tildeToken = tildeToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1562(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): DestructorDeclarationSyntax {
            super.ctor_1934(kind);
            this.SlotCount = 7;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(tildeToken);
            this.tildeToken = tildeToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get TildeToken(): SyntaxToken { return this.tildeToken; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get ParameterList(): ParameterListSyntax { return this.parameterList; }
        public get Body(): BlockSyntax { return this.body; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.tildeToken;
                case 3: return this.identifier;
                case 4: return this.parameterList;
                case 5: return this.body;
                case 6: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.DestructorDeclarationSyntax().ctor_1597(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitDestructorDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitDestructorDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, tildeToken: SyntaxToken, identifier: SyntaxToken, parameterList: ParameterListSyntax, body: BlockSyntax, semicolonToken: SyntaxToken): DestructorDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || tildeToken != this.TildeToken || identifier != this.Identifier || parameterList != this.ParameterList || body != this.Body || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.DestructorDeclaration(attributeLists, modifiers, tildeToken, identifier, parameterList, body, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new DestructorDeclarationSyntax().ctor_4916(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new DestructorDeclarationSyntax().ctor_4916(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1564(reader: Roslyn.Utilities.ObjectReader): DestructorDeclarationSyntax {
            super.ctor_5703(reader);
            this.SlotCount = 7;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var tildeToken = <SyntaxToken>reader.ReadValue();
            if (tildeToken != null) {
                this.AdjustFlagsAndWidth(tildeToken);
                this.tildeToken = tildeToken;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var parameterList = <ParameterListSyntax>reader.ReadValue();
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
                return this;
            }
            var body = <BlockSyntax>reader.ReadValue();
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.tildeToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.body);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new DestructorDeclarationSyntax().ctor_1564(r);
        }
    }

    export class BasePropertyDeclarationSyntax extends MemberDeclarationSyntax {
        constructor() { super(); }
        ctor_1425(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BasePropertyDeclarationSyntax {
            super.ctor_1870(kind, diagnostics, annotations);
            return this;
        }
        ctor_1862(kind: SyntaxKind): BasePropertyDeclarationSyntax {
            super.ctor_9655(kind);
            return this;
        }

        ctor_1386(reader: Roslyn.Utilities.ObjectReader): BasePropertyDeclarationSyntax {
            super.ctor_3031(reader);
            return this;
        }

        public AttributeLists: SyntaxList<AttributeListSyntax>;

        public Modifiers: SyntaxList<SyntaxToken>;

        public Type: TypeSyntax;

        public ExplicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;

        public AccessorList: AccessorListSyntax;
    }

    export class PropertyDeclarationSyntax extends BasePropertyDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        type: TypeSyntax;
        explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        identifier: SyntaxToken;
        accessorList: AccessorListSyntax;
        expressionBody: ArrowExpressionClauseSyntax;
        initializer: EqualsValueClauseSyntax;
        semicolon: SyntaxToken;

        constructor() { super(); }
        ctor_1737(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PropertyDeclarationSyntax {
            super.ctor_1425(kind, diagnostics, annotations);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (accessorList != null) {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (semicolon != null) {
                this.AdjustFlagsAndWidth(semicolon);
                this.semicolon = semicolon;
            }
            return this;
        }


        ctor_3039(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken, context: SyntaxFactoryContext): PropertyDeclarationSyntax {
            super.ctor_1862(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (accessorList != null) {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (semicolon != null) {
                this.AdjustFlagsAndWidth(semicolon);
                this.semicolon = semicolon;
            }
            return this;
        }


        ctor_4136(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken): PropertyDeclarationSyntax {
            super.ctor_1862(kind);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (accessorList != null) {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (semicolon != null) {
                this.AdjustFlagsAndWidth(semicolon);
                this.semicolon = semicolon;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Type(): TypeSyntax { return this.type; }
        public get ExplicitInterfaceSpecifier(): ExplicitInterfaceSpecifierSyntax { return this.explicitInterfaceSpecifier; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get AccessorList(): AccessorListSyntax { return this.accessorList; }
        public get ExpressionBody(): ArrowExpressionClauseSyntax { return this.expressionBody; }
        public get Initializer(): EqualsValueClauseSyntax { return this.initializer; }
        public get Semicolon(): SyntaxToken { return this.semicolon; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.type;
                case 3: return this.explicitInterfaceSpecifier;
                case 4: return this.identifier;
                case 5: return this.accessorList;
                case 6: return this.expressionBody;
                case 7: return this.initializer;
                case 8: return this.semicolon;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.PropertyDeclarationSyntax().ctor_1532(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitPropertyDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitPropertyDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, initializer: EqualsValueClauseSyntax, semicolon: SyntaxToken): PropertyDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || initializer != this.Initializer || semicolon != this.Semicolon) {
                var newNode = SyntaxFactory.PropertyDeclaration(attributeLists, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolon);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new PropertyDeclarationSyntax().ctor_1737(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolon, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new PropertyDeclarationSyntax().ctor_1737(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolon, this.GetDiagnostics(), annotations);
        }

        public ctor_1681(reader: Roslyn.Utilities.ObjectReader): PropertyDeclarationSyntax {
            super.ctor_1386(reader);
            this.SlotCount = 9;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var explicitInterfaceSpecifier = <ExplicitInterfaceSpecifierSyntax>reader.ReadValue();
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var accessorList = <AccessorListSyntax>reader.ReadValue();
            if (accessorList != null) {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
                return this;
            }
            var expressionBody = <ArrowExpressionClauseSyntax>reader.ReadValue();
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
                return this;
            }
            var initializer = <EqualsValueClauseSyntax>reader.ReadValue();
            if (initializer != null) {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
                return this;
            }
            var semicolon = <SyntaxToken>reader.ReadValue();
            if (semicolon != null) {
                this.AdjustFlagsAndWidth(semicolon);
                this.semicolon = semicolon;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
            writer.WriteValue(this.explicitInterfaceSpecifier);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.accessorList);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.initializer);
            writer.WriteValue(this.semicolon);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new PropertyDeclarationSyntax().ctor_1681(r);
        }
    }

    export class ArrowExpressionClauseSyntax extends CSharpSyntaxNode {
        arrowToken: SyntaxToken;
        expression: ExpressionSyntax;

        constructor() { super(); }
        ctor_2030(kind: SyntaxKind, arrowToken: SyntaxToken, expression: ExpressionSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ArrowExpressionClauseSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_5341(kind: SyntaxKind, arrowToken: SyntaxToken, expression: ExpressionSyntax, context: SyntaxFactoryContext): ArrowExpressionClauseSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }


        ctor_1881(kind: SyntaxKind, arrowToken: SyntaxToken, expression: ExpressionSyntax): ArrowExpressionClauseSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            return this;
        }

        public get ArrowToken(): SyntaxToken { return this.arrowToken; }
        public get Expression(): ExpressionSyntax { return this.expression; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.arrowToken;
                case 1: return this.expression;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ArrowExpressionClauseSyntax().ctor_1013(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitArrowExpressionClause(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitArrowExpressionClause(this);
        }

        public Update(arrowToken: SyntaxToken, expression: ExpressionSyntax): ArrowExpressionClauseSyntax {
            if (arrowToken != this.ArrowToken || expression != this.Expression) {
                var newNode = SyntaxFactory.ArrowExpressionClause(arrowToken, expression);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ArrowExpressionClauseSyntax().ctor_2030(this.Kind, this.arrowToken, this.expression, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ArrowExpressionClauseSyntax().ctor_2030(this.Kind, this.arrowToken, this.expression, this.GetDiagnostics(), annotations);
        }

        public ctor_8575(reader: Roslyn.Utilities.ObjectReader): ArrowExpressionClauseSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var arrowToken = <SyntaxToken>reader.ReadValue();
            if (arrowToken != null) {
                this.AdjustFlagsAndWidth(arrowToken);
                this.arrowToken = arrowToken;
                return this;
            }
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.arrowToken);
            writer.WriteValue(this.expression);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ArrowExpressionClauseSyntax().ctor_8575(r);
        }
    }

    export class EventDeclarationSyntax extends BasePropertyDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        eventKeyword: SyntaxToken;
        type: TypeSyntax;
        explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        identifier: SyntaxToken;
        accessorList: AccessorListSyntax;

        constructor() { super(); }
        ctor_2047(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EventDeclarationSyntax {
            super.ctor_1425(kind, diagnostics, annotations);
            this.SlotCount = 7;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
            return this;
        }


        ctor_1179(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax, context: SyntaxFactoryContext): EventDeclarationSyntax {
            super.ctor_1862(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 7;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
            return this;
        }


        ctor_6350(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax): EventDeclarationSyntax {
            super.ctor_1862(kind);
            this.SlotCount = 7;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get EventKeyword(): SyntaxToken { return this.eventKeyword; }
        public get Type(): TypeSyntax { return this.type; }
        public get ExplicitInterfaceSpecifier(): ExplicitInterfaceSpecifierSyntax { return this.explicitInterfaceSpecifier; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get AccessorList(): AccessorListSyntax { return this.accessorList; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.eventKeyword;
                case 3: return this.type;
                case 4: return this.explicitInterfaceSpecifier;
                case 5: return this.identifier;
                case 6: return this.accessorList;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.EventDeclarationSyntax().ctor_1337(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitEventDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitEventDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, eventKeyword: SyntaxToken, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, identifier: SyntaxToken, accessorList: AccessorListSyntax): EventDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList) {
                var newNode = SyntaxFactory.EventDeclaration(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new EventDeclarationSyntax().ctor_2047(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new EventDeclarationSyntax().ctor_2047(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.GetDiagnostics(), annotations);
        }

        public ctor_1343(reader: Roslyn.Utilities.ObjectReader): EventDeclarationSyntax {
            super.ctor_1386(reader);
            this.SlotCount = 7;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var eventKeyword = <SyntaxToken>reader.ReadValue();
            if (eventKeyword != null) {
                this.AdjustFlagsAndWidth(eventKeyword);
                this.eventKeyword = eventKeyword;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var explicitInterfaceSpecifier = <ExplicitInterfaceSpecifierSyntax>reader.ReadValue();
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var accessorList = <AccessorListSyntax>reader.ReadValue();
            if (accessorList != null) {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.eventKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.explicitInterfaceSpecifier);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.accessorList);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new EventDeclarationSyntax().ctor_1343(r);
        }
    }

    export class IndexerDeclarationSyntax extends BasePropertyDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        type: TypeSyntax;
        explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax;
        thisKeyword: SyntaxToken;
        parameterList: BracketedParameterListSyntax;
        accessorList: AccessorListSyntax;
        expressionBody: ArrowExpressionClauseSyntax;
        semicolon: SyntaxToken;

        constructor() { super(); }
        ctor_1724(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IndexerDeclarationSyntax {
            super.ctor_1425(kind, diagnostics, annotations);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (accessorList != null) {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolon != null) {
                this.AdjustFlagsAndWidth(semicolon);
                this.semicolon = semicolon;
            }
            return this;
        }


        ctor_1341(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken, context: SyntaxFactoryContext): IndexerDeclarationSyntax {
            super.ctor_1862(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (accessorList != null) {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolon != null) {
                this.AdjustFlagsAndWidth(semicolon);
                this.semicolon = semicolon;
            }
            return this;
        }


        ctor_1913(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken): IndexerDeclarationSyntax {
            super.ctor_1862(kind);
            this.SlotCount = 9;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (accessorList != null) {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolon != null) {
                this.AdjustFlagsAndWidth(semicolon);
                this.semicolon = semicolon;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Type(): TypeSyntax { return this.type; }
        public get ExplicitInterfaceSpecifier(): ExplicitInterfaceSpecifierSyntax { return this.explicitInterfaceSpecifier; }
        public get ThisKeyword(): SyntaxToken { return this.thisKeyword; }
        public get ParameterList(): BracketedParameterListSyntax { return this.parameterList; }
        public get AccessorList(): AccessorListSyntax { return this.accessorList; }
        public get ExpressionBody(): ArrowExpressionClauseSyntax { return this.expressionBody; }
        public get Semicolon(): SyntaxToken { return this.semicolon; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.type;
                case 3: return this.explicitInterfaceSpecifier;
                case 4: return this.thisKeyword;
                case 5: return this.parameterList;
                case 6: return this.accessorList;
                case 7: return this.expressionBody;
                case 8: return this.semicolon;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.IndexerDeclarationSyntax().ctor_3620(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitIndexerDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitIndexerDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, explicitInterfaceSpecifier: ExplicitInterfaceSpecifierSyntax, thisKeyword: SyntaxToken, parameterList: BracketedParameterListSyntax, accessorList: AccessorListSyntax, expressionBody: ArrowExpressionClauseSyntax, semicolon: SyntaxToken): IndexerDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || thisKeyword != this.ThisKeyword || parameterList != this.ParameterList || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || semicolon != this.Semicolon) {
                var newNode = SyntaxFactory.IndexerDeclaration(attributeLists, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolon);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new IndexerDeclarationSyntax().ctor_1724(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolon, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new IndexerDeclarationSyntax().ctor_1724(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolon, this.GetDiagnostics(), annotations);
        }

        public ctor_6123(reader: Roslyn.Utilities.ObjectReader): IndexerDeclarationSyntax {
            super.ctor_1386(reader);
            this.SlotCount = 9;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var explicitInterfaceSpecifier = <ExplicitInterfaceSpecifierSyntax>reader.ReadValue();
            if (explicitInterfaceSpecifier != null) {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
                return this;
            }
            var thisKeyword = <SyntaxToken>reader.ReadValue();
            if (thisKeyword != null) {
                this.AdjustFlagsAndWidth(thisKeyword);
                this.thisKeyword = thisKeyword;
                return this;
            }
            var parameterList = <BracketedParameterListSyntax>reader.ReadValue();
            if (parameterList != null) {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
                return this;
            }
            var accessorList = <AccessorListSyntax>reader.ReadValue();
            if (accessorList != null) {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
                return this;
            }
            var expressionBody = <ArrowExpressionClauseSyntax>reader.ReadValue();
            if (expressionBody != null) {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
                return this;
            }
            var semicolon = <SyntaxToken>reader.ReadValue();
            if (semicolon != null) {
                this.AdjustFlagsAndWidth(semicolon);
                this.semicolon = semicolon;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
            writer.WriteValue(this.explicitInterfaceSpecifier);
            writer.WriteValue(this.thisKeyword);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.accessorList);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolon);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new IndexerDeclarationSyntax().ctor_6123(r);
        }
    }

    export class AccessorListSyntax extends CSharpSyntaxNode {
        openBraceToken: SyntaxToken;
        accessors: CSharpSyntaxNode;
        closeBraceToken: SyntaxToken;

        constructor() { super(); }
        ctor_1983(kind: SyntaxKind, openBraceToken: SyntaxToken, accessors: CSharpSyntaxNode, closeBraceToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AccessorListSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (accessors != null) {
                this.AdjustFlagsAndWidth(accessors);
                this.accessors = accessors;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }


        ctor_1005(kind: SyntaxKind, openBraceToken: SyntaxToken, accessors: CSharpSyntaxNode, closeBraceToken: SyntaxToken, context: SyntaxFactoryContext): AccessorListSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (accessors != null) {
                this.AdjustFlagsAndWidth(accessors);
                this.accessors = accessors;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }


        ctor_4446(kind: SyntaxKind, openBraceToken: SyntaxToken, accessors: CSharpSyntaxNode, closeBraceToken: SyntaxToken): AccessorListSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (accessors != null) {
                this.AdjustFlagsAndWidth(accessors);
                this.accessors = accessors;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            return this;
        }

        public get OpenBraceToken(): SyntaxToken { return this.openBraceToken; }
        public get Accessors(): SyntaxList<AccessorDeclarationSyntax> { return new SyntaxList<AccessorDeclarationSyntax>().ctor_1319(this.accessors); }
        public get CloseBraceToken(): SyntaxToken { return this.closeBraceToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openBraceToken;
                case 1: return this.accessors;
                case 2: return this.closeBraceToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AccessorListSyntax().ctor_1609(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAccessorList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAccessorList(this);
        }

        public Update(openBraceToken: SyntaxToken, accessors: SyntaxList<AccessorDeclarationSyntax>, closeBraceToken: SyntaxToken): AccessorListSyntax {
            if (openBraceToken != this.OpenBraceToken || accessors != this.Accessors || closeBraceToken != this.CloseBraceToken) {
                var newNode = SyntaxFactory.AccessorList(openBraceToken, accessors, closeBraceToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AccessorListSyntax().ctor_1983(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AccessorListSyntax().ctor_1983(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1508(reader: Roslyn.Utilities.ObjectReader): AccessorListSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var openBraceToken = <SyntaxToken>reader.ReadValue();
            if (openBraceToken != null) {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
                return this;
            }
            var accessors = <CSharpSyntaxNode>reader.ReadValue();
            if (accessors != null) {
                this.AdjustFlagsAndWidth(accessors);
                this.accessors = accessors;
                return this;
            }
            var closeBraceToken = <SyntaxToken>reader.ReadValue();
            if (closeBraceToken != null) {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.accessors);
            writer.WriteValue(this.closeBraceToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AccessorListSyntax().ctor_1508(r);
        }
    }

    export class AccessorDeclarationSyntax extends CSharpSyntaxNode {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        keyword: SyntaxToken;
        body: BlockSyntax;
        semicolonToken: SyntaxToken;

        constructor() { super(); }
        ctor_3526(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): AccessorDeclarationSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 5;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_5617(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken, context: SyntaxFactoryContext): AccessorDeclarationSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }


        ctor_1898(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken): AccessorDeclarationSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 5;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Keyword(): SyntaxToken { return this.keyword; }
        public get Body(): BlockSyntax { return this.body; }
        public get SemicolonToken(): SyntaxToken { return this.semicolonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.keyword;
                case 3: return this.body;
                case 4: return this.semicolonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.AccessorDeclarationSyntax().ctor_1760(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitAccessorDeclaration(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitAccessorDeclaration(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, keyword: SyntaxToken, body: BlockSyntax, semicolonToken: SyntaxToken): AccessorDeclarationSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || body != this.Body || semicolonToken != this.SemicolonToken) {
                var newNode = SyntaxFactory.AccessorDeclaration(this.Kind, attributeLists, modifiers, keyword, body, semicolonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new AccessorDeclarationSyntax().ctor_3526(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.semicolonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new AccessorDeclarationSyntax().ctor_3526(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.semicolonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2034(reader: Roslyn.Utilities.ObjectReader): AccessorDeclarationSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 5;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var keyword = <SyntaxToken>reader.ReadValue();
            if (keyword != null) {
                this.AdjustFlagsAndWidth(keyword);
                this.keyword = keyword;
                return this;
            }
            var body = <BlockSyntax>reader.ReadValue();
            if (body != null) {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
                return this;
            }
            var semicolonToken = <SyntaxToken>reader.ReadValue();
            if (semicolonToken != null) {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.body);
            writer.WriteValue(this.semicolonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new AccessorDeclarationSyntax().ctor_2034(r);
        }
    }

    export class BaseParameterListSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_1312(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseParameterListSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_1762(kind: SyntaxKind): BaseParameterListSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_1023(reader: Roslyn.Utilities.ObjectReader): BaseParameterListSyntax {
            super.ctor_4942(reader);
            return this;
        }

        public Parameters: SeparatedSyntaxList<ParameterSyntax>;
    }

    export class ParameterListSyntax extends BaseParameterListSyntax {
        openParenToken: SyntaxToken;
        parameters: CSharpSyntaxNode;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_1688(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ParameterListSyntax {
            super.ctor_1312(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_1342(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): ParameterListSyntax {
            super.ctor_1762(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_2073(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken): ParameterListSyntax {
            super.ctor_1762(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Parameters(): SeparatedSyntaxList<ParameterSyntax> { return new SeparatedSyntaxList<ParameterSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.parameters)); }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openParenToken;
                case 1: return this.parameters;
                case 2: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ParameterListSyntax().ctor_1013(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitParameterList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitParameterList(this);
        }

        public Update(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<ParameterSyntax>, closeParenToken: SyntaxToken): ParameterListSyntax {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ParameterListSyntax().ctor_1688(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ParameterListSyntax().ctor_1688(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_8017(reader: Roslyn.Utilities.ObjectReader): ParameterListSyntax {
            super.ctor_1023(reader);
            this.SlotCount = 3;
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var parameters = <CSharpSyntaxNode>reader.ReadValue();
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ParameterListSyntax().ctor_8017(r);
        }
    }

    export class BracketedParameterListSyntax extends BaseParameterListSyntax {
        openBracketToken: SyntaxToken;
        parameters: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;

        constructor() { super(); }
        ctor_7255(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BracketedParameterListSyntax {
            super.ctor_1312(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }


        ctor_3203(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken, context: SyntaxFactoryContext): BracketedParameterListSyntax {
            super.ctor_1762(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }


        ctor_3556(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken): BracketedParameterListSyntax {
            super.ctor_1762(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }

        public get OpenBracketToken(): SyntaxToken { return this.openBracketToken; }
        public get Parameters(): SeparatedSyntaxList<ParameterSyntax> { return new SeparatedSyntaxList<ParameterSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.parameters)); }
        public get CloseBracketToken(): SyntaxToken { return this.closeBracketToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openBracketToken;
                case 1: return this.parameters;
                case 2: return this.closeBracketToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.BracketedParameterListSyntax().ctor_2140(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitBracketedParameterList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitBracketedParameterList(this);
        }

        public Update(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<ParameterSyntax>, closeBracketToken: SyntaxToken): BracketedParameterListSyntax {
            if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken) {
                var newNode = SyntaxFactory.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new BracketedParameterListSyntax().ctor_7255(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new BracketedParameterListSyntax().ctor_7255(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1079(reader: Roslyn.Utilities.ObjectReader): BracketedParameterListSyntax {
            super.ctor_1023(reader);
            this.SlotCount = 3;
            var openBracketToken = <SyntaxToken>reader.ReadValue();
            if (openBracketToken != null) {
                this.AdjustFlagsAndWidth(openBracketToken);
                this.openBracketToken = openBracketToken;
                return this;
            }
            var parameters = <CSharpSyntaxNode>reader.ReadValue();
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
                return this;
            }
            var closeBracketToken = <SyntaxToken>reader.ReadValue();
            if (closeBracketToken != null) {
                this.AdjustFlagsAndWidth(closeBracketToken);
                this.closeBracketToken = closeBracketToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeBracketToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new BracketedParameterListSyntax().ctor_1079(r);
        }
    }

    export class ParameterSyntax extends CSharpSyntaxNode {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        type: TypeSyntax;
        identifier: SyntaxToken;
        $default: EqualsValueClauseSyntax;

        constructor() { super(); }
        ctor_1019(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ParameterSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 5;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if ($default != null) {
                this.AdjustFlagsAndWidth($default);
                this.$default = $default;
            }
            return this;
        }


        ctor_1292(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax, context: SyntaxFactoryContext): ParameterSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if ($default != null) {
                this.AdjustFlagsAndWidth($default);
                this.$default = $default;
            }
            return this;
        }


        ctor_1229(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax): ParameterSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 5;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if ($default != null) {
                this.AdjustFlagsAndWidth($default);
                this.$default = $default;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Type(): TypeSyntax { return this.type; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get Default(): EqualsValueClauseSyntax { return this.$default; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.type;
                case 3: return this.identifier;
                case 4: return this.$default;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ParameterSyntax().ctor_1019(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitParameter(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitParameter(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax, identifier: SyntaxToken, $default: EqualsValueClauseSyntax): ParameterSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || $default != this.Default) {
                var newNode = SyntaxFactory.Parameter(attributeLists, modifiers, type, identifier, $default);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ParameterSyntax().ctor_1019(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.$default, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ParameterSyntax().ctor_1019(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.$default, this.GetDiagnostics(), annotations);
        }

        public ctor_7554(reader: Roslyn.Utilities.ObjectReader): ParameterSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 5;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var $default = <EqualsValueClauseSyntax>reader.ReadValue();
            if ($default != null) {
                this.AdjustFlagsAndWidth($default);
                this.$default = $default;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.$default);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ParameterSyntax().ctor_7554(r);
        }
    }

    export class IncompleteMemberSyntax extends MemberDeclarationSyntax {
        attributeLists: CSharpSyntaxNode;
        modifiers: CSharpSyntaxNode;
        type: TypeSyntax;

        constructor() { super(); }
        ctor_1408(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IncompleteMemberSyntax {
            super.ctor_1870(kind, diagnostics, annotations);
            this.SlotCount = 3;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            return this;
        }


        ctor_2249(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax, context: SyntaxFactoryContext): IncompleteMemberSyntax {
            super.ctor_9655(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            return this;
        }


        ctor_1869(kind: SyntaxKind, attributeLists: CSharpSyntaxNode, modifiers: CSharpSyntaxNode, type: TypeSyntax): IncompleteMemberSyntax {
            super.ctor_9655(kind);
            this.SlotCount = 3;
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            return this;
        }

        public get AttributeLists(): SyntaxList<AttributeListSyntax> { return new SyntaxList<AttributeListSyntax>().ctor_1319(this.attributeLists); }
        public get Modifiers(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.modifiers); }
        public get Type(): TypeSyntax { return this.type; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.attributeLists;
                case 1: return this.modifiers;
                case 2: return this.type;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.IncompleteMemberSyntax().ctor_1857(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitIncompleteMember(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitIncompleteMember(this);
        }

        public Update(attributeLists: SyntaxList<AttributeListSyntax>, modifiers: SyntaxList<SyntaxToken>, type: TypeSyntax): IncompleteMemberSyntax {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type) {
                var newNode = SyntaxFactory.IncompleteMember(attributeLists, modifiers, type);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new IncompleteMemberSyntax().ctor_1408(this.Kind, this.attributeLists, this.modifiers, this.type, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new IncompleteMemberSyntax().ctor_1408(this.Kind, this.attributeLists, this.modifiers, this.type, this.GetDiagnostics(), annotations);
        }

        public ctor_4559(reader: Roslyn.Utilities.ObjectReader): IncompleteMemberSyntax {
            super.ctor_3031(reader);
            this.SlotCount = 3;
            var attributeLists = <CSharpSyntaxNode>reader.ReadValue();
            if (attributeLists != null) {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
                return this;
            }
            var modifiers = <CSharpSyntaxNode>reader.ReadValue();
            if (modifiers != null) {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new IncompleteMemberSyntax().ctor_4559(r);
        }
    }

    export class SkippedTokensTriviaSyntax extends StructuredTriviaSyntax {
        tokens: CSharpSyntaxNode;

        constructor() { super(); }
        ctor_1606(kind: SyntaxKind, tokens: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): SkippedTokensTriviaSyntax {
            super.ctor_1999(kind, diagnostics, annotations);
            this.SlotCount = 1;
            if (tokens != null) {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
            return this;
        }


        ctor_2298(kind: SyntaxKind, tokens: CSharpSyntaxNode, context: SyntaxFactoryContext): SkippedTokensTriviaSyntax {
            super.ctor_1999(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            if (tokens != null) {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
            return this;
        }


        ctor_1251(kind: SyntaxKind, tokens: CSharpSyntaxNode): SkippedTokensTriviaSyntax {
            super.ctor_1999(kind);
            this.SlotCount = 1;
            if (tokens != null) {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
            return this;
        }

        public get Tokens(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.tokens); }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.tokens;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.SkippedTokensTriviaSyntax().ctor_9665(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitSkippedTokensTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitSkippedTokensTrivia(this);
        }

        public Update(tokens: SyntaxList<SyntaxToken>): SkippedTokensTriviaSyntax {
            if (tokens != this.Tokens) {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new SkippedTokensTriviaSyntax().ctor_1606(this.Kind, this.tokens, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new SkippedTokensTriviaSyntax().ctor_1606(this.Kind, this.tokens, this.GetDiagnostics(), annotations);
        }

        public ctor_1788(reader: Roslyn.Utilities.ObjectReader): SkippedTokensTriviaSyntax {
            super.ctor_1484(reader);
            this.SlotCount = 1;
            var tokens = <CSharpSyntaxNode>reader.ReadValue();
            if (tokens != null) {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.tokens);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new SkippedTokensTriviaSyntax().ctor_1788(r);
        }
    }

    export class DocumentationCommentTriviaSyntax extends StructuredTriviaSyntax {
        content: CSharpSyntaxNode;
        endOfComment: SyntaxToken;

        constructor() { super(); }
        ctor_1873(kind: SyntaxKind, content: CSharpSyntaxNode, endOfComment: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DocumentationCommentTriviaSyntax {
            super.ctor_1999(kind, diagnostics, annotations);
            this.SlotCount = 2;
            if (content != null) {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
            return this;
        }


        ctor_1399(kind: SyntaxKind, content: CSharpSyntaxNode, endOfComment: SyntaxToken, context: SyntaxFactoryContext): DocumentationCommentTriviaSyntax {
            super.ctor_1999(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            if (content != null) {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
            return this;
        }


        ctor_5915(kind: SyntaxKind, content: CSharpSyntaxNode, endOfComment: SyntaxToken): DocumentationCommentTriviaSyntax {
            super.ctor_1999(kind);
            this.SlotCount = 2;
            if (content != null) {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
            return this;
        }

        public get Content(): SyntaxList<XmlNodeSyntax> { return new SyntaxList<XmlNodeSyntax>().ctor_1319(this.content); }
        public get EndOfComment(): SyntaxToken { return this.endOfComment; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.content;
                case 1: return this.endOfComment;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.DocumentationCommentTriviaSyntax().ctor_4695(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitDocumentationCommentTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitDocumentationCommentTrivia(this);
        }

        public Update(content: SyntaxList<XmlNodeSyntax>, endOfComment: SyntaxToken): DocumentationCommentTriviaSyntax {
            if (content != this.Content || endOfComment != this.EndOfComment) {
                var newNode = SyntaxFactory.DocumentationCommentTrivia(this.Kind, content, endOfComment);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new DocumentationCommentTriviaSyntax().ctor_1873(this.Kind, this.content, this.endOfComment, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new DocumentationCommentTriviaSyntax().ctor_1873(this.Kind, this.content, this.endOfComment, this.GetDiagnostics(), annotations);
        }

        public ctor_1096(reader: Roslyn.Utilities.ObjectReader): DocumentationCommentTriviaSyntax {
            super.ctor_1484(reader);
            this.SlotCount = 2;
            var content = <CSharpSyntaxNode>reader.ReadValue();
            if (content != null) {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
                return this;
            }
            var endOfComment = <SyntaxToken>reader.ReadValue();
            if (endOfComment != null) {
                this.AdjustFlagsAndWidth(endOfComment);
                this.endOfComment = endOfComment;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.content);
            writer.WriteValue(this.endOfComment);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new DocumentationCommentTriviaSyntax().ctor_1096(r);
        }
    }

    export class CrefSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_2895(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CrefSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_9523(kind: SyntaxKind): CrefSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_2879(reader: Roslyn.Utilities.ObjectReader): CrefSyntax {
            super.ctor_4942(reader);
            return this;
        }
    }

    export class TypeCrefSyntax extends CrefSyntax {
        type: TypeSyntax;

        constructor() { super(); }
        ctor_1515(kind: SyntaxKind, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): TypeCrefSyntax {
            super.ctor_2895(kind, diagnostics, annotations);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }


        ctor_1565(kind: SyntaxKind, type: TypeSyntax, context: SyntaxFactoryContext): TypeCrefSyntax {
            super.ctor_9523(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }


        ctor_8612(kind: SyntaxKind, type: TypeSyntax): TypeCrefSyntax {
            super.ctor_9523(kind);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }

        public get Type(): TypeSyntax { return this.type; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.type;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.TypeCrefSyntax().ctor_9808(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitTypeCref(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitTypeCref(this);
        }

        public Update(type: TypeSyntax): TypeCrefSyntax {
            if (type != this.Type) {
                var newNode = SyntaxFactory.TypeCref(type);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new TypeCrefSyntax().ctor_1515(this.Kind, this.type, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new TypeCrefSyntax().ctor_1515(this.Kind, this.type, this.GetDiagnostics(), annotations);
        }

        public ctor_8795(reader: Roslyn.Utilities.ObjectReader): TypeCrefSyntax {
            super.ctor_2879(reader);
            this.SlotCount = 1;
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.type);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new TypeCrefSyntax().ctor_8795(r);
        }
    }

    export class QualifiedCrefSyntax extends CrefSyntax {
        container: TypeSyntax;
        dotToken: SyntaxToken;
        member: MemberCrefSyntax;

        constructor() { super(); }
        ctor_1551(kind: SyntaxKind, container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): QualifiedCrefSyntax {
            super.ctor_2895(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(container);
            this.container = container;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(member);
            this.member = member;
            return this;
        }


        ctor_1897(kind: SyntaxKind, container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax, context: SyntaxFactoryContext): QualifiedCrefSyntax {
            super.ctor_9523(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(container);
            this.container = container;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(member);
            this.member = member;
            return this;
        }


        ctor_1939(kind: SyntaxKind, container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax): QualifiedCrefSyntax {
            super.ctor_9523(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(container);
            this.container = container;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(member);
            this.member = member;
            return this;
        }

        public get Container(): TypeSyntax { return this.container; }
        public get DotToken(): SyntaxToken { return this.dotToken; }
        public get Member(): MemberCrefSyntax { return this.member; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.container;
                case 1: return this.dotToken;
                case 2: return this.member;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.QualifiedCrefSyntax().ctor_9087(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitQualifiedCref(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitQualifiedCref(this);
        }

        public Update(container: TypeSyntax, dotToken: SyntaxToken, member: MemberCrefSyntax): QualifiedCrefSyntax {
            if (container != this.Container || dotToken != this.DotToken || member != this.Member) {
                var newNode = SyntaxFactory.QualifiedCref(container, dotToken, member);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new QualifiedCrefSyntax().ctor_1551(this.Kind, this.container, this.dotToken, this.member, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new QualifiedCrefSyntax().ctor_1551(this.Kind, this.container, this.dotToken, this.member, this.GetDiagnostics(), annotations);
        }

        public ctor_1025(reader: Roslyn.Utilities.ObjectReader): QualifiedCrefSyntax {
            super.ctor_2879(reader);
            this.SlotCount = 3;
            var container = <TypeSyntax>reader.ReadValue();
            if (container != null) {
                this.AdjustFlagsAndWidth(container);
                this.container = container;
                return this;
            }
            var dotToken = <SyntaxToken>reader.ReadValue();
            if (dotToken != null) {
                this.AdjustFlagsAndWidth(dotToken);
                this.dotToken = dotToken;
                return this;
            }
            var member = <MemberCrefSyntax>reader.ReadValue();
            if (member != null) {
                this.AdjustFlagsAndWidth(member);
                this.member = member;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.container);
            writer.WriteValue(this.dotToken);
            writer.WriteValue(this.member);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new QualifiedCrefSyntax().ctor_1025(r);
        }
    }

    export class MemberCrefSyntax extends CrefSyntax {
        constructor() { super(); }
        ctor_1053(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): MemberCrefSyntax {
            super.ctor_2895(kind, diagnostics, annotations);
            return this;
        }
        ctor_3739(kind: SyntaxKind): MemberCrefSyntax {
            super.ctor_9523(kind);
            return this;
        }

        ctor_1923(reader: Roslyn.Utilities.ObjectReader): MemberCrefSyntax {
            super.ctor_2879(reader);
            return this;
        }
    }

    export class NameMemberCrefSyntax extends MemberCrefSyntax {
        name: TypeSyntax;
        parameters: CrefParameterListSyntax;

        constructor() { super(); }
        ctor_8612(kind: SyntaxKind, name: TypeSyntax, parameters: CrefParameterListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): NameMemberCrefSyntax {
            super.ctor_1053(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }


        ctor_9433(kind: SyntaxKind, name: TypeSyntax, parameters: CrefParameterListSyntax, context: SyntaxFactoryContext): NameMemberCrefSyntax {
            super.ctor_3739(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }


        ctor_1436(kind: SyntaxKind, name: TypeSyntax, parameters: CrefParameterListSyntax): NameMemberCrefSyntax {
            super.ctor_3739(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }

        public get Name(): TypeSyntax { return this.name; }
        public get Parameters(): CrefParameterListSyntax { return this.parameters; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.name;
                case 1: return this.parameters;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.NameMemberCrefSyntax().ctor_6585(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitNameMemberCref(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitNameMemberCref(this);
        }

        public Update(name: TypeSyntax, parameters: CrefParameterListSyntax): NameMemberCrefSyntax {
            if (name != this.Name || parameters != this.Parameters) {
                var newNode = SyntaxFactory.NameMemberCref(name, parameters);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new NameMemberCrefSyntax().ctor_8612(this.Kind, this.name, this.parameters, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new NameMemberCrefSyntax().ctor_8612(this.Kind, this.name, this.parameters, this.GetDiagnostics(), annotations);
        }

        public ctor_4277(reader: Roslyn.Utilities.ObjectReader): NameMemberCrefSyntax {
            super.ctor_1923(reader);
            this.SlotCount = 2;
            var name = <TypeSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var parameters = <CrefParameterListSyntax>reader.ReadValue();
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.parameters);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new NameMemberCrefSyntax().ctor_4277(r);
        }
    }

    export class IndexerMemberCrefSyntax extends MemberCrefSyntax {
        thisKeyword: SyntaxToken;
        parameters: CrefBracketedParameterListSyntax;

        constructor() { super(); }
        ctor_8475(kind: SyntaxKind, thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IndexerMemberCrefSyntax {
            super.ctor_1053(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }


        ctor_4376(kind: SyntaxKind, thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax, context: SyntaxFactoryContext): IndexerMemberCrefSyntax {
            super.ctor_3739(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }


        ctor_2097(kind: SyntaxKind, thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax): IndexerMemberCrefSyntax {
            super.ctor_3739(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }

        public get ThisKeyword(): SyntaxToken { return this.thisKeyword; }
        public get Parameters(): CrefBracketedParameterListSyntax { return this.parameters; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.thisKeyword;
                case 1: return this.parameters;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.IndexerMemberCrefSyntax().ctor_1598(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitIndexerMemberCref(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitIndexerMemberCref(this);
        }

        public Update(thisKeyword: SyntaxToken, parameters: CrefBracketedParameterListSyntax): IndexerMemberCrefSyntax {
            if (thisKeyword != this.ThisKeyword || parameters != this.Parameters) {
                var newNode = SyntaxFactory.IndexerMemberCref(thisKeyword, parameters);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new IndexerMemberCrefSyntax().ctor_8475(this.Kind, this.thisKeyword, this.parameters, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new IndexerMemberCrefSyntax().ctor_8475(this.Kind, this.thisKeyword, this.parameters, this.GetDiagnostics(), annotations);
        }

        public ctor_1214(reader: Roslyn.Utilities.ObjectReader): IndexerMemberCrefSyntax {
            super.ctor_1923(reader);
            this.SlotCount = 2;
            var thisKeyword = <SyntaxToken>reader.ReadValue();
            if (thisKeyword != null) {
                this.AdjustFlagsAndWidth(thisKeyword);
                this.thisKeyword = thisKeyword;
                return this;
            }
            var parameters = <CrefBracketedParameterListSyntax>reader.ReadValue();
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.thisKeyword);
            writer.WriteValue(this.parameters);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new IndexerMemberCrefSyntax().ctor_1214(r);
        }
    }

    export class OperatorMemberCrefSyntax extends MemberCrefSyntax {
        operatorKeyword: SyntaxToken;
        operatorToken: SyntaxToken;
        parameters: CrefParameterListSyntax;

        constructor() { super(); }
        ctor_1212(kind: SyntaxKind, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): OperatorMemberCrefSyntax {
            super.ctor_1053(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }


        ctor_6188(kind: SyntaxKind, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax, context: SyntaxFactoryContext): OperatorMemberCrefSyntax {
            super.ctor_3739(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }


        ctor_1625(kind: SyntaxKind, operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax): OperatorMemberCrefSyntax {
            super.ctor_3739(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }

        public get OperatorKeyword(): SyntaxToken { return this.operatorKeyword; }
        public get OperatorToken(): SyntaxToken { return this.operatorToken; }
        public get Parameters(): CrefParameterListSyntax { return this.parameters; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.operatorKeyword;
                case 1: return this.operatorToken;
                case 2: return this.parameters;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.OperatorMemberCrefSyntax().ctor_1011(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitOperatorMemberCref(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitOperatorMemberCref(this);
        }

        public Update(operatorKeyword: SyntaxToken, operatorToken: SyntaxToken, parameters: CrefParameterListSyntax): OperatorMemberCrefSyntax {
            if (operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameters != this.Parameters) {
                var newNode = SyntaxFactory.OperatorMemberCref(operatorKeyword, operatorToken, parameters);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new OperatorMemberCrefSyntax().ctor_1212(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new OperatorMemberCrefSyntax().ctor_1212(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, this.GetDiagnostics(), annotations);
        }

        public ctor_1347(reader: Roslyn.Utilities.ObjectReader): OperatorMemberCrefSyntax {
            super.ctor_1923(reader);
            this.SlotCount = 3;
            var operatorKeyword = <SyntaxToken>reader.ReadValue();
            if (operatorKeyword != null) {
                this.AdjustFlagsAndWidth(operatorKeyword);
                this.operatorKeyword = operatorKeyword;
                return this;
            }
            var operatorToken = <SyntaxToken>reader.ReadValue();
            if (operatorToken != null) {
                this.AdjustFlagsAndWidth(operatorToken);
                this.operatorToken = operatorToken;
                return this;
            }
            var parameters = <CrefParameterListSyntax>reader.ReadValue();
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.operatorKeyword);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.parameters);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new OperatorMemberCrefSyntax().ctor_1347(r);
        }
    }

    export class ConversionOperatorMemberCrefSyntax extends MemberCrefSyntax {
        implicitOrExplicitKeyword: SyntaxToken;
        operatorKeyword: SyntaxToken;
        type: TypeSyntax;
        parameters: CrefParameterListSyntax;

        constructor() { super(); }
        ctor_7616(kind: SyntaxKind, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConversionOperatorMemberCrefSyntax {
            super.ctor_1053(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }


        ctor_7179(kind: SyntaxKind, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax, context: SyntaxFactoryContext): ConversionOperatorMemberCrefSyntax {
            super.ctor_3739(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }


        ctor_1291(kind: SyntaxKind, implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax): ConversionOperatorMemberCrefSyntax {
            super.ctor_3739(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            return this;
        }

        public get ImplicitOrExplicitKeyword(): SyntaxToken { return this.implicitOrExplicitKeyword; }
        public get OperatorKeyword(): SyntaxToken { return this.operatorKeyword; }
        public get Type(): TypeSyntax { return this.type; }
        public get Parameters(): CrefParameterListSyntax { return this.parameters; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.implicitOrExplicitKeyword;
                case 1: return this.operatorKeyword;
                case 2: return this.type;
                case 3: return this.parameters;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ConversionOperatorMemberCrefSyntax().ctor_1441(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitConversionOperatorMemberCref(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitConversionOperatorMemberCref(this);
        }

        public Update(implicitOrExplicitKeyword: SyntaxToken, operatorKeyword: SyntaxToken, type: TypeSyntax, parameters: CrefParameterListSyntax): ConversionOperatorMemberCrefSyntax {
            if (implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameters != this.Parameters) {
                var newNode = SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ConversionOperatorMemberCrefSyntax().ctor_7616(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ConversionOperatorMemberCrefSyntax().ctor_7616(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, this.GetDiagnostics(), annotations);
        }

        public ctor_9378(reader: Roslyn.Utilities.ObjectReader): ConversionOperatorMemberCrefSyntax {
            super.ctor_1923(reader);
            this.SlotCount = 4;
            var implicitOrExplicitKeyword = <SyntaxToken>reader.ReadValue();
            if (implicitOrExplicitKeyword != null) {
                this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
                this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
                return this;
            }
            var operatorKeyword = <SyntaxToken>reader.ReadValue();
            if (operatorKeyword != null) {
                this.AdjustFlagsAndWidth(operatorKeyword);
                this.operatorKeyword = operatorKeyword;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
            var parameters = <CrefParameterListSyntax>reader.ReadValue();
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.implicitOrExplicitKeyword);
            writer.WriteValue(this.operatorKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.parameters);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ConversionOperatorMemberCrefSyntax().ctor_9378(r);
        }
    }

    export class BaseCrefParameterListSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_6975(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BaseCrefParameterListSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_4040(kind: SyntaxKind): BaseCrefParameterListSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_1932(reader: Roslyn.Utilities.ObjectReader): BaseCrefParameterListSyntax {
            super.ctor_4942(reader);
            return this;
        }

        public Parameters: SeparatedSyntaxList<CrefParameterSyntax>;
    }

    export class CrefParameterListSyntax extends BaseCrefParameterListSyntax {
        openParenToken: SyntaxToken;
        parameters: CSharpSyntaxNode;
        closeParenToken: SyntaxToken;

        constructor() { super(); }
        ctor_1950(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CrefParameterListSyntax {
            super.ctor_6975(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_2311(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken, context: SyntaxFactoryContext): CrefParameterListSyntax {
            super.ctor_4040(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }


        ctor_4663(kind: SyntaxKind, openParenToken: SyntaxToken, parameters: CSharpSyntaxNode, closeParenToken: SyntaxToken): CrefParameterListSyntax {
            super.ctor_4040(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            return this;
        }

        public get OpenParenToken(): SyntaxToken { return this.openParenToken; }
        public get Parameters(): SeparatedSyntaxList<CrefParameterSyntax> { return new SeparatedSyntaxList<CrefParameterSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.parameters)); }
        public get CloseParenToken(): SyntaxToken { return this.closeParenToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openParenToken;
                case 1: return this.parameters;
                case 2: return this.closeParenToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CrefParameterListSyntax().ctor_1513(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCrefParameterList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCrefParameterList(this);
        }

        public Update(openParenToken: SyntaxToken, parameters: SeparatedSyntaxList<CrefParameterSyntax>, closeParenToken: SyntaxToken): CrefParameterListSyntax {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken) {
                var newNode = SyntaxFactory.CrefParameterList(openParenToken, parameters, closeParenToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CrefParameterListSyntax().ctor_1950(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CrefParameterListSyntax().ctor_1950(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, this.GetDiagnostics(), annotations);
        }

        public ctor_7526(reader: Roslyn.Utilities.ObjectReader): CrefParameterListSyntax {
            super.ctor_1932(reader);
            this.SlotCount = 3;
            var openParenToken = <SyntaxToken>reader.ReadValue();
            if (openParenToken != null) {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
                return this;
            }
            var parameters = <CSharpSyntaxNode>reader.ReadValue();
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
                return this;
            }
            var closeParenToken = <SyntaxToken>reader.ReadValue();
            if (closeParenToken != null) {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeParenToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CrefParameterListSyntax().ctor_7526(r);
        }
    }

    export class CrefBracketedParameterListSyntax extends BaseCrefParameterListSyntax {
        openBracketToken: SyntaxToken;
        parameters: CSharpSyntaxNode;
        closeBracketToken: SyntaxToken;

        constructor() { super(); }
        ctor_2822(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CrefBracketedParameterListSyntax {
            super.ctor_6975(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }


        ctor_3133(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken, context: SyntaxFactoryContext): CrefBracketedParameterListSyntax {
            super.ctor_4040(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }


        ctor_5561(kind: SyntaxKind, openBracketToken: SyntaxToken, parameters: CSharpSyntaxNode, closeBracketToken: SyntaxToken): CrefBracketedParameterListSyntax {
            super.ctor_4040(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            return this;
        }

        public get OpenBracketToken(): SyntaxToken { return this.openBracketToken; }
        public get Parameters(): SeparatedSyntaxList<CrefParameterSyntax> { return new SeparatedSyntaxList<CrefParameterSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.parameters)); }
        public get CloseBracketToken(): SyntaxToken { return this.closeBracketToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.openBracketToken;
                case 1: return this.parameters;
                case 2: return this.closeBracketToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CrefBracketedParameterListSyntax().ctor_9776(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCrefBracketedParameterList(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCrefBracketedParameterList(this);
        }

        public Update(openBracketToken: SyntaxToken, parameters: SeparatedSyntaxList<CrefParameterSyntax>, closeBracketToken: SyntaxToken): CrefBracketedParameterListSyntax {
            if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken) {
                var newNode = SyntaxFactory.CrefBracketedParameterList(openBracketToken, parameters, closeBracketToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CrefBracketedParameterListSyntax().ctor_2822(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CrefBracketedParameterListSyntax().ctor_2822(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1146(reader: Roslyn.Utilities.ObjectReader): CrefBracketedParameterListSyntax {
            super.ctor_1932(reader);
            this.SlotCount = 3;
            var openBracketToken = <SyntaxToken>reader.ReadValue();
            if (openBracketToken != null) {
                this.AdjustFlagsAndWidth(openBracketToken);
                this.openBracketToken = openBracketToken;
                return this;
            }
            var parameters = <CSharpSyntaxNode>reader.ReadValue();
            if (parameters != null) {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
                return this;
            }
            var closeBracketToken = <SyntaxToken>reader.ReadValue();
            if (closeBracketToken != null) {
                this.AdjustFlagsAndWidth(closeBracketToken);
                this.closeBracketToken = closeBracketToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeBracketToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CrefBracketedParameterListSyntax().ctor_1146(r);
        }
    }

    export class CrefParameterSyntax extends CSharpSyntaxNode {
        refOrOutKeyword: SyntaxToken;
        type: TypeSyntax;

        constructor() { super(); }
        ctor_1463(kind: SyntaxKind, refOrOutKeyword: SyntaxToken, type: TypeSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): CrefParameterSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            if (refOrOutKeyword != null) {
                this.AdjustFlagsAndWidth(refOrOutKeyword);
                this.refOrOutKeyword = refOrOutKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }


        ctor_4620(kind: SyntaxKind, refOrOutKeyword: SyntaxToken, type: TypeSyntax, context: SyntaxFactoryContext): CrefParameterSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            if (refOrOutKeyword != null) {
                this.AdjustFlagsAndWidth(refOrOutKeyword);
                this.refOrOutKeyword = refOrOutKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }


        ctor_1290(kind: SyntaxKind, refOrOutKeyword: SyntaxToken, type: TypeSyntax): CrefParameterSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            if (refOrOutKeyword != null) {
                this.AdjustFlagsAndWidth(refOrOutKeyword);
                this.refOrOutKeyword = refOrOutKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            return this;
        }

        public get RefOrOutKeyword(): SyntaxToken { return this.refOrOutKeyword; }
        public get Type(): TypeSyntax { return this.type; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.refOrOutKeyword;
                case 1: return this.type;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.CrefParameterSyntax().ctor_1978(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitCrefParameter(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitCrefParameter(this);
        }

        public Update(refOrOutKeyword: SyntaxToken, type: TypeSyntax): CrefParameterSyntax {
            if (refOrOutKeyword != this.RefOrOutKeyword || type != this.Type) {
                var newNode = SyntaxFactory.CrefParameter(refOrOutKeyword, type);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new CrefParameterSyntax().ctor_1463(this.Kind, this.refOrOutKeyword, this.type, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new CrefParameterSyntax().ctor_1463(this.Kind, this.refOrOutKeyword, this.type, this.GetDiagnostics(), annotations);
        }

        public ctor_5921(reader: Roslyn.Utilities.ObjectReader): CrefParameterSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var refOrOutKeyword = <SyntaxToken>reader.ReadValue();
            if (refOrOutKeyword != null) {
                this.AdjustFlagsAndWidth(refOrOutKeyword);
                this.refOrOutKeyword = refOrOutKeyword;
                return this;
            }
            var type = <TypeSyntax>reader.ReadValue();
            if (type != null) {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.refOrOutKeyword);
            writer.WriteValue(this.type);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new CrefParameterSyntax().ctor_5921(r);
        }
    }

    export class XmlNodeSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_1320(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlNodeSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_1732(kind: SyntaxKind): XmlNodeSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_9053(reader: Roslyn.Utilities.ObjectReader): XmlNodeSyntax {
            super.ctor_4942(reader);
            return this;
        }
    }

    export class XmlElementSyntax extends XmlNodeSyntax {
        startTag: XmlElementStartTagSyntax;
        content: CSharpSyntaxNode;
        endTag: XmlElementEndTagSyntax;

        constructor() { super(); }
        ctor_2144(kind: SyntaxKind, startTag: XmlElementStartTagSyntax, content: CSharpSyntaxNode, endTag: XmlElementEndTagSyntax, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlElementSyntax {
            super.ctor_1320(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null) {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
            return this;
        }


        ctor_1661(kind: SyntaxKind, startTag: XmlElementStartTagSyntax, content: CSharpSyntaxNode, endTag: XmlElementEndTagSyntax, context: SyntaxFactoryContext): XmlElementSyntax {
            super.ctor_1732(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null) {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
            return this;
        }


        ctor_1787(kind: SyntaxKind, startTag: XmlElementStartTagSyntax, content: CSharpSyntaxNode, endTag: XmlElementEndTagSyntax): XmlElementSyntax {
            super.ctor_1732(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null) {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
            return this;
        }

        public get StartTag(): XmlElementStartTagSyntax { return this.startTag; }
        public get Content(): SyntaxList<XmlNodeSyntax> { return new SyntaxList<XmlNodeSyntax>().ctor_1319(this.content); }
        public get EndTag(): XmlElementEndTagSyntax { return this.endTag; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.startTag;
                case 1: return this.content;
                case 2: return this.endTag;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlElementSyntax().ctor_3794(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlElement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlElement(this);
        }

        public Update(startTag: XmlElementStartTagSyntax, content: SyntaxList<XmlNodeSyntax>, endTag: XmlElementEndTagSyntax): XmlElementSyntax {
            if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag) {
                var newNode = SyntaxFactory.XmlElement(startTag, content, endTag);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlElementSyntax().ctor_2144(this.Kind, this.startTag, this.content, this.endTag, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlElementSyntax().ctor_2144(this.Kind, this.startTag, this.content, this.endTag, this.GetDiagnostics(), annotations);
        }

        public ctor_5825(reader: Roslyn.Utilities.ObjectReader): XmlElementSyntax {
            super.ctor_9053(reader);
            this.SlotCount = 3;
            var startTag = <XmlElementStartTagSyntax>reader.ReadValue();
            if (startTag != null) {
                this.AdjustFlagsAndWidth(startTag);
                this.startTag = startTag;
                return this;
            }
            var content = <CSharpSyntaxNode>reader.ReadValue();
            if (content != null) {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
                return this;
            }
            var endTag = <XmlElementEndTagSyntax>reader.ReadValue();
            if (endTag != null) {
                this.AdjustFlagsAndWidth(endTag);
                this.endTag = endTag;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.startTag);
            writer.WriteValue(this.content);
            writer.WriteValue(this.endTag);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlElementSyntax().ctor_5825(r);
        }
    }

    export class XmlElementStartTagSyntax extends CSharpSyntaxNode {
        lessThanToken: SyntaxToken;
        name: XmlNameSyntax;
        attributes: CSharpSyntaxNode;
        greaterThanToken: SyntaxToken;

        constructor() { super(); }
        ctor_3655(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, greaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlElementStartTagSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }


        ctor_7130(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, greaterThanToken: SyntaxToken, context: SyntaxFactoryContext): XmlElementStartTagSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }


        ctor_1726(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, greaterThanToken: SyntaxToken): XmlElementStartTagSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }

        public get LessThanToken(): SyntaxToken { return this.lessThanToken; }
        public get Name(): XmlNameSyntax { return this.name; }
        public get Attributes(): SyntaxList<XmlAttributeSyntax> { return new SyntaxList<XmlAttributeSyntax>().ctor_1319(this.attributes); }
        public get GreaterThanToken(): SyntaxToken { return this.greaterThanToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.lessThanToken;
                case 1: return this.name;
                case 2: return this.attributes;
                case 3: return this.greaterThanToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlElementStartTagSyntax().ctor_1010(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlElementStartTag(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlElementStartTag(this);
        }

        public Update(lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: SyntaxList<XmlAttributeSyntax>, greaterThanToken: SyntaxToken): XmlElementStartTagSyntax {
            if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken) {
                var newNode = SyntaxFactory.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlElementStartTagSyntax().ctor_3655(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlElementStartTagSyntax().ctor_3655(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, this.GetDiagnostics(), annotations);
        }

        public ctor_8444(reader: Roslyn.Utilities.ObjectReader): XmlElementStartTagSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 4;
            var lessThanToken = <SyntaxToken>reader.ReadValue();
            if (lessThanToken != null) {
                this.AdjustFlagsAndWidth(lessThanToken);
                this.lessThanToken = lessThanToken;
                return this;
            }
            var name = <XmlNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var attributes = <CSharpSyntaxNode>reader.ReadValue();
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
                return this;
            }
            var greaterThanToken = <SyntaxToken>reader.ReadValue();
            if (greaterThanToken != null) {
                this.AdjustFlagsAndWidth(greaterThanToken);
                this.greaterThanToken = greaterThanToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.greaterThanToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlElementStartTagSyntax().ctor_8444(r);
        }
    }

    export class XmlElementEndTagSyntax extends CSharpSyntaxNode {
        lessThanSlashToken: SyntaxToken;
        name: XmlNameSyntax;
        greaterThanToken: SyntaxToken;

        constructor() { super(); }
        ctor_6287(kind: SyntaxKind, lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlElementEndTagSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }


        ctor_2034(kind: SyntaxKind, lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken, context: SyntaxFactoryContext): XmlElementEndTagSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }


        ctor_1135(kind: SyntaxKind, lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken): XmlElementEndTagSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
            return this;
        }

        public get LessThanSlashToken(): SyntaxToken { return this.lessThanSlashToken; }
        public get Name(): XmlNameSyntax { return this.name; }
        public get GreaterThanToken(): SyntaxToken { return this.greaterThanToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.lessThanSlashToken;
                case 1: return this.name;
                case 2: return this.greaterThanToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlElementEndTagSyntax().ctor_7385(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlElementEndTag(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlElementEndTag(this);
        }

        public Update(lessThanSlashToken: SyntaxToken, name: XmlNameSyntax, greaterThanToken: SyntaxToken): XmlElementEndTagSyntax {
            if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken) {
                var newNode = SyntaxFactory.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlElementEndTagSyntax().ctor_6287(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlElementEndTagSyntax().ctor_6287(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1776(reader: Roslyn.Utilities.ObjectReader): XmlElementEndTagSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 3;
            var lessThanSlashToken = <SyntaxToken>reader.ReadValue();
            if (lessThanSlashToken != null) {
                this.AdjustFlagsAndWidth(lessThanSlashToken);
                this.lessThanSlashToken = lessThanSlashToken;
                return this;
            }
            var name = <XmlNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var greaterThanToken = <SyntaxToken>reader.ReadValue();
            if (greaterThanToken != null) {
                this.AdjustFlagsAndWidth(greaterThanToken);
                this.greaterThanToken = greaterThanToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.lessThanSlashToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.greaterThanToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlElementEndTagSyntax().ctor_1776(r);
        }
    }

    export class XmlEmptyElementSyntax extends XmlNodeSyntax {
        lessThanToken: SyntaxToken;
        name: XmlNameSyntax;
        attributes: CSharpSyntaxNode;
        slashGreaterThanToken: SyntaxToken;

        constructor() { super(); }
        ctor_1023(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, slashGreaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlEmptyElementSyntax {
            super.ctor_1320(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
            return this;
        }


        ctor_9676(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, slashGreaterThanToken: SyntaxToken, context: SyntaxFactoryContext): XmlEmptyElementSyntax {
            super.ctor_1732(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
            return this;
        }


        ctor_1537(kind: SyntaxKind, lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: CSharpSyntaxNode, slashGreaterThanToken: SyntaxToken): XmlEmptyElementSyntax {
            super.ctor_1732(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
            return this;
        }

        public get LessThanToken(): SyntaxToken { return this.lessThanToken; }
        public get Name(): XmlNameSyntax { return this.name; }
        public get Attributes(): SyntaxList<XmlAttributeSyntax> { return new SyntaxList<XmlAttributeSyntax>().ctor_1319(this.attributes); }
        public get SlashGreaterThanToken(): SyntaxToken { return this.slashGreaterThanToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.lessThanToken;
                case 1: return this.name;
                case 2: return this.attributes;
                case 3: return this.slashGreaterThanToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlEmptyElementSyntax().ctor_8541(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlEmptyElement(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlEmptyElement(this);
        }

        public Update(lessThanToken: SyntaxToken, name: XmlNameSyntax, attributes: SyntaxList<XmlAttributeSyntax>, slashGreaterThanToken: SyntaxToken): XmlEmptyElementSyntax {
            if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken) {
                var newNode = SyntaxFactory.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlEmptyElementSyntax().ctor_1023(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlEmptyElementSyntax().ctor_1023(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1440(reader: Roslyn.Utilities.ObjectReader): XmlEmptyElementSyntax {
            super.ctor_9053(reader);
            this.SlotCount = 4;
            var lessThanToken = <SyntaxToken>reader.ReadValue();
            if (lessThanToken != null) {
                this.AdjustFlagsAndWidth(lessThanToken);
                this.lessThanToken = lessThanToken;
                return this;
            }
            var name = <XmlNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var attributes = <CSharpSyntaxNode>reader.ReadValue();
            if (attributes != null) {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
                return this;
            }
            var slashGreaterThanToken = <SyntaxToken>reader.ReadValue();
            if (slashGreaterThanToken != null) {
                this.AdjustFlagsAndWidth(slashGreaterThanToken);
                this.slashGreaterThanToken = slashGreaterThanToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.slashGreaterThanToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlEmptyElementSyntax().ctor_1440(r);
        }
    }

    export class XmlNameSyntax extends CSharpSyntaxNode {
        prefix: XmlPrefixSyntax;
        localName: SyntaxToken;

        constructor() { super(); }
        ctor_1617(kind: SyntaxKind, prefix: XmlPrefixSyntax, localName: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlNameSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            if (prefix != null) {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            this.AdjustFlagsAndWidth(localName);
            this.localName = localName;
            return this;
        }


        ctor_1772(kind: SyntaxKind, prefix: XmlPrefixSyntax, localName: SyntaxToken, context: SyntaxFactoryContext): XmlNameSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            if (prefix != null) {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            this.AdjustFlagsAndWidth(localName);
            this.localName = localName;
            return this;
        }


        ctor_1073(kind: SyntaxKind, prefix: XmlPrefixSyntax, localName: SyntaxToken): XmlNameSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            if (prefix != null) {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            this.AdjustFlagsAndWidth(localName);
            this.localName = localName;
            return this;
        }

        public get Prefix(): XmlPrefixSyntax { return this.prefix; }
        public get LocalName(): SyntaxToken { return this.localName; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.prefix;
                case 1: return this.localName;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlNameSyntax().ctor_3909(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlName(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlName(this);
        }

        public Update(prefix: XmlPrefixSyntax, localName: SyntaxToken): XmlNameSyntax {
            if (prefix != this.Prefix || localName != this.LocalName) {
                var newNode = SyntaxFactory.XmlName(prefix, localName);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlNameSyntax().ctor_1617(this.Kind, this.prefix, this.localName, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlNameSyntax().ctor_1617(this.Kind, this.prefix, this.localName, this.GetDiagnostics(), annotations);
        }

        public ctor_4457(reader: Roslyn.Utilities.ObjectReader): XmlNameSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var prefix = <XmlPrefixSyntax>reader.ReadValue();
            if (prefix != null) {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
                return this;
            }
            var localName = <SyntaxToken>reader.ReadValue();
            if (localName != null) {
                this.AdjustFlagsAndWidth(localName);
                this.localName = localName;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.prefix);
            writer.WriteValue(this.localName);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlNameSyntax().ctor_4457(r);
        }
    }

    export class XmlPrefixSyntax extends CSharpSyntaxNode {
        prefix: SyntaxToken;
        colonToken: SyntaxToken;

        constructor() { super(); }
        ctor_1733_C(kind: SyntaxKind, prefix: SyntaxToken, colonToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlPrefixSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }


        ctor_1226(kind: SyntaxKind, prefix: SyntaxToken, colonToken: SyntaxToken, context: SyntaxFactoryContext): XmlPrefixSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }


        ctor_1260(kind: SyntaxKind, prefix: SyntaxToken, colonToken: SyntaxToken): XmlPrefixSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            return this;
        }

        public get Prefix(): SyntaxToken { return this.prefix; }
        public get ColonToken(): SyntaxToken { return this.colonToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.prefix;
                case 1: return this.colonToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlPrefixSyntax().ctor_2531(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlPrefix(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlPrefix(this);
        }

        public Update(prefix: SyntaxToken, colonToken: SyntaxToken): XmlPrefixSyntax {
            if (prefix != this.Prefix || colonToken != this.ColonToken) {
                var newNode = SyntaxFactory.XmlPrefix(prefix, colonToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlPrefixSyntax().ctor_1733_C(this.Kind, this.prefix, this.colonToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlPrefixSyntax().ctor_1733_C(this.Kind, this.prefix, this.colonToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1218(reader: Roslyn.Utilities.ObjectReader): XmlPrefixSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 2;
            var prefix = <SyntaxToken>reader.ReadValue();
            if (prefix != null) {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
                return this;
            }
            var colonToken = <SyntaxToken>reader.ReadValue();
            if (colonToken != null) {
                this.AdjustFlagsAndWidth(colonToken);
                this.colonToken = colonToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.prefix);
            writer.WriteValue(this.colonToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlPrefixSyntax().ctor_1218(r);
        }
    }

    export class XmlAttributeSyntax extends CSharpSyntaxNode {
        constructor() { super(); }
        ctor_1557(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlAttributeSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            return this;
        }
        ctor_5213(kind: SyntaxKind): XmlAttributeSyntax {
            super.ctor_1907(kind);
            return this;
        }

        ctor_1098(reader: Roslyn.Utilities.ObjectReader): XmlAttributeSyntax {
            super.ctor_4942(reader);
            return this;
        }

        public Name: XmlNameSyntax;

        public EqualsToken: SyntaxToken;

        public StartQuoteToken: SyntaxToken;

        public EndQuoteToken: SyntaxToken;
    }

    export class XmlTextAttributeSyntax extends XmlAttributeSyntax {
        name: XmlNameSyntax;
        equalsToken: SyntaxToken;
        startQuoteToken: SyntaxToken;
        textTokens: CSharpSyntaxNode;
        endQuoteToken: SyntaxToken;

        constructor() { super(); }
        ctor_7087(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: CSharpSyntaxNode, endQuoteToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlTextAttributeSyntax {
            super.ctor_1557(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
            return this;
        }


        ctor_1991(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: CSharpSyntaxNode, endQuoteToken: SyntaxToken, context: SyntaxFactoryContext): XmlTextAttributeSyntax {
            super.ctor_5213(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
            return this;
        }


        ctor_2141(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: CSharpSyntaxNode, endQuoteToken: SyntaxToken): XmlTextAttributeSyntax {
            super.ctor_5213(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
            return this;
        }

        public get Name(): XmlNameSyntax { return this.name; }
        public get EqualsToken(): SyntaxToken { return this.equalsToken; }
        public get StartQuoteToken(): SyntaxToken { return this.startQuoteToken; }
        public get TextTokens(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.textTokens); }
        public get EndQuoteToken(): SyntaxToken { return this.endQuoteToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.name;
                case 1: return this.equalsToken;
                case 2: return this.startQuoteToken;
                case 3: return this.textTokens;
                case 4: return this.endQuoteToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlTextAttributeSyntax().ctor_1853(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlTextAttribute(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlTextAttribute(this);
        }

        public Update(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, endQuoteToken: SyntaxToken): XmlTextAttributeSyntax {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken) {
                var newNode = SyntaxFactory.XmlTextAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlTextAttributeSyntax().ctor_7087(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlTextAttributeSyntax().ctor_7087(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1728(reader: Roslyn.Utilities.ObjectReader): XmlTextAttributeSyntax {
            super.ctor_1098(reader);
            this.SlotCount = 5;
            var name = <XmlNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var equalsToken = <SyntaxToken>reader.ReadValue();
            if (equalsToken != null) {
                this.AdjustFlagsAndWidth(equalsToken);
                this.equalsToken = equalsToken;
                return this;
            }
            var startQuoteToken = <SyntaxToken>reader.ReadValue();
            if (startQuoteToken != null) {
                this.AdjustFlagsAndWidth(startQuoteToken);
                this.startQuoteToken = startQuoteToken;
                return this;
            }
            var textTokens = <CSharpSyntaxNode>reader.ReadValue();
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
                return this;
            }
            var endQuoteToken = <SyntaxToken>reader.ReadValue();
            if (endQuoteToken != null) {
                this.AdjustFlagsAndWidth(endQuoteToken);
                this.endQuoteToken = endQuoteToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.startQuoteToken);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.endQuoteToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlTextAttributeSyntax().ctor_1728(r);
        }
    }

    export class XmlCrefAttributeSyntax extends XmlAttributeSyntax {
        name: XmlNameSyntax;
        equalsToken: SyntaxToken;
        startQuoteToken: SyntaxToken;
        cref: CrefSyntax;
        endQuoteToken: SyntaxToken;

        constructor() { super(); }
        ctor_2010(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlCrefAttributeSyntax {
            super.ctor_1557(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(cref);
            this.cref = cref;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
            return this;
        }


        ctor_1110(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken, context: SyntaxFactoryContext): XmlCrefAttributeSyntax {
            super.ctor_5213(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(cref);
            this.cref = cref;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
            return this;
        }


        ctor_2049(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken): XmlCrefAttributeSyntax {
            super.ctor_5213(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(cref);
            this.cref = cref;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
            return this;
        }

        public get Name(): XmlNameSyntax { return this.name; }
        public get EqualsToken(): SyntaxToken { return this.equalsToken; }
        public get StartQuoteToken(): SyntaxToken { return this.startQuoteToken; }
        public get Cref(): CrefSyntax { return this.cref; }
        public get EndQuoteToken(): SyntaxToken { return this.endQuoteToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.name;
                case 1: return this.equalsToken;
                case 2: return this.startQuoteToken;
                case 3: return this.cref;
                case 4: return this.endQuoteToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlCrefAttributeSyntax().ctor_1305(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlCrefAttribute(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlCrefAttribute(this);
        }

        public Update(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, cref: CrefSyntax, endQuoteToken: SyntaxToken): XmlCrefAttributeSyntax {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || cref != this.Cref || endQuoteToken != this.EndQuoteToken) {
                var newNode = SyntaxFactory.XmlCrefAttribute(name, equalsToken, startQuoteToken, cref, endQuoteToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlCrefAttributeSyntax().ctor_2010(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlCrefAttributeSyntax().ctor_2010(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1715(reader: Roslyn.Utilities.ObjectReader): XmlCrefAttributeSyntax {
            super.ctor_1098(reader);
            this.SlotCount = 5;
            var name = <XmlNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var equalsToken = <SyntaxToken>reader.ReadValue();
            if (equalsToken != null) {
                this.AdjustFlagsAndWidth(equalsToken);
                this.equalsToken = equalsToken;
                return this;
            }
            var startQuoteToken = <SyntaxToken>reader.ReadValue();
            if (startQuoteToken != null) {
                this.AdjustFlagsAndWidth(startQuoteToken);
                this.startQuoteToken = startQuoteToken;
                return this;
            }
            var cref = <CrefSyntax>reader.ReadValue();
            if (cref != null) {
                this.AdjustFlagsAndWidth(cref);
                this.cref = cref;
                return this;
            }
            var endQuoteToken = <SyntaxToken>reader.ReadValue();
            if (endQuoteToken != null) {
                this.AdjustFlagsAndWidth(endQuoteToken);
                this.endQuoteToken = endQuoteToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.startQuoteToken);
            writer.WriteValue(this.cref);
            writer.WriteValue(this.endQuoteToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlCrefAttributeSyntax().ctor_1715(r);
        }
    }

    export class XmlNameAttributeSyntax extends XmlAttributeSyntax {
        name: XmlNameSyntax;
        equalsToken: SyntaxToken;
        startQuoteToken: SyntaxToken;
        identifier: IdentifierNameSyntax;
        endQuoteToken: SyntaxToken;

        constructor() { super(); }
        ctor_1926(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlNameAttributeSyntax {
            super.ctor_1557(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
            return this;
        }


        ctor_2473(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken, context: SyntaxFactoryContext): XmlNameAttributeSyntax {
            super.ctor_5213(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
            return this;
        }


        ctor_2001(kind: SyntaxKind, name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken): XmlNameAttributeSyntax {
            super.ctor_5213(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
            return this;
        }

        public get Name(): XmlNameSyntax { return this.name; }
        public get EqualsToken(): SyntaxToken { return this.equalsToken; }
        public get StartQuoteToken(): SyntaxToken { return this.startQuoteToken; }
        public get Identifier(): IdentifierNameSyntax { return this.identifier; }
        public get EndQuoteToken(): SyntaxToken { return this.endQuoteToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.name;
                case 1: return this.equalsToken;
                case 2: return this.startQuoteToken;
                case 3: return this.identifier;
                case 4: return this.endQuoteToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlNameAttributeSyntax().ctor_1624(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlNameAttribute(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlNameAttribute(this);
        }

        public Update(name: XmlNameSyntax, equalsToken: SyntaxToken, startQuoteToken: SyntaxToken, identifier: IdentifierNameSyntax, endQuoteToken: SyntaxToken): XmlNameAttributeSyntax {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || identifier != this.Identifier || endQuoteToken != this.EndQuoteToken) {
                var newNode = SyntaxFactory.XmlNameAttribute(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlNameAttributeSyntax().ctor_1926(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlNameAttributeSyntax().ctor_1926(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1022(reader: Roslyn.Utilities.ObjectReader): XmlNameAttributeSyntax {
            super.ctor_1098(reader);
            this.SlotCount = 5;
            var name = <XmlNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var equalsToken = <SyntaxToken>reader.ReadValue();
            if (equalsToken != null) {
                this.AdjustFlagsAndWidth(equalsToken);
                this.equalsToken = equalsToken;
                return this;
            }
            var startQuoteToken = <SyntaxToken>reader.ReadValue();
            if (startQuoteToken != null) {
                this.AdjustFlagsAndWidth(startQuoteToken);
                this.startQuoteToken = startQuoteToken;
                return this;
            }
            var identifier = <IdentifierNameSyntax>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var endQuoteToken = <SyntaxToken>reader.ReadValue();
            if (endQuoteToken != null) {
                this.AdjustFlagsAndWidth(endQuoteToken);
                this.endQuoteToken = endQuoteToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.startQuoteToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.endQuoteToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlNameAttributeSyntax().ctor_1022(r);
        }
    }

    export class XmlTextSyntax extends XmlNodeSyntax {
        textTokens: CSharpSyntaxNode;

        constructor() { super(); }
        ctor_8428(kind: SyntaxKind, textTokens: CSharpSyntaxNode, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlTextSyntax {
            super.ctor_1320(kind, diagnostics, annotations);
            this.SlotCount = 1;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            return this;
        }


        ctor_4772(kind: SyntaxKind, textTokens: CSharpSyntaxNode, context: SyntaxFactoryContext): XmlTextSyntax {
            super.ctor_1732(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 1;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            return this;
        }


        ctor_1049(kind: SyntaxKind, textTokens: CSharpSyntaxNode): XmlTextSyntax {
            super.ctor_1732(kind);
            this.SlotCount = 1;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            return this;
        }

        public get TextTokens(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.textTokens); }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.textTokens;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlTextSyntax().ctor_1447(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlText(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlText(this);
        }

        public Update(textTokens: SyntaxList<SyntaxToken>): XmlTextSyntax {
            if (textTokens != this.TextTokens) {
                var newNode = SyntaxFactory.XmlText(textTokens);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlTextSyntax().ctor_8428(this.Kind, this.textTokens, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlTextSyntax().ctor_8428(this.Kind, this.textTokens, this.GetDiagnostics(), annotations);
        }

        public ctor_1378(reader: Roslyn.Utilities.ObjectReader): XmlTextSyntax {
            super.ctor_9053(reader);
            this.SlotCount = 1;
            var textTokens = <CSharpSyntaxNode>reader.ReadValue();
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.textTokens);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlTextSyntax().ctor_1378(r);
        }
    }

    export class XmlCDataSectionSyntax extends XmlNodeSyntax {
        startCDataToken: SyntaxToken;
        textTokens: CSharpSyntaxNode;
        endCDataToken: SyntaxToken;

        constructor() { super(); }
        ctor_1655(kind: SyntaxKind, startCDataToken: SyntaxToken, textTokens: CSharpSyntaxNode, endCDataToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlCDataSectionSyntax {
            super.ctor_1320(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
            return this;
        }


        ctor_1490(kind: SyntaxKind, startCDataToken: SyntaxToken, textTokens: CSharpSyntaxNode, endCDataToken: SyntaxToken, context: SyntaxFactoryContext): XmlCDataSectionSyntax {
            super.ctor_1732(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
            return this;
        }


        ctor_1686(kind: SyntaxKind, startCDataToken: SyntaxToken, textTokens: CSharpSyntaxNode, endCDataToken: SyntaxToken): XmlCDataSectionSyntax {
            super.ctor_1732(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
            return this;
        }

        public get StartCDataToken(): SyntaxToken { return this.startCDataToken; }
        public get TextTokens(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.textTokens); }
        public get EndCDataToken(): SyntaxToken { return this.endCDataToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.startCDataToken;
                case 1: return this.textTokens;
                case 2: return this.endCDataToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlCDataSectionSyntax().ctor_5139(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlCDataSection(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlCDataSection(this);
        }

        public Update(startCDataToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, endCDataToken: SyntaxToken): XmlCDataSectionSyntax {
            if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken) {
                var newNode = SyntaxFactory.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlCDataSectionSyntax().ctor_1655(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlCDataSectionSyntax().ctor_1655(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, this.GetDiagnostics(), annotations);
        }

        public ctor_2088(reader: Roslyn.Utilities.ObjectReader): XmlCDataSectionSyntax {
            super.ctor_9053(reader);
            this.SlotCount = 3;
            var startCDataToken = <SyntaxToken>reader.ReadValue();
            if (startCDataToken != null) {
                this.AdjustFlagsAndWidth(startCDataToken);
                this.startCDataToken = startCDataToken;
                return this;
            }
            var textTokens = <CSharpSyntaxNode>reader.ReadValue();
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
                return this;
            }
            var endCDataToken = <SyntaxToken>reader.ReadValue();
            if (endCDataToken != null) {
                this.AdjustFlagsAndWidth(endCDataToken);
                this.endCDataToken = endCDataToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.startCDataToken);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.endCDataToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlCDataSectionSyntax().ctor_2088(r);
        }
    }

    export class XmlProcessingInstructionSyntax extends XmlNodeSyntax {
        startProcessingInstructionToken: SyntaxToken;
        name: XmlNameSyntax;
        textTokens: CSharpSyntaxNode;
        endProcessingInstructionToken: SyntaxToken;

        constructor() { super(); }
        ctor_3526(kind: SyntaxKind, startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: CSharpSyntaxNode, endProcessingInstructionToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlProcessingInstructionSyntax {
            super.ctor_1320(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
            return this;
        }


        ctor_1507(kind: SyntaxKind, startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: CSharpSyntaxNode, endProcessingInstructionToken: SyntaxToken, context: SyntaxFactoryContext): XmlProcessingInstructionSyntax {
            super.ctor_1732(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
            return this;
        }


        ctor_1064(kind: SyntaxKind, startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: CSharpSyntaxNode, endProcessingInstructionToken: SyntaxToken): XmlProcessingInstructionSyntax {
            super.ctor_1732(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
            return this;
        }

        public get StartProcessingInstructionToken(): SyntaxToken { return this.startProcessingInstructionToken; }
        public get Name(): XmlNameSyntax { return this.name; }
        public get TextTokens(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.textTokens); }
        public get EndProcessingInstructionToken(): SyntaxToken { return this.endProcessingInstructionToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.startProcessingInstructionToken;
                case 1: return this.name;
                case 2: return this.textTokens;
                case 3: return this.endProcessingInstructionToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlProcessingInstructionSyntax().ctor_3449(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlProcessingInstruction(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlProcessingInstruction(this);
        }

        public Update(startProcessingInstructionToken: SyntaxToken, name: XmlNameSyntax, textTokens: SyntaxList<SyntaxToken>, endProcessingInstructionToken: SyntaxToken): XmlProcessingInstructionSyntax {
            if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken) {
                var newNode = SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlProcessingInstructionSyntax().ctor_3526(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlProcessingInstructionSyntax().ctor_3526(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1488(reader: Roslyn.Utilities.ObjectReader): XmlProcessingInstructionSyntax {
            super.ctor_9053(reader);
            this.SlotCount = 4;
            var startProcessingInstructionToken = <SyntaxToken>reader.ReadValue();
            if (startProcessingInstructionToken != null) {
                this.AdjustFlagsAndWidth(startProcessingInstructionToken);
                this.startProcessingInstructionToken = startProcessingInstructionToken;
                return this;
            }
            var name = <XmlNameSyntax>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var textTokens = <CSharpSyntaxNode>reader.ReadValue();
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
                return this;
            }
            var endProcessingInstructionToken = <SyntaxToken>reader.ReadValue();
            if (endProcessingInstructionToken != null) {
                this.AdjustFlagsAndWidth(endProcessingInstructionToken);
                this.endProcessingInstructionToken = endProcessingInstructionToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.startProcessingInstructionToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.endProcessingInstructionToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlProcessingInstructionSyntax().ctor_1488(r);
        }
    }

    export class XmlCommentSyntax extends XmlNodeSyntax {
        lessThanExclamationMinusMinusToken: SyntaxToken;
        textTokens: CSharpSyntaxNode;
        minusMinusGreaterThanToken: SyntaxToken;

        constructor() { super(); }
        ctor_3348(kind: SyntaxKind, lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: CSharpSyntaxNode, minusMinusGreaterThanToken: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): XmlCommentSyntax {
            super.ctor_1320(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
            return this;
        }


        ctor_1022(kind: SyntaxKind, lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: CSharpSyntaxNode, minusMinusGreaterThanToken: SyntaxToken, context: SyntaxFactoryContext): XmlCommentSyntax {
            super.ctor_1732(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
            return this;
        }


        ctor_1033(kind: SyntaxKind, lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: CSharpSyntaxNode, minusMinusGreaterThanToken: SyntaxToken): XmlCommentSyntax {
            super.ctor_1732(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
            return this;
        }

        public get LessThanExclamationMinusMinusToken(): SyntaxToken { return this.lessThanExclamationMinusMinusToken; }
        public get TextTokens(): SyntaxList<SyntaxToken> { return new SyntaxList<SyntaxToken>().ctor_1319(this.textTokens); }
        public get MinusMinusGreaterThanToken(): SyntaxToken { return this.minusMinusGreaterThanToken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.lessThanExclamationMinusMinusToken;
                case 1: return this.textTokens;
                case 2: return this.minusMinusGreaterThanToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.XmlCommentSyntax().ctor_1807(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitXmlComment(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitXmlComment(this);
        }

        public Update(lessThanExclamationMinusMinusToken: SyntaxToken, textTokens: SyntaxList<SyntaxToken>, minusMinusGreaterThanToken: SyntaxToken): XmlCommentSyntax {
            if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken) {
                var newNode = SyntaxFactory.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new XmlCommentSyntax().ctor_3348(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new XmlCommentSyntax().ctor_3348(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, this.GetDiagnostics(), annotations);
        }

        public ctor_1732_C(reader: Roslyn.Utilities.ObjectReader): XmlCommentSyntax {
            super.ctor_9053(reader);
            this.SlotCount = 3;
            var lessThanExclamationMinusMinusToken = <SyntaxToken>reader.ReadValue();
            if (lessThanExclamationMinusMinusToken != null) {
                this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
                this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
                return this;
            }
            var textTokens = <CSharpSyntaxNode>reader.ReadValue();
            if (textTokens != null) {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
                return this;
            }
            var minusMinusGreaterThanToken = <SyntaxToken>reader.ReadValue();
            if (minusMinusGreaterThanToken != null) {
                this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
                this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.lessThanExclamationMinusMinusToken);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.minusMinusGreaterThanToken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new XmlCommentSyntax().ctor_1732_C(r);
        }
    }

    export class BranchingDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        constructor() { super(); }
        ctor_1474(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BranchingDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            return this;
        }
        ctor_2042(kind: SyntaxKind): BranchingDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            return this;
        }

        ctor_6254(reader: Roslyn.Utilities.ObjectReader): BranchingDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            return this;
        }

        public BranchTaken: boolean
    }

    export class ConditionalDirectiveTriviaSyntax extends BranchingDirectiveTriviaSyntax {
        constructor() { super(); }
        ctor_1319(kind: SyntaxKind, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ConditionalDirectiveTriviaSyntax {
            super.ctor_1474(kind, diagnostics, annotations);
            return this;
        }
        ctor_1596(kind: SyntaxKind): ConditionalDirectiveTriviaSyntax {
            super.ctor_2042(kind);
            return this;
        }

        ctor_1311(reader: Roslyn.Utilities.ObjectReader): ConditionalDirectiveTriviaSyntax {
            super.ctor_6254(reader);
            return this;
        }

        public Condition: ExpressionSyntax;

        public ConditionValue: boolean
    }

    export class IfDirectiveTriviaSyntax extends ConditionalDirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        ifKeyword: SyntaxToken;
        condition: ExpressionSyntax;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        branchTaken: boolean;
        conditionValue: boolean;

        constructor() { super(); }
        ctor_7775(kind: SyntaxKind, hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): IfDirectiveTriviaSyntax {
            super.ctor_1319(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
            return this;
        }


        ctor_2093(kind: SyntaxKind, hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean, context: SyntaxFactoryContext): IfDirectiveTriviaSyntax {
            super.ctor_1596(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
            return this;
        }


        ctor_2113(kind: SyntaxKind, hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): IfDirectiveTriviaSyntax {
            super.ctor_1596(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get IfKeyword(): SyntaxToken { return this.ifKeyword; }
        public get Condition(): ExpressionSyntax { return this.condition; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }
        public get BranchTaken(): boolean { return this.branchTaken; }
        public get ConditionValue(): boolean { return this.conditionValue; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.ifKeyword;
                case 2: return this.condition;
                case 3: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.IfDirectiveTriviaSyntax().ctor_1844(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitIfDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitIfDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, ifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): IfDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || ifKeyword != this.IfKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.IfDirectiveTrivia(hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new IfDirectiveTriviaSyntax().ctor_7775(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new IfDirectiveTriviaSyntax().ctor_7775(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, this.GetDiagnostics(), annotations);
        }

        public ctor_1308(reader: Roslyn.Utilities.ObjectReader): IfDirectiveTriviaSyntax {
            super.ctor_1311(reader);
            this.SlotCount = 4;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var ifKeyword = <SyntaxToken>reader.ReadValue();
            if (ifKeyword != null) {
                this.AdjustFlagsAndWidth(ifKeyword);
                this.ifKeyword = ifKeyword;
                return this;
            }
            var condition = <ExpressionSyntax>reader.ReadValue();
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
            this.branchTaken = <boolean>reader.ReadBoolean();
            this.conditionValue = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.ifKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
            writer.WriteBoolean(this.branchTaken);
            writer.WriteBoolean(this.conditionValue);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new IfDirectiveTriviaSyntax().ctor_1308(r);
        }
    }

    export class ElifDirectiveTriviaSyntax extends ConditionalDirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        elifKeyword: SyntaxToken;
        condition: ExpressionSyntax;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        branchTaken: boolean;
        conditionValue: boolean;

        constructor() { super(); }
        ctor_1705(kind: SyntaxKind, hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ElifDirectiveTriviaSyntax {
            super.ctor_1319(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elifKeyword);
            this.elifKeyword = elifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
            return this;
        }


        ctor_7592(kind: SyntaxKind, hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean, context: SyntaxFactoryContext): ElifDirectiveTriviaSyntax {
            super.ctor_1596(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elifKeyword);
            this.elifKeyword = elifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
            return this;
        }


        ctor_9784(kind: SyntaxKind, hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): ElifDirectiveTriviaSyntax {
            super.ctor_1596(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elifKeyword);
            this.elifKeyword = elifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get ElifKeyword(): SyntaxToken { return this.elifKeyword; }
        public get Condition(): ExpressionSyntax { return this.condition; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }
        public get BranchTaken(): boolean { return this.branchTaken; }
        public get ConditionValue(): boolean { return this.conditionValue; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.elifKeyword;
                case 2: return this.condition;
                case 3: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ElifDirectiveTriviaSyntax().ctor_1977(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitElifDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitElifDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, elifKeyword: SyntaxToken, condition: ExpressionSyntax, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, conditionValue: boolean): ElifDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || elifKeyword != this.ElifKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.ElifDirectiveTrivia(hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ElifDirectiveTriviaSyntax().ctor_1705(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ElifDirectiveTriviaSyntax().ctor_1705(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, this.GetDiagnostics(), annotations);
        }

        public ctor_9079(reader: Roslyn.Utilities.ObjectReader): ElifDirectiveTriviaSyntax {
            super.ctor_1311(reader);
            this.SlotCount = 4;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var elifKeyword = <SyntaxToken>reader.ReadValue();
            if (elifKeyword != null) {
                this.AdjustFlagsAndWidth(elifKeyword);
                this.elifKeyword = elifKeyword;
                return this;
            }
            var condition = <ExpressionSyntax>reader.ReadValue();
            if (condition != null) {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
            this.branchTaken = <boolean>reader.ReadBoolean();
            this.conditionValue = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.elifKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
            writer.WriteBoolean(this.branchTaken);
            writer.WriteBoolean(this.conditionValue);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ElifDirectiveTriviaSyntax().ctor_9079(r);
        }
    }

    export class ElseDirectiveTriviaSyntax extends BranchingDirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        elseKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;
        branchTaken: boolean;

        constructor() { super(); }
        ctor_8514(kind: SyntaxKind, hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ElseDirectiveTriviaSyntax {
            super.ctor_1474(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            return this;
        }


        ctor_2016(kind: SyntaxKind, hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean, context: SyntaxFactoryContext): ElseDirectiveTriviaSyntax {
            super.ctor_2042(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            return this;
        }


        ctor_1549(kind: SyntaxKind, hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean): ElseDirectiveTriviaSyntax {
            super.ctor_2042(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get ElseKeyword(): SyntaxToken { return this.elseKeyword; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }
        public get BranchTaken(): boolean { return this.branchTaken; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.elseKeyword;
                case 2: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ElseDirectiveTriviaSyntax().ctor_1939(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitElseDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitElseDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, elseKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, branchTaken: boolean): ElseDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || elseKeyword != this.ElseKeyword || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.ElseDirectiveTrivia(hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ElseDirectiveTriviaSyntax().ctor_8514(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ElseDirectiveTriviaSyntax().ctor_8514(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.GetDiagnostics(), annotations);
        }

        public ctor_1067(reader: Roslyn.Utilities.ObjectReader): ElseDirectiveTriviaSyntax {
            super.ctor_6254(reader);
            this.SlotCount = 3;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var elseKeyword = <SyntaxToken>reader.ReadValue();
            if (elseKeyword != null) {
                this.AdjustFlagsAndWidth(elseKeyword);
                this.elseKeyword = elseKeyword;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
            this.branchTaken = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.elseKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
            writer.WriteBoolean(this.branchTaken);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ElseDirectiveTriviaSyntax().ctor_1067(r);
        }
    }

    export class EndIfDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        endIfKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_1788(kind: SyntaxKind, hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EndIfDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endIfKeyword);
            this.endIfKeyword = endIfKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_6683(kind: SyntaxKind, hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): EndIfDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endIfKeyword);
            this.endIfKeyword = endIfKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_2989(kind: SyntaxKind, hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndIfDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endIfKeyword);
            this.endIfKeyword = endIfKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get EndIfKeyword(): SyntaxToken { return this.endIfKeyword; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.endIfKeyword;
                case 2: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.EndIfDirectiveTriviaSyntax().ctor_1812(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitEndIfDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitEndIfDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, endIfKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndIfDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || endIfKeyword != this.EndIfKeyword || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.EndIfDirectiveTrivia(hashToken, endIfKeyword, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new EndIfDirectiveTriviaSyntax().ctor_1788(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new EndIfDirectiveTriviaSyntax().ctor_1788(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_1089(reader: Roslyn.Utilities.ObjectReader): EndIfDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 3;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var endIfKeyword = <SyntaxToken>reader.ReadValue();
            if (endIfKeyword != null) {
                this.AdjustFlagsAndWidth(endIfKeyword);
                this.endIfKeyword = endIfKeyword;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.endIfKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new EndIfDirectiveTriviaSyntax().ctor_1089(r);
        }
    }

    export class RegionDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        regionKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_8896(kind: SyntaxKind, hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): RegionDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(regionKeyword);
            this.regionKeyword = regionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1982(kind: SyntaxKind, hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): RegionDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(regionKeyword);
            this.regionKeyword = regionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_2005(kind: SyntaxKind, hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): RegionDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(regionKeyword);
            this.regionKeyword = regionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get RegionKeyword(): SyntaxToken { return this.regionKeyword; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.regionKeyword;
                case 2: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.RegionDirectiveTriviaSyntax().ctor_1446(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitRegionDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitRegionDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, regionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): RegionDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || regionKeyword != this.RegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.RegionDirectiveTrivia(hashToken, regionKeyword, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new RegionDirectiveTriviaSyntax().ctor_8896(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new RegionDirectiveTriviaSyntax().ctor_8896(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_1589(reader: Roslyn.Utilities.ObjectReader): RegionDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 3;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var regionKeyword = <SyntaxToken>reader.ReadValue();
            if (regionKeyword != null) {
                this.AdjustFlagsAndWidth(regionKeyword);
                this.regionKeyword = regionKeyword;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.regionKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new RegionDirectiveTriviaSyntax().ctor_1589(r);
        }
    }

    export class EndRegionDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        endRegionKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_9044(kind: SyntaxKind, hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): EndRegionDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endRegionKeyword);
            this.endRegionKeyword = endRegionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1167(kind: SyntaxKind, hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): EndRegionDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endRegionKeyword);
            this.endRegionKeyword = endRegionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1067(kind: SyntaxKind, hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndRegionDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endRegionKeyword);
            this.endRegionKeyword = endRegionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get EndRegionKeyword(): SyntaxToken { return this.endRegionKeyword; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.endRegionKeyword;
                case 2: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.EndRegionDirectiveTriviaSyntax().ctor_2484(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitEndRegionDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitEndRegionDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, endRegionKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): EndRegionDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || endRegionKeyword != this.EndRegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.EndRegionDirectiveTrivia(hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new EndRegionDirectiveTriviaSyntax().ctor_9044(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new EndRegionDirectiveTriviaSyntax().ctor_9044(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_1946(reader: Roslyn.Utilities.ObjectReader): EndRegionDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 3;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var endRegionKeyword = <SyntaxToken>reader.ReadValue();
            if (endRegionKeyword != null) {
                this.AdjustFlagsAndWidth(endRegionKeyword);
                this.endRegionKeyword = endRegionKeyword;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.endRegionKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new EndRegionDirectiveTriviaSyntax().ctor_1946(r);
        }
    }

    export class ErrorDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        errorKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_2123(kind: SyntaxKind, hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ErrorDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(errorKeyword);
            this.errorKeyword = errorKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_3594(kind: SyntaxKind, hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): ErrorDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(errorKeyword);
            this.errorKeyword = errorKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1746(kind: SyntaxKind, hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ErrorDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(errorKeyword);
            this.errorKeyword = errorKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get ErrorKeyword(): SyntaxToken { return this.errorKeyword; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.errorKeyword;
                case 2: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ErrorDirectiveTriviaSyntax().ctor_1813(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitErrorDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitErrorDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, errorKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ErrorDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || errorKeyword != this.ErrorKeyword || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.ErrorDirectiveTrivia(hashToken, errorKeyword, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ErrorDirectiveTriviaSyntax().ctor_2123(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ErrorDirectiveTriviaSyntax().ctor_2123(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_7672(reader: Roslyn.Utilities.ObjectReader): ErrorDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 3;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var errorKeyword = <SyntaxToken>reader.ReadValue();
            if (errorKeyword != null) {
                this.AdjustFlagsAndWidth(errorKeyword);
                this.errorKeyword = errorKeyword;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.errorKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ErrorDirectiveTriviaSyntax().ctor_7672(r);
        }
    }

    export class WarningDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        warningKeyword: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_8172(kind: SyntaxKind, hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): WarningDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1502(kind: SyntaxKind, hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): WarningDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1630(kind: SyntaxKind, hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): WarningDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get WarningKeyword(): SyntaxToken { return this.warningKeyword; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.warningKeyword;
                case 2: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.WarningDirectiveTriviaSyntax().ctor_1762(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitWarningDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitWarningDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, warningKeyword: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): WarningDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || warningKeyword != this.WarningKeyword || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.WarningDirectiveTrivia(hashToken, warningKeyword, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new WarningDirectiveTriviaSyntax().ctor_8172(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new WarningDirectiveTriviaSyntax().ctor_8172(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_1613(reader: Roslyn.Utilities.ObjectReader): WarningDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 3;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var warningKeyword = <SyntaxToken>reader.ReadValue();
            if (warningKeyword != null) {
                this.AdjustFlagsAndWidth(warningKeyword);
                this.warningKeyword = warningKeyword;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.warningKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new WarningDirectiveTriviaSyntax().ctor_1613(r);
        }
    }

    export class BadDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        identifier: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_1152(kind: SyntaxKind, hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): BadDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1120(kind: SyntaxKind, hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): BadDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1037(kind: SyntaxKind, hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): BadDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get Identifier(): SyntaxToken { return this.identifier; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.identifier;
                case 2: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.BadDirectiveTriviaSyntax().ctor_8533(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitBadDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitBadDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, identifier: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): BadDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || identifier != this.Identifier || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.BadDirectiveTrivia(hashToken, identifier, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new BadDirectiveTriviaSyntax().ctor_1152(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new BadDirectiveTriviaSyntax().ctor_1152(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_1471(reader: Roslyn.Utilities.ObjectReader): BadDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 3;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var identifier = <SyntaxToken>reader.ReadValue();
            if (identifier != null) {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new BadDirectiveTriviaSyntax().ctor_1471(r);
        }
    }

    export class DefineDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        defineKeyword: SyntaxToken;
        name: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_1065(kind: SyntaxKind, hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): DefineDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(defineKeyword);
            this.defineKeyword = defineKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1673(kind: SyntaxKind, hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): DefineDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(defineKeyword);
            this.defineKeyword = defineKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1051(kind: SyntaxKind, hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): DefineDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(defineKeyword);
            this.defineKeyword = defineKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get DefineKeyword(): SyntaxToken { return this.defineKeyword; }
        public get Name(): SyntaxToken { return this.name; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.defineKeyword;
                case 2: return this.name;
                case 3: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.DefineDirectiveTriviaSyntax().ctor_1613(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitDefineDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitDefineDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, defineKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): DefineDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || defineKeyword != this.DefineKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.DefineDirectiveTrivia(hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new DefineDirectiveTriviaSyntax().ctor_1065(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new DefineDirectiveTriviaSyntax().ctor_1065(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_8033(reader: Roslyn.Utilities.ObjectReader): DefineDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 4;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var defineKeyword = <SyntaxToken>reader.ReadValue();
            if (defineKeyword != null) {
                this.AdjustFlagsAndWidth(defineKeyword);
                this.defineKeyword = defineKeyword;
                return this;
            }
            var name = <SyntaxToken>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.defineKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new DefineDirectiveTriviaSyntax().ctor_8033(r);
        }
    }

    export class UndefDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        undefKeyword: SyntaxToken;
        name: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_1777(kind: SyntaxKind, hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): UndefDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(undefKeyword);
            this.undefKeyword = undefKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1192(kind: SyntaxKind, hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): UndefDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(undefKeyword);
            this.undefKeyword = undefKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_5569(kind: SyntaxKind, hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): UndefDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(undefKeyword);
            this.undefKeyword = undefKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get UndefKeyword(): SyntaxToken { return this.undefKeyword; }
        public get Name(): SyntaxToken { return this.name; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.undefKeyword;
                case 2: return this.name;
                case 3: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.UndefDirectiveTriviaSyntax().ctor_2071(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitUndefDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitUndefDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, undefKeyword: SyntaxToken, name: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): UndefDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || undefKeyword != this.UndefKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.UndefDirectiveTrivia(hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new UndefDirectiveTriviaSyntax().ctor_1777(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new UndefDirectiveTriviaSyntax().ctor_1777(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_2015(reader: Roslyn.Utilities.ObjectReader): UndefDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 4;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var undefKeyword = <SyntaxToken>reader.ReadValue();
            if (undefKeyword != null) {
                this.AdjustFlagsAndWidth(undefKeyword);
                this.undefKeyword = undefKeyword;
                return this;
            }
            var name = <SyntaxToken>reader.ReadValue();
            if (name != null) {
                this.AdjustFlagsAndWidth(name);
                this.name = name;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.undefKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new UndefDirectiveTriviaSyntax().ctor_2015(r);
        }
    }

    export class LineDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        lineKeyword: SyntaxToken;
        line: SyntaxToken;
        file: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_1702(kind: SyntaxKind, hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): LineDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(lineKeyword);
            this.lineKeyword = lineKeyword;
            this.AdjustFlagsAndWidth(line);
            this.line = line;
            if (file != null) {
                this.AdjustFlagsAndWidth(file);
                this.file = file;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_2058(kind: SyntaxKind, hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): LineDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(lineKeyword);
            this.lineKeyword = lineKeyword;
            this.AdjustFlagsAndWidth(line);
            this.line = line;
            if (file != null) {
                this.AdjustFlagsAndWidth(file);
                this.file = file;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_4648(kind: SyntaxKind, hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): LineDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(lineKeyword);
            this.lineKeyword = lineKeyword;
            this.AdjustFlagsAndWidth(line);
            this.line = line;
            if (file != null) {
                this.AdjustFlagsAndWidth(file);
                this.file = file;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get LineKeyword(): SyntaxToken { return this.lineKeyword; }
        public get Line(): SyntaxToken { return this.line; }
        public get File(): SyntaxToken { return this.file; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.lineKeyword;
                case 2: return this.line;
                case 3: return this.file;
                case 4: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.LineDirectiveTriviaSyntax().ctor_1199(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitLineDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitLineDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, lineKeyword: SyntaxToken, line: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): LineDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || lineKeyword != this.LineKeyword || line != this.Line || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.LineDirectiveTrivia(hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new LineDirectiveTriviaSyntax().ctor_1702(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new LineDirectiveTriviaSyntax().ctor_1702(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_1094(reader: Roslyn.Utilities.ObjectReader): LineDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 5;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var lineKeyword = <SyntaxToken>reader.ReadValue();
            if (lineKeyword != null) {
                this.AdjustFlagsAndWidth(lineKeyword);
                this.lineKeyword = lineKeyword;
                return this;
            }
            var line = <SyntaxToken>reader.ReadValue();
            if (line != null) {
                this.AdjustFlagsAndWidth(line);
                this.line = line;
                return this;
            }
            var file = <SyntaxToken>reader.ReadValue();
            if (file != null) {
                this.AdjustFlagsAndWidth(file);
                this.file = file;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.lineKeyword);
            writer.WriteValue(this.line);
            writer.WriteValue(this.file);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new LineDirectiveTriviaSyntax().ctor_1094(r);
        }
    }

    export class PragmaWarningDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        pragmaKeyword: SyntaxToken;
        warningKeyword: SyntaxToken;
        disableOrRestoreKeyword: SyntaxToken;
        errorCodes: CSharpSyntaxNode;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_1823(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: CSharpSyntaxNode, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PragmaWarningDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
            this.disableOrRestoreKeyword = disableOrRestoreKeyword;
            if (errorCodes != null) {
                this.AdjustFlagsAndWidth(errorCodes);
                this.errorCodes = errorCodes;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1913(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: CSharpSyntaxNode, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): PragmaWarningDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
            this.disableOrRestoreKeyword = disableOrRestoreKeyword;
            if (errorCodes != null) {
                this.AdjustFlagsAndWidth(errorCodes);
                this.errorCodes = errorCodes;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1755(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: CSharpSyntaxNode, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaWarningDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
            this.disableOrRestoreKeyword = disableOrRestoreKeyword;
            if (errorCodes != null) {
                this.AdjustFlagsAndWidth(errorCodes);
                this.errorCodes = errorCodes;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get PragmaKeyword(): SyntaxToken { return this.pragmaKeyword; }
        public get WarningKeyword(): SyntaxToken { return this.warningKeyword; }
        public get DisableOrRestoreKeyword(): SyntaxToken { return this.disableOrRestoreKeyword; }
        public get ErrorCodes(): SeparatedSyntaxList<ExpressionSyntax> { return new SeparatedSyntaxList<ExpressionSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.errorCodes)); }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.pragmaKeyword;
                case 2: return this.warningKeyword;
                case 3: return this.disableOrRestoreKeyword;
                case 4: return this.errorCodes;
                case 5: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax().ctor_7374(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitPragmaWarningDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitPragmaWarningDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, warningKeyword: SyntaxToken, disableOrRestoreKeyword: SyntaxToken, errorCodes: SeparatedSyntaxList<ExpressionSyntax>, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaWarningDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || warningKeyword != this.WarningKeyword || disableOrRestoreKeyword != this.DisableOrRestoreKeyword || errorCodes != this.ErrorCodes || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.PragmaWarningDirectiveTrivia(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new PragmaWarningDirectiveTriviaSyntax().ctor_1823(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new PragmaWarningDirectiveTriviaSyntax().ctor_1823(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_1991(reader: Roslyn.Utilities.ObjectReader): PragmaWarningDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 6;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var pragmaKeyword = <SyntaxToken>reader.ReadValue();
            if (pragmaKeyword != null) {
                this.AdjustFlagsAndWidth(pragmaKeyword);
                this.pragmaKeyword = pragmaKeyword;
                return this;
            }
            var warningKeyword = <SyntaxToken>reader.ReadValue();
            if (warningKeyword != null) {
                this.AdjustFlagsAndWidth(warningKeyword);
                this.warningKeyword = warningKeyword;
                return this;
            }
            var disableOrRestoreKeyword = <SyntaxToken>reader.ReadValue();
            if (disableOrRestoreKeyword != null) {
                this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
                this.disableOrRestoreKeyword = disableOrRestoreKeyword;
                return this;
            }
            var errorCodes = <CSharpSyntaxNode>reader.ReadValue();
            if (errorCodes != null) {
                this.AdjustFlagsAndWidth(errorCodes);
                this.errorCodes = errorCodes;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.pragmaKeyword);
            writer.WriteValue(this.warningKeyword);
            writer.WriteValue(this.disableOrRestoreKeyword);
            writer.WriteValue(this.errorCodes);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new PragmaWarningDirectiveTriviaSyntax().ctor_1991(r);
        }
    }

    export class PragmaChecksumDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        pragmaKeyword: SyntaxToken;
        checksumKeyword: SyntaxToken;
        file: SyntaxToken;
        guid: SyntaxToken;
        bytes: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_4505(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): PragmaChecksumDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(checksumKeyword);
            this.checksumKeyword = checksumKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(guid);
            this.guid = guid;
            this.AdjustFlagsAndWidth(bytes);
            this.bytes = bytes;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1957(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): PragmaChecksumDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(checksumKeyword);
            this.checksumKeyword = checksumKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(guid);
            this.guid = guid;
            this.AdjustFlagsAndWidth(bytes);
            this.bytes = bytes;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1214(kind: SyntaxKind, hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaChecksumDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(checksumKeyword);
            this.checksumKeyword = checksumKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(guid);
            this.guid = guid;
            this.AdjustFlagsAndWidth(bytes);
            this.bytes = bytes;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get PragmaKeyword(): SyntaxToken { return this.pragmaKeyword; }
        public get ChecksumKeyword(): SyntaxToken { return this.checksumKeyword; }
        public get File(): SyntaxToken { return this.file; }
        public get Guid(): SyntaxToken { return this.guid; }
        public get Bytes(): SyntaxToken { return this.bytes; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.pragmaKeyword;
                case 2: return this.checksumKeyword;
                case 3: return this.file;
                case 4: return this.guid;
                case 5: return this.bytes;
                case 6: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax().ctor_1261(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitPragmaChecksumDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitPragmaChecksumDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, pragmaKeyword: SyntaxToken, checksumKeyword: SyntaxToken, file: SyntaxToken, guid: SyntaxToken, bytes: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): PragmaChecksumDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || checksumKeyword != this.ChecksumKeyword || file != this.File || guid != this.Guid || bytes != this.Bytes || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.PragmaChecksumDirectiveTrivia(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new PragmaChecksumDirectiveTriviaSyntax().ctor_4505(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new PragmaChecksumDirectiveTriviaSyntax().ctor_4505(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_9866(reader: Roslyn.Utilities.ObjectReader): PragmaChecksumDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 7;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var pragmaKeyword = <SyntaxToken>reader.ReadValue();
            if (pragmaKeyword != null) {
                this.AdjustFlagsAndWidth(pragmaKeyword);
                this.pragmaKeyword = pragmaKeyword;
                return this;
            }
            var checksumKeyword = <SyntaxToken>reader.ReadValue();
            if (checksumKeyword != null) {
                this.AdjustFlagsAndWidth(checksumKeyword);
                this.checksumKeyword = checksumKeyword;
                return this;
            }
            var file = <SyntaxToken>reader.ReadValue();
            if (file != null) {
                this.AdjustFlagsAndWidth(file);
                this.file = file;
                return this;
            }
            var guid = <SyntaxToken>reader.ReadValue();
            if (guid != null) {
                this.AdjustFlagsAndWidth(guid);
                this.guid = guid;
                return this;
            }
            var bytes = <SyntaxToken>reader.ReadValue();
            if (bytes != null) {
                this.AdjustFlagsAndWidth(bytes);
                this.bytes = bytes;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.pragmaKeyword);
            writer.WriteValue(this.checksumKeyword);
            writer.WriteValue(this.file);
            writer.WriteValue(this.guid);
            writer.WriteValue(this.bytes);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new PragmaChecksumDirectiveTriviaSyntax().ctor_9866(r);
        }
    }

    export class ReferenceDirectiveTriviaSyntax extends DirectiveTriviaSyntax {
        hashToken: SyntaxToken;
        referenceKeyword: SyntaxToken;
        file: SyntaxToken;
        endOfDirectiveToken: SyntaxToken;
        isActive: boolean;

        constructor() { super(); }
        ctor_1740(kind: SyntaxKind, hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): ReferenceDirectiveTriviaSyntax {
            super.ctor_9467(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(referenceKeyword);
            this.referenceKeyword = referenceKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_1770(kind: SyntaxKind, hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean, context: SyntaxFactoryContext): ReferenceDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(referenceKeyword);
            this.referenceKeyword = referenceKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }


        ctor_7929(kind: SyntaxKind, hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ReferenceDirectiveTriviaSyntax {
            super.ctor_1539(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(referenceKeyword);
            this.referenceKeyword = referenceKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            return this;
        }

        public get HashToken(): SyntaxToken { return this.hashToken; }
        public get ReferenceKeyword(): SyntaxToken { return this.referenceKeyword; }
        public get File(): SyntaxToken { return this.file; }
        public get EndOfDirectiveToken(): SyntaxToken { return this.endOfDirectiveToken; }
        public get IsActive(): boolean { return this.isActive; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.hashToken;
                case 1: return this.referenceKeyword;
                case 2: return this.file;
                case 3: return this.endOfDirectiveToken;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.ReferenceDirectiveTriviaSyntax().ctor_1757(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitReferenceDirectiveTrivia(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitReferenceDirectiveTrivia(this);
        }

        public Update(hashToken: SyntaxToken, referenceKeyword: SyntaxToken, file: SyntaxToken, endOfDirectiveToken: SyntaxToken, isActive: boolean): ReferenceDirectiveTriviaSyntax {
            if (hashToken != this.HashToken || referenceKeyword != this.ReferenceKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken) {
                var newNode = SyntaxFactory.ReferenceDirectiveTrivia(hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new ReferenceDirectiveTriviaSyntax().ctor_1740(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new ReferenceDirectiveTriviaSyntax().ctor_1740(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, this.GetDiagnostics(), annotations);
        }

        public ctor_1030(reader: Roslyn.Utilities.ObjectReader): ReferenceDirectiveTriviaSyntax {
            super.ctor_1258(reader);
            this.SlotCount = 4;
            var hashToken = <SyntaxToken>reader.ReadValue();
            if (hashToken != null) {
                this.AdjustFlagsAndWidth(hashToken);
                this.hashToken = hashToken;
                return this;
            }
            var referenceKeyword = <SyntaxToken>reader.ReadValue();
            if (referenceKeyword != null) {
                this.AdjustFlagsAndWidth(referenceKeyword);
                this.referenceKeyword = referenceKeyword;
                return this;
            }
            var file = <SyntaxToken>reader.ReadValue();
            if (file != null) {
                this.AdjustFlagsAndWidth(file);
                this.file = file;
                return this;
            }
            var endOfDirectiveToken = <SyntaxToken>reader.ReadValue();
            if (endOfDirectiveToken != null) {
                this.AdjustFlagsAndWidth(endOfDirectiveToken);
                this.endOfDirectiveToken = endOfDirectiveToken;
                return this;
            }
            this.isActive = <boolean>reader.ReadBoolean();
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.referenceKeyword);
            writer.WriteValue(this.file);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new ReferenceDirectiveTriviaSyntax().ctor_1030(r);
        }
    }

    export class InterpolatedStringSyntax extends ExpressionSyntax {
        stringStart: SyntaxToken;
        interpolatedInserts: CSharpSyntaxNode;
        stringEnd: SyntaxToken;

        constructor() { super(); }
        ctor_7981(kind: SyntaxKind, stringStart: SyntaxToken, interpolatedInserts: CSharpSyntaxNode, stringEnd: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InterpolatedStringSyntax {
            super.ctor_1005(kind, diagnostics, annotations);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStart);
            this.stringStart = stringStart;
            if (interpolatedInserts != null) {
                this.AdjustFlagsAndWidth(interpolatedInserts);
                this.interpolatedInserts = interpolatedInserts;
            }
            this.AdjustFlagsAndWidth(stringEnd);
            this.stringEnd = stringEnd;
            return this;
        }


        ctor_8834(kind: SyntaxKind, stringStart: SyntaxToken, interpolatedInserts: CSharpSyntaxNode, stringEnd: SyntaxToken, context: SyntaxFactoryContext): InterpolatedStringSyntax {
            super.ctor_7190(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStart);
            this.stringStart = stringStart;
            if (interpolatedInserts != null) {
                this.AdjustFlagsAndWidth(interpolatedInserts);
                this.interpolatedInserts = interpolatedInserts;
            }
            this.AdjustFlagsAndWidth(stringEnd);
            this.stringEnd = stringEnd;
            return this;
        }


        ctor_2113(kind: SyntaxKind, stringStart: SyntaxToken, interpolatedInserts: CSharpSyntaxNode, stringEnd: SyntaxToken): InterpolatedStringSyntax {
            super.ctor_7190(kind);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStart);
            this.stringStart = stringStart;
            if (interpolatedInserts != null) {
                this.AdjustFlagsAndWidth(interpolatedInserts);
                this.interpolatedInserts = interpolatedInserts;
            }
            this.AdjustFlagsAndWidth(stringEnd);
            this.stringEnd = stringEnd;
            return this;
        }

        public get StringStart(): SyntaxToken { return this.stringStart; }
        public get InterpolatedInserts(): SeparatedSyntaxList<InterpolatedStringInsertSyntax> { return new SeparatedSyntaxList<InterpolatedStringInsertSyntax>().ctor_9176(new SyntaxList<CSharpSyntaxNode>().ctor_1319(this.interpolatedInserts)); }
        public get StringEnd(): SyntaxToken { return this.stringEnd; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.stringStart;
                case 1: return this.interpolatedInserts;
                case 2: return this.stringEnd;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.InterpolatedStringSyntax().ctor_1690(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitInterpolatedString(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitInterpolatedString(this);
        }

        public Update(stringStart: SyntaxToken, interpolatedInserts: SeparatedSyntaxList<InterpolatedStringInsertSyntax>, stringEnd: SyntaxToken): InterpolatedStringSyntax {
            if (stringStart != this.StringStart || interpolatedInserts != this.InterpolatedInserts || stringEnd != this.StringEnd) {
                var newNode = SyntaxFactory.InterpolatedString(stringStart, interpolatedInserts, stringEnd);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new InterpolatedStringSyntax().ctor_7981(this.Kind, this.stringStart, this.interpolatedInserts, this.stringEnd, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new InterpolatedStringSyntax().ctor_7981(this.Kind, this.stringStart, this.interpolatedInserts, this.stringEnd, this.GetDiagnostics(), annotations);
        }

        public ctor_1417(reader: Roslyn.Utilities.ObjectReader): InterpolatedStringSyntax {
            super.ctor_1102(reader);
            this.SlotCount = 3;
            var stringStart = <SyntaxToken>reader.ReadValue();
            if (stringStart != null) {
                this.AdjustFlagsAndWidth(stringStart);
                this.stringStart = stringStart;
                return this;
            }
            var interpolatedInserts = <CSharpSyntaxNode>reader.ReadValue();
            if (interpolatedInserts != null) {
                this.AdjustFlagsAndWidth(interpolatedInserts);
                this.interpolatedInserts = interpolatedInserts;
                return this;
            }
            var stringEnd = <SyntaxToken>reader.ReadValue();
            if (stringEnd != null) {
                this.AdjustFlagsAndWidth(stringEnd);
                this.stringEnd = stringEnd;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.stringStart);
            writer.WriteValue(this.interpolatedInserts);
            writer.WriteValue(this.stringEnd);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new InterpolatedStringSyntax().ctor_1417(r);
        }
    }

    export class InterpolatedStringInsertSyntax extends CSharpSyntaxNode {
        expression: ExpressionSyntax;
        comma: SyntaxToken;
        alignment: ExpressionSyntax;
        format: SyntaxToken;

        constructor() { super(); }
        ctor_1139(kind: SyntaxKind, expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken, diagnostics: DiagnosticInfo[], annotations: SyntaxAnnotation[]): InterpolatedStringInsertSyntax {
            super.ctor_1757(kind, diagnostics, annotations);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (comma != null) {
                this.AdjustFlagsAndWidth(comma);
                this.comma = comma;
            }
            if (alignment != null) {
                this.AdjustFlagsAndWidth(alignment);
                this.alignment = alignment;
            }
            if (format != null) {
                this.AdjustFlagsAndWidth(format);
                this.format = format;
            }
            return this;
        }


        ctor_2595(kind: SyntaxKind, expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken, context: SyntaxFactoryContext): InterpolatedStringInsertSyntax {
            super.ctor_1907(kind);
            this.SetFactoryContext_9638(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (comma != null) {
                this.AdjustFlagsAndWidth(comma);
                this.comma = comma;
            }
            if (alignment != null) {
                this.AdjustFlagsAndWidth(alignment);
                this.alignment = alignment;
            }
            if (format != null) {
                this.AdjustFlagsAndWidth(format);
                this.format = format;
            }
            return this;
        }


        ctor_7483(kind: SyntaxKind, expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken): InterpolatedStringInsertSyntax {
            super.ctor_1907(kind);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (comma != null) {
                this.AdjustFlagsAndWidth(comma);
                this.comma = comma;
            }
            if (alignment != null) {
                this.AdjustFlagsAndWidth(alignment);
                this.alignment = alignment;
            }
            if (format != null) {
                this.AdjustFlagsAndWidth(format);
                this.format = format;
            }
            return this;
        }

        public get Expression(): ExpressionSyntax { return this.expression; }
        public get Comma(): SyntaxToken { return this.comma; }
        public get Alignment(): ExpressionSyntax { return this.alignment; }
        public get Format(): SyntaxToken { return this.format; }

        public GetSlot(index: number): GreenNode {
            switch (index) {
                case 0: return this.expression;
                case 1: return this.comma;
                case 2: return this.alignment;
                case 3: return this.format;
                default: return null;
            }
        }

        public CreateRed_9614(parent: SyntaxNode, position: number): SyntaxNode {
            return new CSharp.Syntax.InterpolatedStringInsertSyntax().ctor_1720(this, parent, position);
        }

        public Accept_1388<TResult>(visitor: CSharpSyntaxVisitor<TResult>): TResult {
            return visitor.VisitInterpolatedStringInsert(this);
        }

        public Accept_1012(visitor: CSharpSyntaxVisitorBase): void {
            visitor.VisitInterpolatedStringInsert(this);
        }

        public Update(expression: ExpressionSyntax, comma: SyntaxToken, alignment: ExpressionSyntax, format: SyntaxToken): InterpolatedStringInsertSyntax {
            if (expression != this.Expression || comma != this.Comma || alignment != this.Alignment || format != this.Format) {
                var newNode = SyntaxFactory.InterpolatedStringInsert(expression, comma, alignment, format);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithDiagnosticsGreen(newNode, diags);
                var annotations = this.GetAnnotations_1741();
                if (annotations != null && annotations.Length > 0)
                    newNode = CodeAnalysis.GreenNodeExtensions.WithAnnotationsGreen(newNode, annotations);
                return newNode;
            }

            return this;
        }

        public SetDiagnostics(diagnostics: DiagnosticInfo[]): GreenNode {
            return new InterpolatedStringInsertSyntax().ctor_1139(this.Kind, this.expression, this.comma, this.alignment, this.format, diagnostics, this.GetAnnotations_1741());
        }

        public SetAnnotations(annotations: SyntaxAnnotation[]): GreenNode {
            return new InterpolatedStringInsertSyntax().ctor_1139(this.Kind, this.expression, this.comma, this.alignment, this.format, this.GetDiagnostics(), annotations);
        }

        public ctor_1109(reader: Roslyn.Utilities.ObjectReader): InterpolatedStringInsertSyntax {
            super.ctor_4942(reader);
            this.SlotCount = 4;
            var expression = <ExpressionSyntax>reader.ReadValue();
            if (expression != null) {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
                return this;
            }
            var comma = <SyntaxToken>reader.ReadValue();
            if (comma != null) {
                this.AdjustFlagsAndWidth(comma);
                this.comma = comma;
                return this;
            }
            var alignment = <ExpressionSyntax>reader.ReadValue();
            if (alignment != null) {
                this.AdjustFlagsAndWidth(alignment);
                this.alignment = alignment;
                return this;
            }
            var format = <SyntaxToken>reader.ReadValue();
            if (format != null) {
                this.AdjustFlagsAndWidth(format);
                this.format = format;
                return this;
            }
        }

        public WriteTo_2123(writer: Roslyn.Utilities.ObjectWriter): void {
            super.WriteTo_2123(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.comma);
            writer.WriteValue(this.alignment);
            writer.WriteValue(this.format);
        }

        public GetReader(): (_: Roslyn.Utilities.ObjectReader) => Object {
            return r => new InterpolatedStringInsertSyntax().ctor_1109(r);
        }
    }
}
