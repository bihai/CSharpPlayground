module Microsoft.CodeAnalysis.CSharp {
    export class CSharpResources {

        public static CantReferenceCompilationOf = "Can't reference compilation of type '{0}' from {1} compilation.";
        public static ChainingSpeculativeModelIsNotSupported = "Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.";
        public static CompilationC = "Compilation (C#):";
        public static ElementIsExpected = "element is expected";
        public static ElementsCannotBeNull = "Elements cannot be null.";
        public static ERR_AbstractAndExtern = "'{0}' cannot be both extern and abstract";
        public static ERR_AbstractAndSealed = "'{0}' cannot be both abstract and sealed";
        public static ERR_AbstractAttributeClass = "Cannot apply attribute class '{0}' because it is abstract";
        public static ERR_AbstractBaseCall = "Cannot call an abstract base member: '{0}'";
        public static ERR_AbstractEventInitializer = "'{0}': abstract event cannot have initializer";
        public static ERR_AbstractField = "The modifier 'abstract' is not valid on fields. Try using a property instead.";
        public static ERR_AbstractHasBody = "'{0}' cannot declare a body because it is marked abstract";
        public static ERR_AbstractInConcreteClass = "'{0}' is abstract but it is contained in non-abstract class '{1}'";
        public static ERR_AbstractNotVirtual = "The abstract method '{0}' cannot be marked virtual";
        public static ERR_AbstractSealedStatic = "'{0}': an abstract class cannot be sealed or static";
        public static ERR_AccessModMissingAccessor = "'{0}': accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor";
        public static ERR_AccessorImplementingMethod = "Accessor '{0}' cannot implement interface member '{1}' for type '{2}'. Use an explicit interface implementation.";
        public static ERR_AccessorListAndExpressionBody = "Properties cannot combine accessor lists with expression bodies.";
        public static ERR_AddModuleAssembly = "'{0}' cannot be added to this assembly because it already is an assembly";
        public static ERR_AddOrRemoveExpected = "An add or remove accessor expected";
        public static ERR_AddRemoveMustHaveBody = "An add or remove accessor must have a body";
        public static ERR_AddrOnReadOnlyLocal = "Cannot take the address of a read-only local variable";
        public static ERR_AgnosticToMachineModule = "Agnostic assembly cannot have a processor specific module '{0}'.";
        public static ERR_AliasMissingFile = "Invalid reference alias option: '{0}=' -- missing filename";
        public static ERR_AliasNotFound = "Alias '{0}' not found";
        public static ERR_AliasQualAsExpression = "The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.";
        public static ERR_AliasQualifiedNameNotAnExpression = "An alias-qualified name is not an expression.";
        public static ERR_AmbigBinaryOps = "Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'";
        public static ERR_AmbigCall = "The call is ambiguous between the following methods or properties: '{0}' and '{1}'";
        public static ERR_AmbigContext = "'{0}' is an ambiguous reference between '{1}' and '{2}'";
        public static ERR_AmbigMember = "Ambiguity between '{0}' and '{1}'";
        public static ERR_AmbigousAttribute = "'{0}' is ambiguous between '{1}' and '{2}'; use either '@{0}' or '{0}Attribute'";
        public static ERR_AmbigOverride = "The inherited members '{0}' and '{1}' have the same signature in type '{2}', so they cannot be overridden";
        public static ERR_AmbigQM = "Type of conditional expression cannot be determined because '{0}' and '{1}' implicitly convert to one another";
        public static ERR_AmbigUDConv = "Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'";
        public static ERR_AmbigUnaryOp = "Operator '{0}' is ambiguous on an operand of type '{1}'";
        public static ERR_AnonDelegateCantUse = "Cannot use ref or out parameter '{0}' inside an anonymous method, lambda expression, or query expression";
        public static ERR_AnonMethGrpInForEach = "Foreach cannot operate on a '{0}'. Did you intend to invoke the '{0}'?";
        public static ERR_AnonMethToNonDel = "Cannot convert {0} to type '{1}' because it is not a delegate type";
        public static ERR_AnonymousMethodToExpressionTree = "An anonymous method expression cannot be converted to an expression tree";
        public static ERR_AnonymousReturnExpected = "Not all code paths return a value in {0} of type '{1}'";
        public static ERR_AnonymousTypeDuplicatePropertyName = "An anonymous type cannot have multiple properties with the same name";
        public static ERR_AnonymousTypeNotAvailable = "Cannot use anonymous type in a constant expression";
        public static ERR_AnonymousTypePropertyAssignedBadValue = "Cannot assign {0} to anonymous type property";
        public static ERR_ArgsInvalid = "The __arglist construct is valid only within a variable argument method";
        public static ERR_ArrayElementCantBeRefAny = "Array elements cannot be of type '{0}'";
        public static ERR_ArrayInitializerExpected = "A nested array initializer is expected";
        public static ERR_ArrayInitializerIncorrectLength = "An array initializer of length '{0}' is expected";
        public static ERR_ArrayInitInBadPlace = "Array initializers can only be used in a variable or field initializer. Try using a new expression instead.";
        public static ERR_ArrayInitToNonArrayType = "Can only use array initializer expressions to assign to array types. Try using a new expression instead.";
        public static ERR_ArrayOfStaticClass = "'{0}': array elements cannot be of static type";
        public static ERR_ArraySizeInDeclaration = "Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)";
        public static ERR_AsMustHaveReferenceType = "The as operator must be used with a reference type or nullable type ('{0}' is a non-nullable value type)";
        public static ERR_AssemblyMatchBadVersion = "Assembly '{0}' with identity '{1}' uses '{2}' which has a higher version than referenced assembly '{3}' with identity '{4}'";
        public static ERR_AssemblyNameOnNonModule = "The /moduleassemblyname option may only be specified when building a target type of 'module'";
        public static ERR_AssemblySpecifiedForLinkAndRef = "Assemblies '{0}' and '{1}' refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references.";
        public static ERR_AssgLvalueExpected = "The left-hand side of an assignment must be a variable, property or indexer";
        public static ERR_AssgReadonly = "A readonly field cannot be assigned to (except in a constructor or a variable initializer)";
        public static ERR_AssgReadonly2 = "Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)";
        public static ERR_AssgReadonlyLocal = "Cannot assign to '{0}' because it is read-only";
        public static ERR_AssgReadonlyLocal2Cause = "Cannot modify members of '{0}' because it is a '{1}'";
        public static ERR_AssgReadonlyLocalCause = "Cannot assign to '{0}' because it is a '{1}'";
        public static ERR_AssgReadonlyProp = "Property or indexer '{0}' cannot be assigned to -- it is read only";
        public static ERR_AssgReadonlyStatic = "A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)";
        public static ERR_AssgReadonlyStatic2 = "Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)";
        public static ERR_AsWithTypeVar = "The type parameter '{0}' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint";
        public static ERR_AttrArgWithTypeVars = "'{0}': an attribute argument cannot use type parameters";
        public static ERR_AttributeCantBeGeneric = "Cannot apply attribute class '{0}' because it is generic";
        public static ERR_AttributeNotOnAccessor = "Attribute '{0}' is not valid on property or event accessors. It is only valid on '{1}' declarations.";
        public static ERR_AttributeOnBadSymbolType = "Attribute '{0}' is not valid on this declaration type. It is only valid on '{1}' declarations.";
        public static ERR_AttributeParameterRequired1 = "Attribute parameter '{0}' must be specified.";
        public static ERR_AttributeParameterRequired2 = "Attribute parameter '{0}' or '{1}' must be specified.";
        public static ERR_AttributesNotAllowed = "Attributes are not valid in this context.";
        public static ERR_AttributeUsageOnNonAttributeClass = "Attribute '{0}' is only valid on classes derived from System.Attribute";
        public static ERR_AutoPropertyInitializerInInterface = "Auto-implemented properties inside interfaces cannot have initializers.";
        public static ERR_AutoPropertyMustHaveGetAccessor = "Auto-implemented properties must have get accessors.";
        public static ERR_AutoPropertyMustOverrideSet = "Auto-implemented properties must override all accessors of the overridden property.";
        public static ERR_AwaitInUnsafeContext = "Cannot await in an unsafe context";
        public static ERR_BadAccess = "'{0}' is inaccessible due to its protection level";
        public static ERR_BadAppConfigPath = "AppConfigPath must be absolute.";
        public static ERR_BadArgCount = "No overload for method '{0}' takes {1} arguments";
        public static ERR_BadArgExtraRef = "Argument {0} should not be passed with the '{1}' keyword";
        public static ERR_BadArgRef = "Argument {0} must be passed with the '{1}' keyword";
        public static ERR_BadArgType = "Argument {0}: cannot convert from '{1}' to '{2}'";
        public static ERR_BadArgTypeDynamicExtension = "'{0}' has no applicable method named '{1}' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.";
        public static ERR_BadArgTypesForCollectionAdd = "The best overloaded Add method '{0}' for the collection initializer has some invalid arguments";
        public static ERR_BadArgumentToAttribute = "The argument to the '{0}' attribute must be a valid identifier";
        public static ERR_BadArity = "Using the generic {1} '{0}' requires {2} type arguments";
        public static ERR_BadArraySyntax = "Array type specifier, [], must appear before parameter name";
        public static ERR_BadAsyncArgType = "Async methods cannot have ref or out parameters";
        public static ERR_BadAsyncExpressionTree = "Async lambda expressions cannot be converted to expression trees";
        public static ERR_BadAsyncLacksBody = "The 'async' modifier can only be used in methods that have a statement body.";
        public static ERR_BadAsyncReturn = "The return type of an async method must be void, Task or Task<T>";
        public static ERR_BadAsyncReturnExpression = "Since this is an async method, the return expression must be of type '{0}' rather than 'Task<{0}>'";
        public static ERR_BadAttributeArgument = "An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type";
        public static ERR_BadAttributeParamDefaultArgument = "Attribute constructor parameter '{0}' is optional, but no default parameter value was specified.";
        public static ERR_BadAttributeParamType = "Attribute constructor parameter '{0}' has type '{1}', which is not a valid attribute parameter type";
        public static ERR_BadAwaitArg = "'await' requires that the type {0} have a suitable GetAwaiter method";
        public static ERR_BadAwaitArg_NeedSystem = "'await' requires that the type '{0}' have a suitable GetAwaiter method. Are you missing a using directive for 'System'?";
        public static ERR_BadAwaitArgIntrinsic = "Cannot await '{0}'";
        public static ERR_BadAwaitArgVoidCall = "Cannot await 'void'";
        public static ERR_BadAwaitAsIdentifier = "'await' cannot be used as an identifier within an async method or lambda expression";
        public static ERR_BadAwaiterPattern = "'await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable IsCompleted, OnCompleted, and GetResult members, and implement INotifyCompletion or ICriticalNotifyCompletion";
        public static ERR_BadAwaitInCatch = "Cannot await in a catch clause";
        public static ERR_BadAwaitInCatchFilter = "Cannot await in the filter expression of a catch clause";
        public static ERR_BadAwaitInFinally = "Cannot await in the body of a finally clause";
        public static ERR_BadAwaitInLock = "Cannot await in the body of a lock statement";
        public static ERR_BadAwaitInQuery = "The 'await' operator may only be used in a query expression within the first collection expression of the initial 'from' clause or within the collection expression of a 'join' clause";
        public static ERR_BadAwaitWithoutAsync = "The 'await' operator can only be used when contained within a method or lambda expression marked with the 'async' modifier";
        public static ERR_BadAwaitWithoutAsyncLambda = "The 'await' operator can only be used within an async {0}. Consider marking this {0} with the 'async' modifier.";
        public static ERR_BadAwaitWithoutAsyncMethod = "The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task<{0}>'.";
        public static ERR_BadAwaitWithoutVoidAsyncMethod = "The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.";
        public static ERR_BadBaseNumber = "Invalid image base number '{0}'";
        public static ERR_BadBaseType = "Invalid base type";
        public static ERR_BadBinaryOperatorSignature = "One of the parameters of a binary operator must be the containing type";
        public static ERR_BadBinaryOps = "Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'";
        public static ERR_BadBinOpArgs = "Overloaded binary operator '{0}' takes two parameters";
        public static ERR_BadBoolOp = "In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type and parameter types";
        public static ERR_BadBoundType = "'{0}' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.";
        public static ERR_BadCallerFilePathParamWithoutDefaultValue = "The CallerFilePathAttribute may only be applied to parameters with default values";
        public static ERR_BadCallerLineNumberParamWithoutDefaultValue = "The CallerLineNumberAttribute may only be applied to parameters with default values";
        public static ERR_BadCallerMemberNameParamWithoutDefaultValue = "The CallerMemberNameAttribute may only be applied to parameters with default values";
        public static ERR_BadCastInFixed = "The right hand side of a fixed statement assignment may not be a cast expression";
        public static ERR_BadCoClassSig = "The managed coclass wrapper class signature '{0}' for interface '{1}' is not a valid class name signature";
        public static ERR_BadCompatMode = "Invalid option '{0}' for /langversion; must be ISO-1, ISO-2, Default or an integer in range 1 to 6.";
        public static ERR_BadCompilationOption = "{0}";
        public static ERR_BadCompilationOptionValue = "Invalid '{0}' value: '{1}'.";
        public static ERR_BadConstraintType = "Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.";
        public static ERR_BadConstType = "The type '{0}' cannot be declared const";
        public static ERR_BadCtorArgCount = "'{0}' does not contain a constructor that takes {1} arguments";
        public static ERR_BadDebugType = "Invalid option '{0}' for /debug; must be full or pdbonly";
        public static ERR_BadDelArgCount = "Delegate '{0}' does not take {1} arguments";
        public static ERR_BadDelegateConstructor = "The delegate '{0}' does not have a valid constructor";
        public static ERR_BadDelegateLeave = "Control cannot leave the body of an anonymous method or lambda expression";
        public static ERR_BadDestructorName = "Name of destructor must match name of class";
        public static ERR_BadDirectivePlacement = "Preprocessor directives must appear as the first non-whitespace character on a line";
        public static ERR_BadDynamicConversion = "'{0}': user-defined conversions to or from the dynamic type are not allowed";
        public static ERR_BadDynamicMethodArg = "Cannot use an expression of type '{0}' as an argument to a dynamically dispatched operation.";
        public static ERR_BadDynamicMethodArgLambda = "Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.";
        public static ERR_BadDynamicMethodArgMemgrp = "Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?";
        public static ERR_BadDynamicQuery = "Query expressions over source type 'dynamic' or with a join sequence of type 'dynamic' are not allowed";
        public static ERR_BadDynamicTypeof = "The typeof operator cannot be used on the dynamic type";
        public static ERR_BadEmbeddedStmt = "Embedded statement cannot be a declaration or labeled statement";
        public static ERR_BadEmptyThrow = "A throw statement with no arguments is not allowed outside of a catch clause";
        public static ERR_BadEmptyThrowInFinally = "A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause";
        public static ERR_BadEventUsage = "The event '{0}' can only appear on the left hand side of += or -= (except when used from within the type '{1}')";
        public static ERR_BadEventUsageNoField = "The event '{0}' can only appear on the left hand side of += or -=";
        public static ERR_BadExceptionType = "The type caught or thrown must be derived from System.Exception";
        public static ERR_BadExtensionAgg = "Extension method must be defined in a non-generic static class";
        public static ERR_BadExtensionArgTypes = "'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' has some invalid arguments";
        public static ERR_BadExtensionMeth = "Extension method must be static";
        public static ERR_BadExternAlias = "The extern alias '{0}' was not specified in a /reference option";
        public static ERR_BadExternIdentifier = "Invalid extern alias for '/reference'; '{0}' is not a valid identifier";
        public static ERR_BadFinallyLeave = "Control cannot leave the body of a finally clause";
        public static ERR_BadFixedInitType = "The type of a local declared in a fixed statement must be a pointer type";
        public static ERR_BadForeachDecl = "Type and identifier are both required in a foreach statement";
        public static ERR_BadGetEnumerator = "foreach requires that the return type '{0}' of '{1}' must have a suitable public MoveNext method and public Current property";
        public static ERR_BadIncDecRetType = "The return type for ++ or -- operator must match the parameter type or be derived from the parameter type";
        public static ERR_BadIncDecSignature = "The parameter type for ++ or -- operator must be the containing type";
        public static ERR_BadIndexCount = "Wrong number of indices inside []; expected {0}";
        public static ERR_BadIndexerNameAttr = "The '{0}' attribute is valid only on an indexer that is not an explicit interface member declaration";
        public static ERR_BadIndexLHS = "Cannot apply indexing with [] to an expression of type '{0}'";
        public static ERR_BadInstanceArgType = "'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' requires a receiver of type '{3}'";
        public static ERR_BadIteratorArgType = "Iterators cannot have ref or out parameters";
        public static ERR_BadIteratorReturn = "The body of '{0}' cannot be an iterator block because '{1}' is not an iterator interface type";
        public static ERR_BadMemberFlag = "The modifier '{0}' is not valid for this item";
        public static ERR_BadMemberProtection = "More than one protection modifier";
        public static ERR_BadModifierLocation = "Member modifier '{0}' must precede the member type and name";
        public static ERR_BadModifiersOnNamespace = "A namespace declaration cannot have modifiers or attributes";
        public static ERR_BadNamedArgument = "The best overload for '{0}' does not have a parameter named '{1}'";
        public static ERR_BadNamedArgumentForDelegateInvoke = "The delegate '{0}' does not have a parameter named '{1}'";
        public static ERR_BadNamedAttributeArgument = "'{0}' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static.";
        public static ERR_BadNamedAttributeArgumentType = "'{0}' is not a valid named attribute argument because it is not a valid attribute parameter type";
        public static ERR_BadNewExpr = "A new expression requires (), [], or {} after type";
        public static ERR_BadOperatorSyntax = "Declaration is not valid; use '{0} operator <dest-type> (...' instead";
        public static ERR_BadOutWithThis = "The parameter modifier 'out' cannot be used with 'this'";
        public static ERR_BadParamExtraRef = "Parameter {0} should not be declared with the '{1}' keyword";
        public static ERR_BadParamModThis = "A parameter array cannot be used with 'this' modifier on an extension method";
        public static ERR_BadParamRef = "Parameter {0} must be declared with the '{1}' keyword";
        public static ERR_BadParamType = "Parameter {0} is declared as type '{1}{2}' but should be '{3}{4}'";
        public static ERR_BadPlatformType = "Invalid option '{0}' for /platform; must be anycpu, x86, Itanium or x64";
        public static ERR_BadPrefer32OnLib = "/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe";
        public static ERR_BadProtectedAccess = "Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)";
        public static ERR_BadRefWithThis = "The parameter modifier 'ref' cannot be used with 'this'";
        public static ERR_BadResourceVis = "Invalid option '{0}'; Resource visibility must be either 'public' or 'private'";
        public static ERR_BadRetType = "'{1} {0}' has the wrong return type";
        public static ERR_BadShiftOperatorSignature = "The first operand of an overloaded shift operator must have the same type as the containing type, and the type of the second operand must be int";
        public static ERR_BadSKknown = "'{0}' is a {1} but is used like a {2}";
        public static ERR_BadSKunknown = "'{0}' is a {1}, which is not valid in the given context";
        public static ERR_BadSpecialByRefLocal = "Parameters or locals of type '{0}' cannot be declared in async methods or lambda expressions.";
        public static ERR_BadStackAllocExpr = "A stackalloc expression requires [] after type";
        public static ERR_BadSwitch = "Unrecognized option: '{0}'";
        public static ERR_BadThisParam = "Method '{0}' has a parameter modifier 'this' which is not on the first parameter";
        public static ERR_BadTypeArgument = "The type '{0}' may not be used as a type argument";
        public static ERR_BadTypeforThis = "The first parameter of an extension method cannot be of type '{0}'";
        public static ERR_BadTypeReference = "'{0}': cannot reference a type through an expression; try '{1}' instead";
        public static ERR_BadUnaryOp = "Operator '{0}' cannot be applied to operand of type '{1}'";
        public static ERR_BadUnaryOperatorSignature = "The parameter of a unary operator must be the containing type";
        public static ERR_BadUnOpArgs = "Overloaded unary operator '{0}' takes one parameter";
        public static ERR_BadUsingNamespace = "A 'using namespace' directive can only be applied to namespaces; '{0}' is a type not a namespace. Consider a 'using static' directive instead";
        public static ERR_BadUsingType = "A 'using static' directive can only be applied to types; '{0}' is a namespace not a type. Consider a 'using namespace' directive instead";
        public static ERR_BadVarargs = "A method with vararg cannot be generic, be in a generic type, or have a params parameter";
        public static ERR_BadVarDecl = "Expected ; or = (cannot specify constructor arguments in declaration)";
        public static ERR_BadVisBaseClass = "Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'";
        public static ERR_BadVisBaseInterface = "Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'";
        public static ERR_BadVisBound = "Inconsistent accessibility: constraint type '{1}' is less accessible than '{0}'";
        public static ERR_BadVisDelegateParam = "Inconsistent accessibility: parameter type '{1}' is less accessible than delegate '{0}'";
        public static ERR_BadVisDelegateReturn = "Inconsistent accessibility: return type '{1}' is less accessible than delegate '{0}'";
        public static ERR_BadVisEventType = "Inconsistent accessibility: event type '{1}' is less accessible than event '{0}'";
        public static ERR_BadVisFieldType = "Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'";
        public static ERR_BadVisIndexerParam = "Inconsistent accessibility: parameter type '{1}' is less accessible than indexer '{0}'";
        public static ERR_BadVisIndexerReturn = "Inconsistent accessibility: indexer return type '{1}' is less accessible than indexer '{0}'";
        public static ERR_BadVisOpParam = "Inconsistent accessibility: parameter type '{1}' is less accessible than operator '{0}'";
        public static ERR_BadVisOpReturn = "Inconsistent accessibility: return type '{1}' is less accessible than operator '{0}'";
        public static ERR_BadVisParamType = "Inconsistent accessibility: parameter type '{1}' is less accessible than method '{0}'";
        public static ERR_BadVisPropertyType = "Inconsistent accessibility: property type '{1}' is less accessible than property '{0}'";
        public static ERR_BadVisReturnType = "Inconsistent accessibility: return type '{1}' is less accessible than method '{0}'";
        public static ERR_BadWarningLevel = "Warning level must be in the range 0-4";
        public static ERR_BadWin32Res = "Error reading Win32 resources -- {0}";
        public static ERR_BadYieldInCatch = "Cannot yield a value in the body of a catch clause";
        public static ERR_BadYieldInFinally = "Cannot yield in the body of a finally clause";
        public static ERR_BadYieldInTryOfCatch = "Cannot yield a value in the body of a try block with a catch clause";
        public static ERR_BaseClassMustBeFirst = "Base class '{0}' must come before any interfaces";
        public static ERR_BaseConstraintConflict = "Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'";
        public static ERR_BaseIllegal = "Use of keyword 'base' is not valid in this context";
        public static ERR_BaseInBadContext = "Keyword 'base' is not available in the current context";
        public static ERR_BaseInStaticMeth = "Keyword 'base' is not available in a static method";
        public static ERR_BinaryFile = "'{0}' is a binary file instead of a text file";
        public static ERR_BindToBogus = "'{0}' is not supported by the language";
        public static ERR_BindToBogusProp1 = "Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'";
        public static ERR_BindToBogusProp2 = "Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'";
        public static ERR_BlockBodyAndExpressionBody = "Methods cannot combine block bodies with expression bodies.";
        public static ERR_BogusExplicitImpl = "'{0}' cannot implement '{1}' because it is not supported by the language";
        public static ERR_BogusType = "'{0}' is a type not supported by the language";
        public static ERR_ByRefParameterInExpressionTree = "An expression tree lambda may not contain an out or ref parameter";
        public static ERR_ByRefReturnUnsupported = "By-reference return type 'ref {0}' is not supported.";
        public static ERR_ByRefTypeAndAwait = "'await' cannot be used in an expression containing the type '{0}'";
        public static ERR_CallingBaseFinalizeDeprecated = "Do not directly call your base class Finalize method. It is called automatically from your destructor.";
        public static ERR_CallingFinalizeDeprecated = "Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.";
        public static ERR_CannotPassNullForFriendAssembly = "Cannot pass null for friend assembly name";
        public static ERR_CantCallSpecialMethod = "'{0}': cannot explicitly call operator or accessor";
        public static ERR_CantChangeAccessOnOverride = "'{0}': cannot change access modifiers when overriding '{1}' inherited member '{2}'";
        public static ERR_CantChangeReturnTypeOnOverride = "'{0}': return type must be '{2}' to match overridden member '{1}'";
        public static ERR_CantChangeTypeOnOverride = "'{0}': type must be '{2}' to match overridden member '{1}'";
        public static ERR_CantConvAnonMethNoParams = "Cannot convert anonymous method block without a parameter list to delegate type '{0}' because it has one or more out parameters";
        public static ERR_CantConvAnonMethParams = "Cannot convert {0} to delegate type '{1}' because the parameter types do not match the delegate parameter types";
        public static ERR_CantConvAnonMethReturns = "Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type";
        public static ERR_CantConvAsyncAnonFuncReturns = "Cannot convert async {0} to delegate type '{1}'. An async {0} may return void, Task or Task<T>, none of which are convertible to '{1}'.";
        public static ERR_CantDeriveFromSealedType = "'{0}': cannot derive from sealed type '{1}'";
        public static ERR_CantHaveWin32ResAndIcon = "Conflicting options specified: Win32 resource file; Win32 icon";
        public static ERR_CantHaveWin32ResAndManifest = "Conflicting options specified: Win32 resource file; Win32 manifest";
        public static ERR_CantInferMethTypeArgs = "The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.";
        public static ERR_CantMakeTempFile = "Cannot create temporary file -- {0}";
        public static ERR_CantOpenFileWrite = "Cannot open '{0}' for writing -- '{1}'";
        public static ERR_CantOpenIcon = "Error opening icon file {0} -- {1}";
        public static ERR_CantOpenWin32Manifest = "Error opening Win32 manifest file {0} -- {1}";
        public static ERR_CantOpenWin32Res = "Error opening Win32 resource file '{0}' -- '{1}'";
        public static ERR_CantOverrideBogusMethod = "'{0}': cannot override '{1}' because it is not supported by the language";
        public static ERR_CantOverrideNonEvent = "'{0}': cannot override; '{1}' is not an event";
        public static ERR_CantOverrideNonFunction = "'{0}': cannot override because '{1}' is not a function";
        public static ERR_CantOverrideNonProperty = "'{0}': cannot override because '{1}' is not a property";
        public static ERR_CantOverrideNonVirtual = "'{0}': cannot override inherited member '{1}' because it is not marked virtual, abstract, or override";
        public static ERR_CantOverrideSealed = "'{0}': cannot override inherited member '{1}' because it is sealed";
        public static ERR_CantReadConfigFile = "Cannot read config file '{0}' -- '{1}'";
        public static ERR_CantReadResource = "Error reading resource '{0}' -- '{1}'";
        public static ERR_CantReadRulesetFile = "Error reading ruleset file {0} - {1}";
        public static ERR_CantRefResource = "Cannot link resource files when building a module";
        public static ERR_CantReturnVoid = "Cannot return an expression of type 'void'";
        public static ERR_CantSetWin32Manifest = "Error reading Win32 manifest file '{0}' -- '{1}'";
        public static ERR_CantUseRequiredAttribute = "The RequiredAttribute attribute is not permitted on C# types";
        public static ERR_CheckedOverflow = "The operation overflows at compile time in checked mode";
        public static ERR_CircConstValue = "The evaluation of the constant value for '{0}' involves a circular definition";
        public static ERR_CircularBase = "Circular base class dependency involving '{0}' and '{1}'";
        public static ERR_CircularConstraint = "Circular constraint dependency involving '{0}' and '{1}'";
        public static ERR_ClassBoundNotFirst = "The class type constraint '{0}' must come before any other constraints";
        public static ERR_ClassDoesntImplementInterface = "'{0}': containing type does not implement interface '{1}'";
        public static ERR_ClassTypeExpected = "An object, string, or class type expected";
        public static ERR_CloseParenExpected = ") expected";
        public static ERR_CloseUnimplementedInterfaceMemberNotPublic = "'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is not public.";
        public static ERR_CloseUnimplementedInterfaceMemberStatic = "'{0}' does not implement interface member '{1}'. '{2}' cannot implement an interface member because it is static.";
        public static ERR_CloseUnimplementedInterfaceMemberWrongReturnType = "'{0}' does not implement interface member '{1}'. '{2}' cannot implement '{1}' because it does not have the matching return type of '{3}'.";
        public static ERR_CmdOptionConflictsSource = "Attribute '{0}' given in a source file conflicts with option '{1}'.";
        public static ERR_ColColWithTypeAlias = "Cannot use alias '{0}' with '::' since the alias references a type. Use '.' instead.";
        public static ERR_CollectionInitRequiresIEnumerable = "Cannot initialize type '{0}' with a collection initializer because it does not implement 'System.Collections.IEnumerable'";
        public static ERR_ComImportWithBase = "'{0}': a class with the ComImport attribute cannot specify a base class";
        public static ERR_ComImportWithImpl = "Since '{1}' has the ComImport attribute, '{0}' must be extern or abstract";
        public static ERR_ComImportWithInitializers = "'{0}': a class with the ComImport attribute cannot specify field initializers.";
        public static ERR_ComImportWithoutUuidAttribute = "The Guid attribute must be specified with the ComImport attribute";
        public static ERR_ComImportWithUserCtor = "A class with the ComImport attribute cannot have a user-defined constructor";
        public static ERR_CompileCancelled = "Compilation cancelled by user";
        public static ERR_ComRefCallInExpressionTree = "An expression tree lambda may not contain a COM call with ref omitted on arguments";
        public static ERR_ConcreteMissingBody = "'{0}' must declare a body because it is not marked abstract, extern, or partial";
        public static ERR_ConditionalMustReturnVoid = "The Conditional attribute is not valid on '{0}' because its return type is not void";
        public static ERR_ConditionalOnInterfaceMethod = "The Conditional attribute is not valid on interface members";
        public static ERR_ConditionalOnNonAttributeClass = "Attribute '{0}' is only valid on methods or attribute classes";
        public static ERR_ConditionalOnOverride = "The Conditional attribute is not valid on '{0}' because it is an override method";
        public static ERR_ConditionalOnSpecialMethod = "The Conditional attribute is not valid on '{0}' because it is a constructor, destructor, operator, or explicit interface implementation";
        public static ERR_ConditionalWithOutParam = "Conditional member '{0}' cannot have an out parameter";
        public static ERR_ConflictAliasAndMember = "Namespace '{1}' contains a definition conflicting with alias '{0}'";
        public static ERR_ConflictingAliasAndDefinition = "Alias '{0}' conflicts with {1} definition";
        public static ERR_ConflictingMachineModule = "Assembly and module '{0}' cannot target different processors.";
        public static ERR_ConstantExpected = "A constant value is expected";
        public static ERR_ConstOutOfRange = "Constant value '{0}' cannot be converted to a '{1}'";
        public static ERR_ConstOutOfRangeChecked = "Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)";
        public static ERR_ConstraintIsStaticClass = "'{0}': static classes cannot be used as constraints";
        public static ERR_ConstraintOnlyAllowedOnGenericDecl = "Constraints are not allowed on non-generic declarations";
        public static ERR_ConstructedDynamicTypeAsBound = "Constraint cannot be a dynamic type '{0}'";
        public static ERR_ConstructorInStaticClass = "Static classes cannot have instance constructors";
        public static ERR_ConstValueRequired = "A const field requires a value to be provided";
        public static ERR_ConversionNotInvolvingContainedType = "User-defined conversion must convert to or from the enclosing type";
        public static ERR_ConversionWithBase = "'{0}': user-defined conversions to or from a base class are not allowed";
        public static ERR_ConversionWithDerived = "'{0}': user-defined conversions to or from a derived class are not allowed";
        public static ERR_ConversionWithInterface = "'{0}': user-defined conversions to or from an interface are not allowed";
        public static ERR_ConvertToStaticClass = "Cannot convert to static type '{0}'";
        public static ERR_ConWithValCon = "Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'";
        public static ERR_CryptoHashFailed = "Cryptographic failure while creating hashes.";
        public static ERR_CStyleArray = "Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.";
        public static ERR_CycleInInterfaceInheritance = "Inherited interface '{1}' causes a cycle in the interface hierarchy of '{0}'";
        public static ERR_CycleInTypeForwarder = "The type forwarder for type '{0}' in assembly '{1}' causes a cycle";
        public static ERR_DecConstError = "Evaluation of the decimal constant expression failed";
        public static ERR_DefaultMemberOnIndexedType = "Cannot specify the DefaultMember attribute on a type containing an indexer";
        public static ERR_DefaultValueBadValueType = "Argument of type '{0}' is not applicable for the DefaultParameterValue attribute";
        public static ERR_DefaultValueBeforeRequiredValue = "Optional parameters must appear after all required parameters";
        public static ERR_DefaultValueForExtensionParameter = "Cannot specify a default value for the 'this' parameter";
        public static ERR_DefaultValueForParamsParameter = "Cannot specify a default value for a parameter array";
        public static ERR_DefaultValueMustBeConstant = "Default parameter value for '{0}' must be a compile-time constant";
        public static ERR_DefaultValueNotAllowed = "Default values are not valid in this context.";
        public static ERR_DefaultValueTypeMustMatch = "The type of the argument to the DefaultParameterValue attribute must match the parameter type";
        public static ERR_DefaultValueUsedWithAttributes = "Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute";
        public static ERR_DelegateOnConditional = "Cannot create delegate with '{0}' because it or a method it overrides has a Conditional attribute";
        public static ERR_DelegateOnNullable = "Cannot bind delegate to '{0}' because it is a member of 'System.Nullable<T>'";
        public static ERR_DeprecatedCollectionInitAddStr = "The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}";
        public static ERR_DeprecatedSymbolStr = "'{0}' is obsolete: '{1}'";
        public static ERR_DeriveFromConstructedDynamic = "'{0}': cannot implement a dynamic interface '{1}'";
        public static ERR_DeriveFromDynamic = "'{0}': cannot derive from the dynamic type";
        public static ERR_DeriveFromEnumOrValueType = "'{0}' cannot derive from special class '{1}'";
        public static ERR_DerivingFromATyVar = "Cannot derive from '{0}' because it is a type parameter";
        public static ERR_DestructorInStaticClass = "Static classes cannot contain destructors";
        public static ERR_DictionaryInitializerInExpressionTree = "An expression tree lambda may not contain a dictionary initializer.";
        public static ERR_DllImportOnGenericMethod = "The DllImport attribute cannot be applied to a method that is generic or contained in a generic type.";
        public static ERR_DllImportOnInvalidMethod = "The DllImport attribute must be specified on a method marked 'static' and 'extern'";
        public static ERR_DoesntImplementAwaitInterface = "'{0}' does not implement '{1}'";
        public static ERR_DoNotUseFixedBufferAttr = "Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.";
        public static ERR_DottedTypeNameNotFoundInAgg = "The type name '{0}' does not exist in the type '{1}'";
        public static ERR_DottedTypeNameNotFoundInNS = "The type or namespace name '{0}' does not exist in the namespace '{1}' (are you missing an assembly reference?)";
        public static ERR_DottedTypeNameNotFoundInNSFwd = "The type name '{0}' could not be found in the namespace '{1}'. This type has been forwarded to assembly '{2}' Consider adding a reference to that assembly.";
        public static ERR_DuplicateAccessor = "Property accessor already defined";
        public static ERR_DuplicateAlias = "The using alias '{0}' appeared previously in this namespace";
        public static ERR_DuplicateAttribute = "Duplicate '{0}' attribute";
        public static ERR_DuplicateAttributeInNetModule = "Duplicate '{0}' attribute in '{1}'";
        public static ERR_DuplicateBound = "Duplicate constraint '{0}' for type parameter '{1}'";
        public static ERR_DuplicateCaseLabel = "The switch statement contains multiple cases with the label value '{0}'";
        public static ERR_DuplicateConstraintClause = "A constraint clause has already been specified for type parameter '{0}'. All of the constraints for a type parameter must be specified in a single where clause.";
        public static ERR_DuplicateConversionInClass = "Duplicate user-defined conversion in type '{0}'";
        public static ERR_DuplicateGeneratedName = "The parameter name '{0}' conflicts with an automatically-generated parameter name";
        public static ERR_DuplicateImport = "Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.";
        public static ERR_DuplicateImportSimple = "An assembly with the same simple name '{0}' has already been imported. Try removing one of the references (e.g. '{1}') or sign them to enable side-by-side.";
        public static ERR_DuplicateInterfaceInBaseList = "'{0}' is already listed in interface list";
        public static ERR_DuplicateLabel = "The label '{0}' is a duplicate";
        public static ERR_DuplicateModifier = "Duplicate '{0}' modifier";
        public static ERR_DuplicateNamedArgument = "Named argument '{0}' cannot be specified multiple times";
        public static ERR_DuplicateNamedAttributeArgument = "'{0}' duplicate named attribute argument";
        public static ERR_DuplicateNameInClass = "The type '{0}' already contains a definition for '{1}'";
        public static ERR_DuplicateNameInNS = "The namespace '{1}' already contains a definition for '{0}'";
        public static ERR_DuplicateParamName = "The parameter name '{0}' is a duplicate";
        public static ERR_DuplicatePropertyAccessMods = "Cannot specify accessibility modifiers for both accessors of the property or indexer '{0}'";
        public static ERR_DuplicateTypeForwarder = "'{0}' duplicate TypeForwardedToAttribute";
        public static ERR_DuplicateTypeParameter = "Duplicate type parameter '{0}'";
        public static ERR_DupParamMod = "A parameter can only have one '{0}' modifier";
        public static ERR_DynamicAttributeMissing = "Cannot define a class or member that utilizes 'dynamic' because the compiler required type '{0}' cannot be found. Are you missing a reference?";
        public static ERR_DynamicRequiredTypesMissing = "One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?";
        public static ERR_DynamicTypeAsBound = "Constraint cannot be the dynamic type";
        public static ERR_EmptyCharConst = "Empty character literal";
        public static ERR_EmptyElementInitializer = "Element initializer cannot be empty";
        public static ERR_EmptyFormatSpecifier = "Empty format specifier.";
        public static ERR_EmptyYield = "Expression expected after yield return";
        public static ERR_EncNoDynamicOperation = "Cannot continue since the edit includes an operation on a 'dynamic' type.";
        public static ERR_EncNoPIAReference = "Cannot continue since the edit includes a reference to an embedded type: '{0}'.";
        public static ERR_EncodinglessSyntaxTree = "Cannot emit debug information for a source text without encoding.";
        public static ERR_EncReferenceToAddedMember = "Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.";
        public static ERR_EndifDirectiveExpected = "#endif directive expected";
        public static ERR_EndOfPPLineExpected = "Single-line comment or end-of-line expected";
        public static ERR_EndRegionDirectiveExpected = "#endregion directive expected";
        public static ERR_EnumeratorOverflow = "'{0}': the enumerator value is too large to fit in its type";
        public static ERR_EnumsCantContainDefaultConstructor = "Enums cannot contain explicit parameterless constructors";
        public static ERR_EOFExpected = "Type or namespace definition, or end-of-file expected";
        public static ERR_ErrorBuildingWin32Resources = "Error building Win32 resources -- {0}";
        public static ERR_ErrorDirective = "#error: '{0}'";
        public static ERR_ErrorInReferencedAssembly = "There is an error in a referenced assembly '{0}'.";
        public static ERR_EscapedCurly = "A '{0}' character may only be escaped by doubling '{0}{0}' in an interpolated string.";
        public static ERR_EventNeedsBothAccessors = "'{0}': event property must have both add and remove accessors";
        public static ERR_EventNotDelegate = "'{0}': event must be of a delegate type";
        public static ERR_EventPropertyInInterface = "An event in an interface cannot have add or remove accessors";
        public static ERR_ExpectedContextualKeywordBy = "Expected contextual keyword 'by'";
        public static ERR_ExpectedContextualKeywordEquals = "Expected contextual keyword 'equals'";
        public static ERR_ExpectedContextualKeywordOn = "Expected contextual keyword 'on'";
        public static ERR_ExpectedEndTry = "Expected catch or finally";
        public static ERR_ExpectedPPFile = "Quoted file name expected";
        public static ERR_ExpectedSelectOrGroup = "A query body must end with a select clause or a group clause";
        public static ERR_ExpectedVerbatimLiteral = "Keyword, identifier, or string expected after verbatim specifier: @";
        public static ERR_ExplicitDynamicAttr = "Do not use 'System.Runtime.CompilerServices.DynamicAttribute'. Use the 'dynamic' keyword instead.";
        public static ERR_ExplicitEventFieldImpl = "An explicit interface implementation of an event must use event accessor syntax";
        public static ERR_ExplicitExtension = "Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.";
        public static ERR_ExplicitImplCollisionOnRefOut = "Cannot inherit interface '{0}' with the specified type parameters because it causes method '{1}' to contain overloads which differ only on ref and out";
        public static ERR_ExplicitImplParams = "'{0}' should not have a params parameter since '{1}' does not";
        public static ERR_ExplicitInterfaceImplementationInNonClassOrStruct = "'{0}': explicit interface declaration can only be declared in a class or struct";
        public static ERR_ExplicitInterfaceImplementationNotInterface = "'{0}' in explicit interface declaration is not an interface";
        public static ERR_ExplicitLayoutAndAutoImplementedProperty = "'{0}': Auto-implemented properties cannot be used inside a type marked with StructLayout(LayoutKind.Explicit)";
        public static ERR_ExplicitMethodImplAccessor = "'{0}' explicit method implementation cannot implement '{1}' because it is an accessor";
        public static ERR_ExplicitParamArray = "Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead.";
        public static ERR_ExplicitPropertyAddingAccessor = "'{0}' adds an accessor not found in interface member '{1}'";
        public static ERR_ExplicitPropertyMissingAccessor = "Explicit interface implementation '{0}' is missing accessor '{1}'";
        public static ERR_ExportedTypeConflictsWithDeclaration = "Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.";
        public static ERR_ExportedTypesConflict = "Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.";
        public static ERR_ExpressionExpected = "Expected expression";
        public static ERR_ExpressionHasNoName = "Expression does not have a name.";
        public static ERR_ExpressionTreeContainsAnonymousMethod = "An expression tree may not contain an anonymous method expression";
        public static ERR_ExpressionTreeContainsAssignment = "An expression tree may not contain an assignment operator";
        public static ERR_ExpressionTreeContainsBadCoalesce = "An expression tree lambda may not contain a coalescing operator with a null literal left-hand side";
        public static ERR_ExpressionTreeContainsBaseAccess = "An expression tree may not contain a base access";
        public static ERR_ExpressionTreeContainsDynamicOperation = "An expression tree may not contain a dynamic operation";
        public static ERR_ExpressionTreeContainsIndexedProperty = "An expression tree may not contain an indexed property";
        public static ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer = "An expression tree may not contain a multidimensional array initializer";
        public static ERR_ExpressionTreeContainsNamedArgument = "An expression tree may not contain a named argument specification";
        public static ERR_ExpressionTreeContainsOptionalArgument = "An expression tree may not contain a call or invocation that uses optional arguments";
        public static ERR_ExpressionTreeContainsPointerOp = "An expression tree may not contain an unsafe pointer operation";
        public static ERR_ExpressionTreeMustHaveDelegate = "Cannot convert lambda to an expression tree whose type argument '{0}' is not a delegate type";
        public static ERR_ExtensionAttrNotFound = "Cannot define a new extension method because the compiler required type '{0}' cannot be found. Are you missing a reference to System.Core.dll?";
        public static ERR_ExtensionMethodsDecl = "Extension methods must be defined in a top level static class; {0} is a nested class";
        public static ERR_ExternAfterElements = "An extern alias declaration must precede all other elements defined in the namespace";
        public static ERR_ExternAliasNotAllowed = "'extern alias' is not valid in this context";
        public static ERR_ExternHasBody = "'{0}' cannot be extern and declare a body";
        public static ERR_FeatureIsExperimental = "Feature '{0}' is only available in 'experimental' language version.";
        public static ERR_FeatureNotAvailableInVersion1 = "Feature '{0}' is not available in C# 1.  Please use language version {1} or greater.";
        public static ERR_FeatureNotAvailableInVersion2 = "Feature '{0}' is not available in C# 2.  Please use language version {1} or greater.";
        public static ERR_FeatureNotAvailableInVersion3 = "Feature '{0}' is not available in C# 3.  Please use language version {1} or greater.";
        public static ERR_FeatureNotAvailableInVersion4 = "Feature '{0}' is not available in C# 4.  Please use language version {1} or greater.";
        public static ERR_FeatureNotAvailableInVersion5 = "Feature '{0}' is not available in C# 5.  Please use language version {1} or greater.";
        public static ERR_FeatureNotAvailableInVersion6 = "Feature '{0}' is not available in C# 6.  Please use language version {1} or greater.";
        public static ERR_FeatureNotValidInExpressionTree = "An expression tree may not contain '{0}'";
        public static ERR_FieldCantBeRefAny = "Field or property cannot be of type '{0}'";
        public static ERR_FieldCantHaveVoidType = "Field cannot have void type";
        public static ERR_FieldHasMultipleDistinctConstantValues = "The field has multiple distinct constant values.";
        public static ERR_FieldInitializerInStruct = "'{0}': cannot have instance property or field initializers in structs";
        public static ERR_FieldInitRefNonstatic = "A field initializer cannot reference the non-static field, method, or property '{0}'";
        public static ERR_FileNotFound = "Source file '{0}' could not be found.";
        public static ERR_FixedBufferNotFixed = "You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.";
        public static ERR_FixedBufferTooManyDimensions = "A fixed buffer may only have one dimension.";
        public static ERR_FixedDimsRequired = "A fixed size buffer field must have the array size specifier after the field name";
        public static ERR_FixedLocalInLambda = "Cannot use fixed local '{0}' inside an anonymous method, lambda expression, or query expression";
        public static ERR_FixedMustInit = "You must provide an initializer in a fixed or using statement declaration";
        public static ERR_FixedNeeded = "You can only take the address of an unfixed expression inside of a fixed statement initializer";
        public static ERR_FixedNeedsLvalue = "Fixed size buffers can only be accessed through locals or fields";
        public static ERR_FixedNotInStruct = "Fixed size buffer fields may only be members of structs";
        public static ERR_FixedNotNeeded = "You cannot use the fixed statement to take the address of an already fixed expression";
        public static ERR_FixedOverflow = "Fixed size buffer of length {0} and type '{1}' is too big";
        public static ERR_FloatOverflow = "Floating-point constant is outside the range of type '{0}'";
        public static ERR_ForEachMissingMember = "foreach statement cannot operate on variables of type '{0}' because '{0}' does not contain a public definition for '{1}'";
        public static ERR_ForwardedTypeConflictsWithDeclaration = "Forwarded type '{0}' conflicts with type declared in primary module of this assembly.";
        public static ERR_ForwardedTypeConflictsWithExportedType = "Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.";
        public static ERR_ForwardedTypeInThisAssembly = "Type '{0}' is defined in this assembly, but a type forwarder is specified for it";
        public static ERR_ForwardedTypeIsNested = "Cannot forward type '{0}' because it is a nested type of '{1}'";
        public static ERR_ForwardedTypesConflict = "Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.";
        public static ERR_FriendAssemblyBadArgs = "Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.";
        public static ERR_FriendAssemblySNReq = "Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.";
        public static ERR_FriendRefNotEqualToThis = "Friend access was granted by '{0}', but the public key of the output assembly does not match that specified by the attribute in the granting assembly.";
        public static ERR_FriendRefSigningMismatch = "Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.";
        public static ERR_GenericArgIsStaticClass = "'{0}': static types cannot be used as type arguments";
        public static ERR_GenericConstraintNotSatisfiedNullableEnum = "The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.";
        public static ERR_GenericConstraintNotSatisfiedNullableInterface = "The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.";
        public static ERR_GenericConstraintNotSatisfiedRefType = "The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.";
        public static ERR_GenericConstraintNotSatisfiedTyVar = "The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.";
        public static ERR_GenericConstraintNotSatisfiedValType = "The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.";
        public static ERR_GenericDerivingFromAttribute = "A generic type cannot derive from '{0}' because it is an attribute class";
        public static ERR_GenericsUsedAcrossAssemblies = "Type '{0}' from assembly '{1}' cannot be used across assembly boundaries because it has a generic type parameter that is an embedded interop type.";
        public static ERR_GenericsUsedInNoPIAType = "Type '{0}' cannot be embedded because it has a generic argument. Consider setting the 'Embed Interop Types' property to false.";
        public static ERR_GetOrSetExpected = "A get or set accessor expected";
        public static ERR_GlobalAttributesNotAllowed = "Assembly and module attributes are not allowed in this context";
        public static ERR_GlobalAttributesNotFirst = "Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations";
        public static ERR_GlobalDefinitionOrStatementExpected = "Member definition, statement, or end-of-file expected";
        public static ERR_GlobalExternAlias = "You cannot redefine the global extern alias";
        public static ERR_GlobalSingleTypeNameNotFound = "The type or namespace name '{0}' could not be found in the global namespace (are you missing an assembly reference?)";
        public static ERR_GlobalSingleTypeNameNotFoundFwd = "The type name '{0}' could not be found in the global namespace. This type has been forwarded to assembly '{1}' Consider adding a reference to that assembly.";
        public static ERR_GlobalStatement = "Expressions and statements can only occur in a method body";
        public static ERR_HasNoTypeVars = "The non-generic {1} '{0}' cannot be used with type arguments";
        public static ERR_HidingAbstractMethod = "'{0}' hides inherited abstract member '{1}'";
        public static ERR_IdentifierExpected = "Identifier expected";
        public static ERR_IdentifierExpectedKW = "Identifier expected; '{1}' is a keyword";
        public static ERR_IdentityConversion = "User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type";
        public static ERR_IllegalArglist = "An __arglist expression may only appear inside of a call or new expression";
        public static ERR_IllegalEscape = "Unrecognized escape sequence";
        public static ERR_IllegalFixedType = "Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double";
        public static ERR_IllegalInnerUnsafe = "Unsafe code may not appear in iterators";
        public static ERR_IllegalParams = "params is not valid in this context";
        public static ERR_IllegalRefParam = "ref and out are not valid in this context";
        public static ERR_IllegalStatement = "Only assignment, call, increment, decrement, and new object expressions can be used as a statement";
        public static ERR_IllegalUnsafe = "Unsafe code may only appear if compiling with /unsafe";
        public static ERR_IllegalVarArgs = "__arglist is not valid in this context";
        public static ERR_IllegalVarianceSyntax = "Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.";
        public static ERR_ImplBadConstraints = "The constraints for type parameter '{0}' of method '{1}' must match the constraints for type parameter '{2}' of interface method '{3}'. Consider using an explicit interface implementation instead.";
        public static ERR_ImplicitlyTypedArrayNoBestType = "No best type found for implicitly-typed array";
        public static ERR_ImplicitlyTypedLocalCannotBeFixed = "Implicitly-typed local variables cannot be fixed";
        public static ERR_ImplicitlyTypedVariableAssignedArrayInitializer = "Cannot initialize an implicitly-typed variable with an array initializer";
        public static ERR_ImplicitlyTypedVariableAssignedBadValue = "Cannot assign {0} to an implicitly-typed variable";
        public static ERR_ImplicitlyTypedVariableCannotBeConst = "Implicitly-typed variables cannot be constant";
        public static ERR_ImplicitlyTypedVariableMultipleDeclarator = "Implicitly-typed variables cannot have multiple declarators";
        public static ERR_ImplicitlyTypedVariableWithNoInitializer = "Implicitly-typed variables must be initialized";
        public static ERR_ImportedCircularBase = "Imported type '{0}' is invalid. It contains a circular base class dependency.";
        public static ERR_ImportNonAssembly = "The referenced file '{0}' is not an assembly";
        public static ERR_InaccessibleGetter = "The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible";
        public static ERR_InaccessibleSetter = "The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible";
        public static ERR_InAttrOnOutParam = "An out parameter cannot have the In attribute";
        public static ERR_InconsistentIndexerNames = "Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type";
        public static ERR_InconsistentLambdaParameterUsage = "Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit";
        public static ERR_IncrementLvalueExpected = "The operand of an increment or decrement operator must be a variable, property or indexer";
        public static ERR_IndexedPropertyMustHaveAllOptionalParams = "Indexed property '{0}' must have all arguments optional";
        public static ERR_IndexedPropertyRequiresParams = "Indexed property '{0}' has non-optional arguments which must be provided";
        public static ERR_IndexerCantHaveVoidType = "Indexers cannot have void type";
        public static ERR_IndexerInStaticClass = "'{0}': cannot declare indexers in a static class";
        public static ERR_IndexerNeedsParam = "Indexers must have at least one parameter";
        public static ERR_InExpected = "'in' expected";
        public static ERR_InitializerAddHasParamModifiers = "The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.";
        public static ERR_InitializerAddHasWrongSignature = "The best overloaded method match for '{0}' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.";
        public static ERR_InitializerInStructWithoutExplicitConstructor = "Structs without explicit constructors cannot contain members with initializers.";
        public static ERR_InitializerOnNonAutoProperty = "Only auto-implemented properties can have initializers.";
        public static ERR_InstanceMemberInStaticClass = "'{0}': cannot declare instance members in a static class";
        public static ERR_InstantiatingStaticClass = "Cannot create an instance of the static class '{0}'";
        public static ERR_InsufficientStack = "An expression is too long or complex to compile";
        public static ERR_IntDivByZero = "Division by constant zero";
        public static ERR_IntegralTypeExpected = "Type byte, sbyte, short, ushort, int, uint, long, or ulong expected";
        public static ERR_IntegralTypeValueExpected = "A value of an integral type expected";
        public static ERR_InterfaceEventInitializer = "'{0}': event in interface cannot have initializer";
        public static ERR_InterfaceImplementedByConditional = "Conditional member '{0}' cannot implement interface member '{1}' in type '{2}'";
        public static ERR_InterfaceMemberHasBody = "'{0}': interface members cannot have a definition";
        public static ERR_InterfaceMemberNotFound = "'{0}' in explicit interface declaration is not a member of interface";
        public static ERR_InterfacesCannotContainTypes = "'{0}': interfaces cannot declare types";
        public static ERR_InterfacesCantContainConstructors = "Interfaces cannot contain constructors";
        public static ERR_InterfacesCantContainFields = "Interfaces cannot contain fields";
        public static ERR_InterfacesCantContainOperators = "Interfaces cannot contain operators";
        public static ERR_InteropMethodWithBody = "Embedded interop method '{0}' contains a body.";
        public static ERR_InteropStructContainsMethods = "Embedded interop struct '{0}' can contain only public instance fields.";
        public static ERR_InteropTypeMissingAttribute = "Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.";
        public static ERR_InteropTypesWithSameNameAndGuid = "Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider setting the 'Embed Interop Types' property to false.";
        public static ERR_IntOverflow = "Integral constant is too large";
        public static ERR_InvalidAddrOp = "Cannot take the address of the given expression";
        public static ERR_InvalidAnonymousTypeMemberDeclarator = "Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.";
        public static ERR_InvalidArray = "Invalid rank specifier: expected ',' or ']'";
        public static ERR_InvalidAssemblyCulture = "Assembly culture strings may not contain embedded NUL characters.";
        public static ERR_InvalidAssemblyCultureForExe = "Executables cannot be satellite assemblies; culture should always be empty";
        public static ERR_InvalidAssemblyName = "Assembly reference '{0}' is invalid and cannot be resolved";
        public static ERR_InvalidAttributeArgument = "Invalid value for argument to '{0}' attribute";
        public static ERR_InvalidConstantDeclarationType = "'{0}' is of type '{1}'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.";
        public static ERR_InvalidDebugInformationFormat = "Invalid debug information format: {0}";
        public static ERR_InvalidDelegateType = "Delegate '{0}' has no invoke method or an invoke method with a return type or parameter types that are not supported.";
        public static ERR_InvalidDynamicCondition = "Expression must be implicitly convertible to Boolean or its type '{0}' must define operator '{1}'.";
        public static ERR_InvalidExprTerm = "Invalid expression term '{0}'";
        public static ERR_InvalidFileAlignment = "Invalid file section alignment '{0}'";
        public static ERR_InvalidFixedArraySize = "Fixed size buffers must have a length greater than zero";
        public static ERR_InvalidFormatForGuidForOption = "Command-line syntax error: Invalid Guid format '{0}' for option '{1}'";
        public static ERR_InvalidFwdType = "Invalid type specified as an argument for TypeForwardedTo attribute";
        public static ERR_InvalidGotoCase = "A goto case is only valid inside a switch statement";
        public static ERR_InvalidInitializerElementInitializer = "Invalid initializer member declarator";
        public static ERR_InvalidLineNumber = "The line number specified for #line directive is missing or invalid";
        public static ERR_InvalidMemberDecl = "Invalid token '{0}' in class, struct, or interface member declaration";
        public static ERR_InvalidNamedArgument = "Invalid value for named attribute argument '{0}'";
        public static ERR_InvalidNumber = "Invalid number";
        public static ERR_InvalidOutputName = "Invalid output name: {0}";
        public static ERR_InvalidPreprocExpr = "Invalid preprocessor expression";
        public static ERR_InvalidPropertyAccessMod = "The accessibility modifier of the '{0}' accessor must be more restrictive than the property or indexer '{1}'";
        public static ERR_InvalidQM = "Type of conditional expression cannot be determined because there is no implicit conversion between '{0}' and '{1}'";
        public static ERR_InvalidSignaturePublicKey = "Invalid signature public key specified in AssemblySignatureKeyAttribute.";
        public static ERR_InvalidSpecifier = "'{0}' is not a valid format specifier";
        public static ERR_InvalidSubsystemVersion = "Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise";
        public static ERR_InvalidVersionFormat = "The specified version string does not conform to the required format - major[.minor[.build[.revision]]]";
        public static ERR_InvalidVersionFormat2 = "The specified version string does not conform to the required format - major.minor.build.revision";
        public static ERR_IteratorInInteractive = "Yield statements may not appear at the top level in interactive code.";
        public static ERR_LabelNotFound = "No such label '{0}' within the scope of the goto statement";
        public static ERR_LabelShadow = "The label '{0}' shadows another label by the same name in a contained scope";
        public static ERR_LambdaInIsAs = "The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.";
        public static ERR_LbraceExpected = "{ expected";
        public static ERR_LegacyObjectIdSyntax = "'id#' syntax is no longer supported. Use '$id' instead.";
        public static ERR_LibraryMethodNotFound = "Runtime library method '{0}.{1}' not found.";
        public static ERR_LibraryMethodNotUnique = "More than one candidate found for library invocation '{0}.{1}'.";
        public static ERR_LinkedNetmoduleMetadataMustProvideFullPEImage = "Linked netmodule metadata must provide a full PE image: '{0}'.";
        public static ERR_LiteralDoubleCast = "Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type";
        public static ERR_LocalCantBeFixedAndHoisted = "Local '{0}' or its members cannot have their address taken and be used inside an anonymous method or lambda expression";
        public static ERR_LocalDuplicate = "A local variable named '{0}' is already defined in this scope";
        public static ERR_LocalIllegallyOverrides = "A local or parameter named '{0}' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter";
        public static ERR_LocalSameNameAsTypeParam = "'{0}': a parameter or local variable cannot have the same name as a method type parameter";
        public static ERR_LocalTypeNameClash = "Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider setting the 'Embed Interop Types' property to false.";
        public static ERR_LockNeedsReference = "'{0}' is not a reference type as required by the lock statement";
        public static ERR_LookupInTypeVariable = "Cannot do member lookup in '{0}' because it is a type parameter";
        public static ERR_MainCantBeAsync = "'{0}': an entry point cannot be marked with the 'async' modifier";
        public static ERR_MainClassIsImport = "Cannot use '{0}' for Main method because it is imported";
        public static ERR_MainClassNotClass = "'{0}' specified for Main method must be a valid non-generic class or struct";
        public static ERR_MainClassNotFound = "Could not find '{0}' specified for Main method";
        public static ERR_ManagedAddr = "Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')";
        public static ERR_MarshalUnmanagedTypeNotValidForFields = "Unmanaged type '{0}' not valid for fields.";
        public static ERR_MarshalUnmanagedTypeOnlyValidForFields = "Unmanaged type '{0}' is only valid for fields.";
        public static ERR_MemberAlreadyExists = "Type '{1}' already defines a member called '{0}' with the same parameter types";
        public static ERR_MemberAlreadyInitialized = "Duplicate initialization of member '{0}'";
        public static ERR_MemberCannotBeInitialized = "Member '{0}' cannot be initialized. It is not a field or property.";
        public static ERR_MemberNameSameAsType = "'{0}': member names cannot be the same as their enclosing type";
        public static ERR_MemberNeedsType = "Method must have a return type";
        public static ERR_MemberReserved = "Type '{1}' already reserves a member called '{0}' with the same parameter types";
        public static ERR_MemGroupInExpressionTree = "An expression tree lambda may not contain a method group";
        public static ERR_MetadataNameTooLong = "Name '{0}' exceeds the maximum length allowed in metadata.";
        public static ERR_MetadataReferencesNotSupported = "Metadata references not supported.";
        public static ERR_MethDelegateMismatch = "No overload for '{0}' matches delegate '{1}'";
        public static ERR_MethGrpToNonDel = "Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?";
        public static ERR_MethodArgCantBeRefAny = "Cannot make reference to variable of type '{0}'";
        public static ERR_MethodImplementingAccessor = "Method '{0}' cannot implement interface accessor '{1}' for type '{2}'. Use an explicit interface implementation.";
        public static ERR_MethodNameExpected = "Method name expected";
        public static ERR_MethodReturnCantBeRefAny = "Method or delegate cannot return type '{0}'";
        public static ERR_MissingArgument = "Argument missing";
        public static ERR_MissingArraySize = "Array creation must have array size or array initializer";
        public static ERR_MissingCoClass = "The managed coclass wrapper class '{0}' for interface '{1}' cannot be found (are you missing an assembly reference?)";
        public static ERR_MissingDebugSwitch = "The /pdb option requires that the /debug option also be used";
        public static ERR_MissingGuidForOption = "Command-line syntax error: Missing Guid for option '{1}'";
        public static ERR_MissingMethodOnSourceInterface = "Source interface '{0}' is missing method '{1}' which is required to embed event '{2}'.";
        public static ERR_MissingNetModuleReference = "Reference to '{0}' netmodule missing.";
        public static ERR_MissingPartial = "Missing partial modifier on declaration of type '{0}'; another partial declaration of this type exists";
        public static ERR_MissingPPFile = "Quoted file name, single-line comment or end-of-line expected";
        public static ERR_MissingPredefinedMember = "Missing compiler required member '{0}.{1}'";
        public static ERR_MissingSourceInterface = "Interface '{0}' has an invalid source interface which is required to embed event '{1}'.";
        public static ERR_MissingStructOffset = "'{0}': instance field types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute";
        public static ERR_MissingTypeInAssembly = "Reference to type '{0}' claims it is defined in '{1}', but it could not be found";
        public static ERR_MissingTypeInSource = "Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules";
        public static ERR_MixingWinRTEventWithRegular = "'{0}' cannot implement '{1}' because '{2}' is a Windows Runtime event and '{3}' is a regular .NET event.";
        public static ERR_ModuleEmitFailure = "Failed to emit module '{0}'.";
        public static ERR_MultiParamMod = "A parameter cannot have all the specified modifiers; there are too many modifiers on the parameter";
        public static ERR_MultipleEntryPoints = "Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point.";
        public static ERR_MultipleIEnumOfT = "foreach statement cannot operate on variables of type '{0}' because it implements multiple instantiations of '{1}'; try casting to a specific interface instantiation";
        public static ERR_MultiTypeInDeclaration = "Cannot use more than one type in a for, using, fixed, or declaration statement";
        public static ERR_MustHaveOpTF = "In order for '{0}' to be applicable as a short circuit operator, its declaring type '{1}' must define operator true and operator false";
        public static ERR_NamedArgumentExpected = "Named attribute argument expected";
        public static ERR_NamedArgumentForArray = "An array access may not have a named argument specifier";
        public static ERR_NamedArgumentSpecificationBeforeFixedArgument = "Named argument specifications must appear after all fixed arguments have been specified";
        public static ERR_NamedArgumentUsedInPositional = "Named argument '{0}' specifies a parameter for which a positional argument has already been given";
        public static ERR_NameNotInContext = "The name '{0}' does not exist in the current context";
        public static ERR_NameNotInContextPossibleMissingReference = "The name '{0}' does not exist in the current context (are you missing a reference to assembly '{1}'?)";
        public static ERR_NameofMethodGroupWithTypeParameters = "Type parameters are not allowed on a method group as an argument to 'nameof'.";
        public static ERR_NamespaceNotAllowedInScript = "You cannot declare namespace in script code";
        public static ERR_NamespaceUnexpected = "A namespace cannot directly contain members such as fields or methods";
        public static ERR_NegativeArraySize = "Cannot create an array with a negative size";
        public static ERR_NegativeStackAllocSize = "Cannot use a negative size with stackalloc";
        public static ERR_NetModuleNameMismatch = "Module name '{0}' stored in '{1}' must match its filename.";
        public static ERR_NetModuleNameMustBeUnique = "Module '{0}' is already defined in this assembly. Each module must have a unique filename.";
        public static ERR_NewBoundMustBeLast = "The new() constraint must be the last constraint specified";
        public static ERR_NewBoundWithVal = "The 'new()' constraint cannot be used with the 'struct' constraint";
        public static ERR_NewCoClassOnLink = "Interop type '{0}' cannot be embedded. Use the applicable interface instead.";
        public static ERR_NewConstraintNotSatisfied = "'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'";
        public static ERR_NewlineInConst = "Newline in constant";
        public static ERR_NewTyvarWithArgs = "'{0}': cannot provide arguments when creating an instance of a variable type";
        public static ERR_NewVirtualInSealed = "'{0}' is a new virtual member in sealed class '{1}'";
        public static ERR_NoAliasHere = "A 'using static' directive cannot be used to declare an alias";
        public static ERR_NoBaseClass = "A base class is required for a 'base' reference";
        public static ERR_NoBreakOrCont = "No enclosing loop out of which to break or continue";
        public static ERR_NoCanonicalView = "Cannot find the interop type that matches the embedded interop type '{0}'. Are you missing an assembly reference?";
        public static ERR_NoConstructors = "The type '{0}' has no constructors defined";
        public static ERR_NoConversionForCallerFilePathParam = "CallerFilePathAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'";
        public static ERR_NoConversionForCallerLineNumberParam = "CallerLineNumberAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'";
        public static ERR_NoConversionForCallerMemberNameParam = "CallerMemberNameAttribute cannot be applied because there are no standard conversions from type '{0}' to type '{1}'";
        public static ERR_NoConversionForDefaultParam = "A value of type '{0}' cannot be used as a default parameter because there are no standard conversions to type '{1}'";
        public static ERR_NoConversionForNubDefaultParam = "A value of type '{0}' cannot be used as default parameter for nullable parameter '{1}' because '{0}' is not a simple type";
        public static ERR_NoConvToIDisp = "'{0}': type used in a using statement must be implicitly convertible to 'System.IDisposable'";
        public static ERR_NoCorrespondingArgument = "There is no argument given that corresponds to the required formal parameter '{0}' of '{1}'";
        public static ERR_NoDynamicPhantomOnBase = "The call to method '{0}' needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.";
        public static ERR_NoDynamicPhantomOnBaseCtor = "The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments.";
        public static ERR_NoDynamicPhantomOnBaseIndexer = "The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access.";
        public static ERR_NoEntryPoint = "Program does not contain a static 'Main' method suitable for an entry point";
        public static ERR_NoExplicitBuiltinConv = "Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion";
        public static ERR_NoExplicitConv = "Cannot convert type '{0}' to '{1}'";
        public static ERR_NoFileSpec = "Missing file specification for '{0}' option";
        public static ERR_NoGetToOverride = "'{0}': cannot override because '{1}' does not have an overridable get accessor";
        public static ERR_NoImplicitConv = "Cannot implicitly convert type '{0}' to '{1}'";
        public static ERR_NoImplicitConvCast = "Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)";
        public static ERR_NoMainInClass = "'{0}' does not have a suitable static Main method";
        public static ERR_NoMainOnDLL = "Cannot specify /main if building a module or library";
        public static ERR_NoMetadataFile = "Metadata file '{0}' could not be found";
        public static ERR_NoModifiersOnAccessor = "Modifiers cannot be placed on event accessor declarations";
        public static ERR_NoMultipleInheritance = "Class '{0}' cannot have multiple base classes: '{1}' and '{2}'";
        public static ERR_NoNamespacePrivate = "Elements defined in a namespace cannot be explicitly declared as private, protected, or protected internal";
        public static ERR_NoNewAbstract = "Cannot create an instance of the abstract class or interface '{0}'";
        public static ERR_NoNewTyvar = "Cannot create an instance of the variable type '{0}' because it does not have the new() constraint";
        public static ERR_NonInterfaceInInterfaceList = "Type '{0}' in interface list is not an interface";
        public static ERR_NonInvocableMemberCalled = "Non-invocable member '{0}' cannot be used like a method.";
        public static ERR_NoPIAAssemblyMissingAttribute = "Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.";
        public static ERR_NoPIAAssemblyMissingAttributes = "Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.";
        public static ERR_NoPIANestedType = "Type '{0}' cannot be embedded because it is a nested type. Consider setting the 'Embed Interop Types' property to false.";
        public static ERR_NoScriptsSpecified = "Expected at least one script (.csx file) but none specified";
        public static ERR_NoSetToOverride = "'{0}': cannot override because '{1}' does not have an overridable set accessor";
        public static ERR_NoSourceFile = "Source file '{0}' could not be opened -- {1}";
        public static ERR_NoSuchMember = "'{0}' does not contain a definition for '{1}'";
        public static ERR_NoSuchMemberOrExtension = "'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)";
        public static ERR_NoSuchMemberOrExtensionNeedUsing = "'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive for '{2}'?)";
        public static ERR_NotAnAttributeClass = "'{0}' is not an attribute class";
        public static ERR_NotConstantExpression = "The expression being assigned to '{0}' must be constant";
        public static ERR_NotNullConstRefField = "'{0}' is of type '{1}'. A const field of a reference type other than string can only be initialized with null.";
        public static ERR_NotNullRefDefaultParameter = "'{0}' is of type '{1}'. A default parameter value of a reference type other than string can only be initialized with null";
        public static ERR_NotYetImplementedInRoslyn = "This language feature ('{0}') is not yet implemented in Roslyn.";
        public static ERR_NoTypeDef = "The type '{0}' is defined in an assembly that is not referenced. You must add a reference to assembly '{1}'.";
        public static ERR_NoTypeDefFromModule = "The type '{0}' is defined in a module that has not been added. You must add the module '{1}'.";
        public static ERR_NoVoidHere = "Keyword 'void' cannot be used in this context";
        public static ERR_NoVoidParameter = "Invalid parameter type 'void'";
        public static ERR_NullNotValid = "Use of null is not valid in this context";
        public static ERR_NullPropagatingOpInExpressionTree = "An expression tree lambda may not contain a null propagating operator.";
        public static ERR_ObjectCallingBaseConstructor = "'{0}' has no base class and cannot call a base constructor";
        public static ERR_ObjectCantHaveBases = "The class System.Object cannot have a base class or implement an interface";
        public static ERR_ObjectOrCollectionInitializerWithDelegateCreation = "Object and collection initializer expressions may not be applied to a delegate creation expression";
        public static ERR_ObjectProhibited = "Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead";
        public static ERR_ObjectRequired = "An object reference is required for the non-static field, method, or property '{0}'";
        public static ERR_OneAliasPerReference = "A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.";
        public static ERR_OnlyClassesCanContainDestructors = "Only class types can contain destructors";
        public static ERR_OpenEndedComment = "End-of-file found, '*/' expected";
        public static ERR_OpenResponseFile = "Error opening response file '{0}'";
        public static ERR_OperatorCantReturnVoid = "User-defined operators cannot return void";
        public static ERR_OperatorInStaticClass = "'{0}': static classes cannot contain user-defined operators";
        public static ERR_OperatorNeedsMatch = "The operator '{0}' requires a matching operator '{1}' to also be defined";
        public static ERR_OperatorsMustBeStatic = "User-defined operator '{0}' must be declared static and public";
        public static ERR_OpTFRetType = "The return type of operator True or False must be bool";
        public static ERR_OutAttrOnRefParam = "Cannot specify only Out attribute on a ref parameter. Use both In and Out attributes, or neither.";
        public static ERR_OutputNeedsName = "Outputs without source must have the /out option specified";
        public static ERR_OutputWriteFailed = "Could not write to output file '{0}' -- '{1}'";
        public static ERR_OverloadRefOut = "'{0}' cannot define overloaded methods that differ only on ref and out";
        public static ERR_OverloadRefOutCtor = "Cannot define overloaded constructor '{0}' because it differs from another constructor only on ref and out";
        public static ERR_OverrideFinalizeDeprecated = "Do not override object.Finalize. Instead, provide a destructor.";
        public static ERR_OverrideNotExpected = "'{0}': no suitable method found to override";
        public static ERR_OverrideNotNew = "A member '{0}' marked as override cannot be marked as new or virtual";
        public static ERR_OverrideWithConstraints = "Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly";
        public static ERR_OvlBinaryOperatorExpected = "Overloadable binary operator expected";
        public static ERR_OvlOperatorExpected = "Overloadable operator expected";
        public static ERR_OvlUnaryOperatorExpected = "Overloadable unary operator expected";
        public static ERR_ParamDefaultValueDiffersFromAttribute = "The parameter has multiple distinct default values.";
        public static ERR_ParameterIsStaticClass = "'{0}': static types cannot be used as parameters";
        public static ERR_ParameterlessStructCtorsMustBePublic = "Parameterless instance constructors in structs must be public";
        public static ERR_ParameterNotValidForType = "Parameter not valid for the specified unmanaged type.";
        public static ERR_ParamsCantBeRefOut = "The params parameter cannot be declared as ref or out";
        public static ERR_ParamsLast = "A params parameter must be the last parameter in a formal parameter list";
        public static ERR_ParamsMustBeArray = "The params parameter must be a single dimensional array";
        public static ERR_ParamUnassigned = "The out parameter '{0}' must be assigned to before control leaves the current method";
        public static ERR_PartialMethodCannotHaveOutParameters = "A partial method cannot have out parameters";
        public static ERR_PartialMethodExtensionDifference = "Both partial method declarations must be extension methods or neither may be an extension method";
        public static ERR_PartialMethodInconsistentConstraints = "Partial method declarations of '{0}' have inconsistent type parameter constraints";
        public static ERR_PartialMethodInExpressionTree = "Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees";
        public static ERR_PartialMethodInvalidModifier = "A partial method cannot have access modifiers or the virtual, abstract, override, new, sealed, or extern modifiers";
        public static ERR_PartialMethodMustHaveLatent = "No defining declaration found for implementing declaration of partial method '{0}'";
        public static ERR_PartialMethodMustReturnVoid = "Partial methods must have a void return type";
        public static ERR_PartialMethodNotExplicit = "A partial method may not explicitly implement an interface method";
        public static ERR_PartialMethodOnlyInPartialClass = "A partial method must be declared within a partial class or partial struct";
        public static ERR_PartialMethodOnlyMethods = "Only methods, classes, structs, or interfaces may be partial";
        public static ERR_PartialMethodOnlyOneActual = "A partial method may not have multiple implementing declarations";
        public static ERR_PartialMethodOnlyOneLatent = "A partial method may not have multiple defining declarations";
        public static ERR_PartialMethodParamsDifference = "Both partial method declarations must use a params parameter or neither may use a params parameter";
        public static ERR_PartialMethodStaticDifference = "Both partial method declarations must be static or neither may be static";
        public static ERR_PartialMethodToDelegate = "Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration";
        public static ERR_PartialMethodUnsafeDifference = "Both partial method declarations must be unsafe or neither may be unsafe";
        public static ERR_PartialMisplaced = "The 'partial' modifier can only appear immediately before 'class', 'struct', 'interface', or 'void'";
        public static ERR_PartialModifierConflict = "Partial declarations of '{0}' have conflicting accessibility modifiers";
        public static ERR_PartialMultipleBases = "Partial declarations of '{0}' must not specify different base classes";
        public static ERR_PartialTypeKindConflict = "Partial declarations of '{0}' must be all classes, all structs, or all interfaces";
        public static ERR_PartialWrongConstraints = "Partial declarations of '{0}' have inconsistent constraints for type parameter '{1}'";
        public static ERR_PartialWrongTypeParams = "Partial declarations of '{0}' must have the same type parameter names in the same order";
        public static ERR_PartialWrongTypeParamsVariance = "Partial declarations of '{0}' must have the same type parameter names and variance modifiers in the same order";
        public static ERR_PermissionSetAttributeFileReadError = "Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'";
        public static ERR_PermissionSetAttributeInvalidFile = "Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute";
        public static ERR_PointerInAsOrIs = "Neither 'is' nor 'as' is valid on pointer types";
        public static ERR_PPDefFollowsToken = "Cannot define/undefine preprocessor symbols after first token in file";
        public static ERR_PPDirectiveExpected = "Preprocessor directive expected";
        public static ERR_PPReferenceFollowsToken = "Cannot use #r after first token in file";
        public static ERR_PredefinedTypeNotFound = "Predefined type '{0}' is not defined or imported";
        public static ERR_PrincipalPermissionInvalidAction = "SecurityAction value '{0}' is invalid for PrincipalPermission attribute";
        public static ERR_PrivateAbstractAccessor = "'{0}': abstract properties cannot have private accessors";
        public static ERR_PropertyAccessModInInterface = "'{0}': accessibility modifiers may not be used on accessors in an interface";
        public static ERR_PropertyCantHaveVoidType = "'{0}': property or indexer cannot have void type";
        public static ERR_PropertyLacksGet = "The property or indexer '{0}' cannot be used in this context because it lacks the get accessor";
        public static ERR_PropertyWithNoAccessors = "'{0}': property or indexer must have at least one accessor";
        public static ERR_ProtectedInStatic = "'{0}': static classes cannot contain protected members";
        public static ERR_ProtectedInStruct = "'{0}': new protected member declared in struct";
        public static ERR_PtrExpected = "The * or -> operator must be applied to a pointer";
        public static ERR_PtrIndexSingle = "A pointer must be indexed by only one value";
        public static ERR_PublicKeyContainerFailure = "Error signing output with public key from container '{0}' -- {1}";
        public static ERR_PublicKeyFileFailure = "Error signing output with public key from file '{0}' -- {1}";
        public static ERR_QueryDuplicateRangeVariable = "The range variable '{0}' has already been declared";
        public static ERR_QueryInnerKey = "The name '{0}' is not in scope on the right side of 'equals'.  Consider swapping the expressions on either side of 'equals'.";
        public static ERR_QueryMultipleProviders = "Multiple implementations of the query pattern were found for source type '{0}'.  Ambiguous call to '{1}'.";
        public static ERR_QueryNoProvider = "Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.";
        public static ERR_QueryNoProviderCastable = "Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Consider explicitly specifying the type of the range variable '{2}'.";
        public static ERR_QueryNoProviderStandard = "Could not find an implementation of the query pattern for source type '{0}'.  '{1}' not found.  Are you missing a reference to 'System.Core.dll' or a using directive for 'System.Linq'?";
        public static ERR_QueryOuterKey = "The name '{0}' is not in scope on the left side of 'equals'.  Consider swapping the expressions on either side of 'equals'.";
        public static ERR_QueryOutRefRangeVariable = "Cannot pass the range variable '{0}' as an out or ref parameter";
        public static ERR_QueryRangeVariableAssignedBadValue = "Cannot assign {0} to a range variable";
        public static ERR_QueryRangeVariableOverrides = "The range variable '{0}' conflicts with a previous declaration of '{0}'";
        public static ERR_QueryRangeVariableReadOnly = "Range variable '{0}' cannot be assigned to -- it is read only";
        public static ERR_QueryRangeVariableSameAsTypeParam = "The range variable '{0}' cannot have the same name as a method type parameter";
        public static ERR_QueryTypeInferenceFailed = "The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.";
        public static ERR_QueryTypeInferenceFailedMulti = "The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to '{1}'.";
        public static ERR_QueryTypeInferenceFailedSelectMany = "An expression of type '{0}' is not allowed in a subsequent from clause in a query expression with source type '{1}'.  Type inference failed in the call to '{2}'.";
        public static ERR_RbraceExpected = "} expected";
        public static ERR_ReadonlyValueTypeInObjectInitializer = "Members of readonly field '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type";
        public static ERR_RecursiveConstructorCall = "Constructor '{0}' cannot call itself";
        public static ERR_RecursivelyTypedVariable = "Type of '{0}' cannot be inferred since its initializer directly or indirectly refers to the definition.";
        public static ERR_RefConstraintNotSatisfied = "The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'";
        public static ERR_ReferenceDirectiveOnlyAllowedInScripts = "#r is only allowed in scripts";
        public static ERR_RefLvalueExpected = "A ref or out argument must be an assignable variable";
        public static ERR_RefOutDefaultValue = "A ref or out parameter cannot have a default value";
        public static ERR_RefProperty = "A property or indexer may not be passed as an out or ref parameter";
        public static ERR_RefReadonly = "A readonly field cannot be passed ref or out (except in a constructor)";
        public static ERR_RefReadonly2 = "Members of readonly field '{0}' cannot be passed ref or out (except in a constructor)";
        public static ERR_RefReadonlyLocal = "Cannot pass '{0}' as a ref or out argument because it is read-only";
        public static ERR_RefReadonlyLocal2Cause = "Cannot pass fields of '{0}' as a ref or out argument because it is a '{1}'";
        public static ERR_RefReadonlyLocalCause = "Cannot pass '{0}' as a ref or out argument because it is a '{1}'";
        public static ERR_RefReadonlyStatic = "A static readonly field cannot be passed ref or out (except in a static constructor)";
        public static ERR_RefReadonlyStatic2 = "Fields of static readonly field '{0}' cannot be passed ref or out (except in a static constructor)";
        public static ERR_RefValBoundMustBeFirst = "The 'class' or 'struct' constraint must come before any other constraints";
        public static ERR_RefValBoundWithClass = "'{0}': cannot specify both a constraint class and the 'class' or 'struct' constraint";
        public static ERR_ReservedAssemblyName = "The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session";
        public static ERR_ReservedEnumerator = "The enumerator name '{0}' is reserved and cannot be used";
        public static ERR_ResourceFileNameNotUnique = "Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly";
        public static ERR_ResourceNotUnique = "Resource identifier '{0}' has already been used in this assembly";
        public static ERR_RetNoObjectRequired = "Since '{0}' returns void, a return keyword must not be followed by an object expression";
        public static ERR_RetNoObjectRequiredLambda = "Anonymous function converted to a void returning delegate cannot return a value";
        public static ERR_RetObjectRequired = "An object of a type convertible to '{0}' is required";
        public static ERR_ReturnExpected = "'{0}': not all code paths return a value";
        public static ERR_ReturnInIterator = "Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.";
        public static ERR_ReturnNotAllowedInScript = "You cannot use 'return' in top-level script code";
        public static ERR_ReturnNotLValue = "Cannot modify the return value of '{0}' because it is not a variable";
        public static ERR_ReturnTypeIsStaticClass = "'{0}': static types cannot be used as return types";
        public static ERR_SameFullNameAggAgg = "The type '{1}' exists in both '{0}' and '{2}'";
        public static ERR_SameFullNameNsAgg = "The namespace '{1}' in '{0}' conflicts with the type '{3}' in '{2}'";
        public static ERR_SameFullNameThisAggThisNs = "The type '{1}' in '{0}' conflicts with the namespace '{3}' in '{2}'";
        public static ERR_SealedNonOverride = "'{0}' cannot be sealed because it is not an override";
        public static ERR_SealedStaticClass = "'{0}': a class cannot be both static and sealed";
        public static ERR_SecurityAttributeInvalidAction = "Security attribute '{0}' has an invalid SecurityAction value '{1}'";
        public static ERR_SecurityAttributeInvalidActionAssembly = "SecurityAction value '{0}' is invalid for security attributes applied to an assembly";
        public static ERR_SecurityAttributeInvalidActionTypeOrMethod = "SecurityAction value '{0}' is invalid for security attributes applied to a type or a method";
        public static ERR_SecurityAttributeInvalidTarget = "Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.";
        public static ERR_SecurityAttributeMissingAction = "First argument to a security attribute must be a valid SecurityAction";
        public static ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync = "Security attribute '{0}' cannot be applied to an Async method.";
        public static ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct = "Async methods are not allowed in an Interface, Class, or Structure which has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.";
        public static ERR_SemicolonExpected = "; expected";
        public static ERR_SemiOrLBraceExpected = "{ or ; expected";
        public static ERR_SignButNoPrivateKey = "Key file '{0}' is missing the private key needed for signing";
        public static ERR_SingleLineCommentInExpressionHole = "A single-line comment may not be used in an interpolated string.";
        public static ERR_SingleTypeNameNotFound = "The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)";
        public static ERR_SingleTypeNameNotFoundFwd = "The type name '{0}' could not be found. This type has been forwarded to assembly '{1}'. Consider adding a reference to that assembly.";
        public static ERR_SizeofUnsafe = "'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf)";
        public static ERR_SpecialByRefInLambda = "Instance of type '{0}' cannot be used inside an anonymous function, query expression, iterator block or async method";
        public static ERR_SpecialTypeAsBound = "Constraint cannot be special class '{0}'";
        public static ERR_StackallocInCatchFinally = "stackalloc may not be used in a catch or finally block";
        public static ERR_StatementLambdaToExpressionTree = "A lambda expression with a statement body cannot be converted to an expression tree";
        public static ERR_StaticBaseClass = "'{1}': cannot derive from static class '{0}'";
        public static ERR_StaticClassInterfaceImpl = "'{0}': static classes cannot implement interfaces";
        public static ERR_StaticConstant = "The constant '{0}' cannot be marked static";
        public static ERR_StaticConstParam = "'{0}': a static constructor must be parameterless";
        public static ERR_StaticConstructorWithAccessModifiers = "'{0}': access modifiers are not allowed on static constructors";
        public static ERR_StaticConstructorWithExplicitConstructorCall = "'{0}': static constructor cannot have an explicit 'this' or 'base' constructor call";
        public static ERR_StaticDerivedFromNonObject = "Static class '{0}' cannot derive from type '{1}'. Static classes must derive from object.";
        public static ERR_StaticInAsOrIs = "The second operand of an 'is' or 'as' operator may not be static type '{0}'";
        public static ERR_StaticMemberInObjectInitializer = "Static field or property '{0}' cannot be assigned in an object initializer";
        public static ERR_StaticNotVirtual = "A static member '{0}' cannot be marked as override, virtual, or abstract";
        public static ERR_StructLayoutCycle = "Struct member '{0}' of type '{1}' causes a cycle in the struct layout";
        public static ERR_StructOffsetOnBadField = "The FieldOffset attribute is not allowed on static or const fields";
        public static ERR_StructOffsetOnBadStruct = "The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)";
        public static ERR_StructsCantContainDefaultConstructor = "Structs cannot contain explicit parameterless constructors";
        public static ERR_StructWithBaseConstructorCall = "'{0}': structs cannot call base class constructors";
        public static ERR_SubexpressionNotInNameof = "Sub-expression cannot be used in an argument to nameof.";
        public static ERR_SwitchFallOut = "Control cannot fall out of switch from final case label ('{0}')";
        public static ERR_SwitchFallThrough = "Control cannot fall through from one case label ('{0}') to another";
        public static ERR_SwitchGoverningTypeValueExpected = "A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type";
        public static ERR_SwitchNeedsNumber = "Command-line syntax error: Missing ':<number>' for '{0}' option";
        public static ERR_SwitchNeedsString = "Command-line syntax error: Missing '{0}' for '{1}' option";
        public static ERR_SynchronizedAsyncMethod = "'MethodImplOptions.Synchronized' cannot be applied to an async method";
        public static ERR_SyntaxError = "Syntax error, '{0}' expected";
        public static ERR_SystemVoid = "System.Void cannot be used from C# -- use typeof(void) to get the void type object";
        public static ERR_TaskRetNoObjectRequired = "Since '{0}' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task<T>'?";
        public static ERR_TaskRetNoObjectRequiredLambda = "Async lambda expression converted to a 'Task' returning delegate cannot return a value. Did you intend to return 'Task<T>'?";
        public static ERR_ThisInBadContext = "Keyword 'this' is not available in the current context";
        public static ERR_ThisInStaticMeth = "Keyword 'this' is not valid in a static property, static method, or static field initializer";
        public static ERR_ThisOrBaseExpected = "Keyword 'this' or 'base' expected";
        public static ERR_ThisStructNotInAnonMeth = "Anonymous methods, lambda expressions, and query expressions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression or query expression and using the local instead.";
        public static ERR_TooManyCatches = "Catch clauses cannot follow the general catch clause of a try statement";
        public static ERR_TooManyCharsInConst = "Too many characters in character literal";
        public static ERR_TooManyLocals = "Only 65534 locals, including those generated by the compiler, are allowed";
        public static ERR_TrailingWhitespaceInFormatSpecifier = "A format specifier may not contain trailing whitespace.";
        public static ERR_TypeArgsNotAllowed = "The {1} '{0}' cannot be used with type arguments";
        public static ERR_TypeExpected = "Type expected";
        public static ERR_TypeParamMustBeIdentifier = "Type parameter declaration must be an identifier not a type";
        public static ERR_TypeVarCantBeNull = "Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.";
        public static ERR_TypeVariableSameAsParent = "Type parameter '{0}' has the same name as the containing type, or method";
        public static ERR_TypeVarNotFound = "The contextual keyword 'var' may only appear within a local variable declaration or in script code";
        public static ERR_TypeVarNotFoundRangeVariable = "The contextual keyword 'var' cannot be used in a range variable declaration";
        public static ERR_TyVarNotFoundInConstraint = "'{1}' does not define type parameter '{0}'";
        public static ERR_UnassignedThis = "Field '{0}' must be fully assigned before control is returned to the caller";
        public static ERR_UnassignedThisAutoProperty = "Auto-implemented property property '{0}' must be fully assigned before control is returned to the caller.";
        public static ERR_UnboxNotLValue = "Cannot modify the result of an unboxing conversion";
        public static ERR_UnclosedExpressionHole = "Missing close delimiter '}' for interpolated expression started with '{'.";
        public static ERR_UnescapedCurly = "A '{0}' character must be escaped (by doubling) in an interpolated string.";
        public static ERR_UnexpectedAliasedName = "Unexpected use of an aliased name";
        public static ERR_UnexpectedBoundGenericName = "Type arguments are not allowed in the nameof operator.";
        public static ERR_UnexpectedCharacter = "Unexpected character '{0}'";
        public static ERR_UnexpectedDirective = "Unexpected preprocessor directive";
        public static ERR_UnexpectedGenericName = "Unexpected use of a generic name";
        public static ERR_UnexpectedSemicolon = "Semicolon after method or accessor block is not valid";
        public static ERR_UnexpectedUnboundGenericName = "Unexpected use of an unbound generic name";
        public static ERR_UnexpectedVariance = "Invalid variance: The type parameter '{1}' must be {3} valid on '{0}'. '{1}' is {2}.";
        public static ERR_UnifyingInterfaceInstantiations = "'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions";
        public static ERR_UnimplementedAbstractMethod = "'{0}' does not implement inherited abstract member '{1}'";
        public static ERR_UnimplementedInterfaceAccessor = "'{0}' does not implement interface member '{1}'. '{2}' is not public.";
        public static ERR_UnimplementedInterfaceMember = "'{0}' does not implement interface member '{1}'";
        public static ERR_UnreachableCatch = "A previous catch clause already catches all exceptions of this or of a super type ('{0}')";
        public static ERR_UnsafeAsyncArgType = "Async methods cannot have unsafe parameters or return types";
        public static ERR_UnsafeIteratorArgType = "Iterators cannot have unsafe parameters or yield types";
        public static ERR_UnsafeNeeded = "Pointers and fixed size buffers may only be used in an unsafe context";
        public static ERR_UnsafeTypeInObjectCreation = "Unsafe type '{0}' cannot be used in object creation";
        public static ERR_UnsupportedTransparentIdentifierAccess = "Transparent identifier member access failed for field '{0}' of '{1}'.  Does the data being queried implement the query pattern?";
        public static ERR_UnterminatedStringLit = "Unterminated string literal";
        public static ERR_UseDefViolation = "Use of unassigned local variable '{0}'";
        public static ERR_UseDefViolationField = "Use of possibly unassigned field '{0}'";
        public static ERR_UseDefViolationOut = "Use of unassigned out parameter '{0}'";
        public static ERR_UseDefViolationProperty = "Use of possibly unassigned auto-implemented property '{0}'";
        public static ERR_UseDefViolationThis = "The 'this' object cannot be used before all of its fields are assigned to";
        public static ERR_UsingAfterElements = "A using clause must precede all other elements defined in the namespace except extern alias declarations";
        public static ERR_ValConstraintNotSatisfied = "The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'";
        public static ERR_ValueCantBeNull = "Cannot convert null to '{0}' because it is a non-nullable value type";
        public static ERR_ValueExpected = "Syntax error; value expected";
        public static ERR_ValueTypeExtDelegate = "Extension method '{0}' defined on value type '{1}' cannot be used to create delegates";
        public static ERR_ValueTypePropertyInObjectInitializer = "Members of property '{0}' of type '{1}' cannot be assigned with an object initializer because it is of a value type";
        public static ERR_VarargsAsync = "__arglist is not allowed in the parameter list of async methods";
        public static ERR_VarArgsInExpressionTree = "An expression tree lambda may not contain a method with variable arguments";
        public static ERR_VarargsIterator = "__arglist is not allowed in the parameter list of iterators";
        public static ERR_VarargsLast = "An __arglist parameter must be the last parameter in a formal parameter list";
        public static ERR_VarDeclIsStaticClass = "Cannot declare a variable of static type '{0}'";
        public static ERR_VariableUsedBeforeDeclaration = "Cannot use local variable '{0}' before it is declared";
        public static ERR_VariableUsedBeforeDeclarationAndHidesField = "Cannot use local variable '{0}' before it is declared. The declaration of the local variable hides the field '{1}'.";
        public static ERR_VirtualPrivate = "'{0}': virtual or abstract members cannot be private";
        public static ERR_VoidError = "The operation in question is undefined on void pointers";
        public static ERR_VolatileAndReadonly = "'{0}': a field cannot be both volatile and readonly";
        public static ERR_VolatileStruct = "'{0}': a volatile field cannot be of the type '{1}'";
        public static ERR_WinRtEventPassedByRef = "A Windows Runtime event may not be passed as an out or ref parameter.";
        public static ERR_YieldInAnonMeth = "The yield statement cannot be used inside an anonymous method or lambda expression";
        public static FTL_BadChecksumAlgorithm = "Algorithm '{0}' is not supported";
        public static FTL_BadCodepage = "Code page '{0}' is invalid or not installed";
        public static FTL_DebugEmitFailure = "Unexpected error writing debug information -- '{0}'";
        public static FTL_InputFileNameTooLong = "File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long";
        public static FTL_InvalidTarget = "Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'";
        public static FTL_MetadataCantOpenFile = "Metadata file '{0}' could not be opened -- {1}";
        public static FTL_OutputFileExists = "Cannot create short filename '{0}' when a long filename with the same short filename already exists";
        public static GenericParameterDefinition = "Generic parameter is definition when expected to be reference {0}";
        public static HDN_UnusedExternAlias = "Unused extern alias.";
        public static HDN_UnusedUsingDirective = "Unnecessary using directive.";
        public static IDS_AnonMethod = "anonymous method";
        public static IDS_Collection = "collection";
        public static IDS_Contravariant = "contravariant";
        public static IDS_Contravariantly = "contravariantly";
        public static IDS_Covariant = "covariant";
        public static IDS_Covariantly = "covariantly";
        public static IDS_CSCHelp = ""
        + "                             Visual C# Compiler Options"
        + ""
        + "                       - OUTPUT FILES -"
        + "/out:<file>                   Specify output file name (default: base name of"
        + "                              file with main class or first file)"
        + "/target:exe                   Build a console executable (default) (Short"
        + "                              form: /t:exe)"
        + "/target:winexe                Build a Windows executable (Short form:"
        + "                              /t:winexe)"
        + "/target:library               Build a library (Short form: /t:library)"
        + "/target:module                Build a module that can be added to another"
        + "                              assembly (Short form: /t:module)"
        + "/target:appcontainerexe       Build an Appcontainer executable (Short form:"
        + "                              /t:appcontainerexe)"
        + "/target:winmdobj              Build a Windows Runtime intermediate file that"
        + "                              is consumed by WinMDExp (Short form: /t:winmdobj)"
        + "/doc:<file>                   XML Documentation file to generate"
        + "/platform:<string>            Limit which platforms this code can run on: x86,"
        + "                              Itanium, x64, arm, anycpu32bitpreferred, or"
        + "                              anycpu. The default is anycpu."
        + ""
        + "                       - INPUT FILES -"
        + "/recurse:<wildcard>           Include all files in the current directory and"
        + "                              subdirectories according to the wildcard"
        + "                              specifications"
        + "/reference:<alias>=<file>     Reference metadata from the specified assembly"
        + "                              file using the given alias (Short form: /r)"
        + "/reference:<file list>        Reference metadata from the specified assembly"
        + "                              files (Short form: /r)"
        + "/addmodule:<file list>        Link the specified modules into this assembly"
        + "/link:<file list>             Embed metadata from the specified interop"
        + "                              assembly files (Short form: /l)"
        + "/analyzer:<file list>         Run the analyzers from this assembly"
        + "                              (Short form: /a)"
        + "/additionalfile:<file list>   Additional files that don't directly affect code"
        + "                              generation but may be used by analyzers for producing"
        + "                              errors or warnings."
        + ""
        + "                       - RESOURCES -"
        + "/win32res:<file>              Specify a Win32 resource file (.res)"
        + "/win32icon:<file>             Use this icon for the output"
        + "/win32manifest:<file>         Specify a Win32 manifest file (.xml)"
        + "/nowin32manifest              Do not include the default Win32 manifest"
        + "/resource:<resinfo>           Embed the specified resource (Short form: /res)"
        + "/linkresource:<resinfo>       Link the specified resource to this assembly"
        + "                              (Short form: /linkres) Where the resinfo format"
        + "                              is <file>[,<string name>[,public|private]]"
        + ""
        + "                       - CODE GENERATION -"
        + "/debug[+|-]                   Emit debugging information"
        + "/debug:{full|pdbonly}         Specify debugging type ('full' is default, and"
        + "                              enables attaching a debugger to a running"
        + "                              program)"
        + "/optimize[+|-]                Enable optimizations (Short form: /o)"
        + ""
        + "                       - ERRORS AND WARNINGS -"
        + "/warnaserror[+|-]             Report all warnings as errors"
        + "/warnaserror[+|-]:<warn list> Report specific warnings as errors"
        + "/warn:<n>                     Set warning level (0-4) (Short form: /w)"
        + "/nowarn:<warn list>           Disable specific warning messages"
        + "/ruleset:<file>               Specify a ruleset file that disables specific"
        + "                              diagnostics."
        + "/option:<name>=<value>        Specify an option that can be passed to analyzers."
        + ""
        + "                       - LANGUAGE -"
        + "/checked[+|-]                 Generate overflow checks"
        + "/unsafe[+|-]                  Allow 'unsafe' code"
        + "/define:<symbol list>         Define conditional compilation symbol(s) (Short"
        + "                              form: /d)"
        + "/langversion:<string>         Specify language version mode: ISO-1, ISO-2, 3,"
        + "                              4, 5, 6, or Default"
        + ""
        + "                       - SECURITY -"
        + "/delaysign[+|-]               Delay-sign the assembly using only the public"
        + "                              portion of the strong name key"
        + "/keyfile:<file>               Specify a strong name key file"
        + "/keycontainer:<string>        Specify a strong name key container"
        + "/highentropyva[+|-]           Enable high-entropy ASLR"
        + ""
        + "                       - MISCELLANEOUS -"
        + "@<file>                       Read response file for more options"
        + "/help                         Display this usage message (Short form: /?)"
        + "/nologo                       Suppress compiler copyright message"
        + "/noconfig                     Do not auto include CSC.RSP file"
        + "/parallel[+|-]                Concurrent build."
        + ""
        + "                       - ADVANCED -"
        + "/baseaddress:<address>        Base address for the library to be built"
        + "/bugreport:<file>             Create a 'Bug Report' file"
        + "/checksumalgorithm:<alg>      Specify algorithm for calculating source file"
        + "                              checksum stored in PDB. Supported values are:"
        + "                              SHA1 (default) or SHA256."
        + "/codepage:<n>                 Specify the codepage to use when opening source"
        + "                              files"
        + "/utf8output                   Output compiler messages in UTF-8 encoding"
        + "/main:<type>                  Specify the type that contains the entry point"
        + "                              (ignore all other possible entry points) (Short"
        + "                              form: /m)"
        + "/fullpaths                    Compiler generates fully qualified paths"
        + "/filealign:<n>                Specify the alignment used for output file"
        + "                              sections"
        + "/pdb:<file>                   Specify debug information file name (default:"
        + "                              output file name with .pdb extension)"
        + "/errorendlocation             Output line and column of the end location of"
        + "                              each error"
        + "/preferreduilang              Specify the preferred output language name."
        + "/nostdlib[+|-]                Do not reference standard library (mscorlib.dll)"
        + "/subsystemversion:<string>    Specify subsystem version of this assembly"
        + "/lib:<file list>              Specify additional directories to search in for"
        + "                              references"
        + "/errorreport:<string>         Specify how to handle internal compiler errors:"
        + "                              prompt, send, queue, or none. The default is"
        + "                              queue."
        + "/appconfig:<file>             Specify an application configuration file"
        + "                              containing assembly binding settings"
        + "/moduleassemblyname:<string>  Name of the assembly which this module will be"
        + "                              a part of"
        + "/modulename:<string>          Specify the name of the source module";
        public static IDS_DirectoryDoesNotExist = "directory does not exist";
        public static IDS_DirectoryHasInvalidPath = "path is too long or invalid";
        public static IDS_FeatureAnonDelegates = "anonymous methods";
        public static IDS_FeatureAnonymousTypes = "anonymous types";
        public static IDS_FeatureAsync = "async function";
        public static IDS_FeatureAutoImplementedProperties = "automatically implemented properties";
        public static IDS_FeatureAutoPropertyInitializer = "auto property initializer";
        public static IDS_FeatureCollectionInitializer = "collection initializer";
        public static IDS_FeatureDeclarationExpression = "declaration expression";
        public static IDS_FeatureDefault = "default operator";
        public static IDS_FeatureDictionaryInitializer = "dictionary initializer";
        public static IDS_FeatureDynamic = "dynamic";
        public static IDS_FeatureExceptionFilter = "exception filter";
        public static IDS_FeatureExpressionBodiedIndexer = "expression-bodied indexer";
        public static IDS_FeatureExpressionBodiedMethod = "expression-bodied method";
        public static IDS_FeatureExpressionBodiedProperty = "expression-bodied property";
        public static IDS_FeatureExtensionMethod = "extension method";
        public static IDS_FeatureExternAlias = "extern alias";
        public static IDS_FeatureFixedBuffer = "fixed size buffers";
        public static IDS_FeatureGenerics = "generics";
        public static IDS_FeatureGlobalNamespace = "namespace alias qualifier";
        public static IDS_FeatureImplicitArray = "implicitly typed array";
        public static IDS_FeatureImplicitLocal = "implicitly typed local variable";
        public static IDS_FeatureInterpolatedStrings = "interpolated strings";
        public static IDS_FeatureIterators = "iterators";
        public static IDS_FeatureLambda = "lambda expression";
        public static IDS_FeatureModuleAttrLoc = "module as an attribute target specifier";
        public static IDS_FeatureNamedArgument = "named argument";
        public static IDS_FeatureNameof = "nameof operator";
        public static IDS_FeatureNullable = "nullable types";
        public static IDS_FeatureNullPropagatingOperator = "null propagating operator";
        public static IDS_FeatureObjectInitializer = "object initializer";
        public static IDS_FeatureOptionalParameter = "optional parameter";
        public static IDS_FeaturePartialMethod = "partial method";
        public static IDS_FeaturePartialTypes = "partial types";
        public static IDS_FeaturePragma = "#pragma";
        public static IDS_FeaturePropertyAccessorMods = "access modifiers on properties";
        public static IDS_FeatureQueryExpression = "query expression";
        public static IDS_FeatureStaticClasses = "static classes";
        public static IDS_FeatureStructParameterlessConstructors = "struct instance parameterless constructors";
        public static IDS_FeatureSwitchOnBool = "switch on boolean type";
        public static IDS_FeatureTypeVariance = "type variance";
        public static IDS_FeatureUsingStatic = "using static";
        public static IDS_FIXEDLOCAL = "fixed variable";
        public static IDS_FOREACHLOCAL = "foreach iteration variable";
        public static IDS_GlobalNamespace = "<global namespace>";
        public static IDS_Invariantly = "invariantly";
        public static IDS_Lambda = "lambda expression";
        public static IDS_LIB_ENV = "LIB environment variable";
        public static IDS_LIB_OPTION = "/LIB option";
        public static IDS_LogoLine1 = "Microsoft (R) Visual C# Compiler version {0}";
        public static IDS_LogoLine2 = "Copyright (C) Microsoft Corporation. All rights reserved.";
        public static IDS_MethodGroup = "method group";
        public static IDS_Namespace1 = "<namespace>";
        public static IDS_NULL = "<null>";
        public static IDS_PathList = "<path list>";
        public static IDS_REFERENCEPATH_OPTION = "/REFERENCEPATH option";
        public static IDS_RELATEDERROR = "(Location of symbol related to previous error)";
        public static IDS_RELATEDWARNING = "(Location of symbol related to previous warning)";
        public static IDS_SK_ALIAS = "using alias";
        public static IDS_SK_EVENT = "event";
        public static IDS_SK_EXTERNALIAS = "extern alias";
        public static IDS_SK_FIELD = "field";
        public static IDS_SK_LABEL = "label";
        public static IDS_SK_METHOD = "method";
        public static IDS_SK_NAMESPACE = "namespace";
        public static IDS_SK_PROPERTY = "property";
        public static IDS_SK_TYPE = "type";
        public static IDS_SK_TYVAR = "type parameter";
        public static IDS_SK_UNKNOWN = "element";
        public static IDS_SK_VARIABLE = "variable";
        public static IDS_Text = "<text>";
        public static IDS_USINGLOCAL = "using variable";
        public static IDS_VersionExperimental = "'experimental'";
        public static IDS_XMLBADINCLUDE = "Include tag is invalid";
        public static IDS_XMLFAILEDINCLUDE = "Failed to insert some or all of included XML";
        public static IDS_XMLIGNORED = "<!-- Badly formed XML comment ignored for member \"{0}\" -->";
        public static IDS_XMLIGNORED2 = "Badly formed XML file \"{0}\" cannot be included";
        public static IDS_XMLMISSINGINCLUDEFILE = "Missing file attribute";
        public static IDS_XMLMISSINGINCLUDEPATH = "Missing path attribute";
        public static IDS_XMLNOINCLUDE = "No matching elements were found for the following include tag";
        public static INF_UnableToLoadSomeTypesInAnalyzer = "Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.";
        public static InvalidGetDeclarationNameMultipleDeclarators = "Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators.";
        public static ItemsMustBeNonEmpty = "items: must be non-empty";
        public static LocationMustBeProvided = "Location must be provided in order to provide minimal type qualification.";
        public static LookupOptionsHasInvalidCombo = "LookupOptions has an invalid combination of options";
        public static MustCallSetMethodTestData = "Must call SetMethodTestData(ConcurrentDictionary) before calling SetMethodTestData(MethodSymbol, ILBuilder)";
        public static NameConflictForName = "Name conflict for name {0}";
        public static NoNoneSearchCriteria = "SearchCriteria is expected.";
        public static NotACSharpSymbol = "Not a C# symbol.";
        public static OperationCausedStackOverflow = "Operation caused a stack overflow.";
        public static PositionIsNotWithinSyntax = "Position is not within syntax tree with full span {0}";
        public static PositionNotWithinTree = "Position must be within span of the syntax tree.";
        public static SeparatorIsExpected = "separator is expected";
        public static SpeculatedSyntaxNodeCannotBelongToCurrentCompilation = "Syntax node to be speculated cannot belong to a syntax tree from the current compilation.";
        public static SubmissionCanHaveAtMostOne = "Submission can have at most one syntax tree.";
        public static SubmissionCanOnlyInclude = "Submission can only include script code.";
        public static SyntaxNodeIsNotWithinSynt = "Syntax node is not within syntax tree";
        public static SyntaxTreeAlreadyPresent = "Syntax tree already present";
        public static SyntaxTreeNotFoundTo = "SyntaxTree '{0}' not found to remove";
        public static SyntaxTreeSemanticModelMust = "SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification.";
        public static TheStreamCannotBeReadFrom = "The stream cannot be read from.";
        public static TheStreamCannotBeWritten = "The stream cannot be written to.";
        public static ThisCompilationNotInteractive = "This compilation doesn't represent an interactive submission.";
        public static ThisMethodCanOnlyBeUsedToCreateTokens = "This method can only be used to create tokens - {0} is not a token kind.";
        public static TreeMustHaveARootNodeWith = "tree must have a root node with SyntaxKind.CompilationUnit";
        public static TreeNotPartOfCompilation = "tree not part of compilation";
        public static Trees0 = "trees[{0}]";
        public static TreesMustHaveRootNode = "trees[{0}] must have root node with SyntaxKind.CompilationUnit.";
        public static TypeArgumentCannotBeNull = "Type argument cannot be null";
        public static UseLiteralForNumeric = "Use Roslyn.Compilers.CSharp.Syntax.Literal to create numeric literal tokens.";
        public static UseLiteralForTokens = "Use Roslyn.Compilers.CSharp.Syntax.Literal to create character literal tokens.";
        public static UseVerbatimIdentifier = "Use Roslyn.Compilers.CSharp.Syntax.Identifier or Roslyn.Compilers.CSharp.Syntax.VerbatimIdentifier to create identifier tokens.";
        public static WRN_AlwaysNull = "The result of the expression is always 'null' of type '{0}'";
        public static WRN_AmbiguousXMLReference = "Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.";
        public static WRN_AnalyzerCannotBeCreated = "An instance of analyzer {0} cannot be created from {1} : {2}.";
        public static WRN_AssemblyAttributeFromModuleIsOverridden = "Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source";
        public static WRN_AssignmentToLockOrDispose = "Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.";
        public static WRN_AssignmentToSelf = "Assignment made to same variable; did you mean to assign something else?";
        public static WRN_AsyncLacksAwaits = "This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.";
        public static WRN_AttributeLocationOnBadDeclaration = "'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.";
        public static WRN_BadRefCompareLeft = "Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'";
        public static WRN_BadRefCompareRight = "Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'";
        public static WRN_BadRestoreNumber = "Cannot restore warning 'CS{0}' because it was disabled globally";
        public static WRN_BadUILang = "The language name '{0}' is invalid.";
        public static WRN_BadWarningNumber = "'{0}' is not a valid warning number";
        public static WRN_BadXMLRef = "XML comment has cref attribute '{0}' that could not be resolved";
        public static WRN_BadXMLRefParamType = "Invalid type for parameter {0} in XML comment cref attribute: '{1}'";
        public static WRN_BadXMLRefReturnType = "Invalid return type in XML comment cref attribute";
        public static WRN_BadXMLRefSyntax = "XML comment has syntactically incorrect cref attribute '{0}'";
        public static WRN_BadXMLRefTypeVar = "XML comment has cref attribute '{0}' that refers to a type parameter";
        public static WRN_BitwiseOrSignExtend = "Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first";
        public static WRN_ByRefNonAgileField = "Passing '{0}' as ref or out or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class";
        public static WRN_CA2000_DisposeObjectsBeforeLosingScope1 = "Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope.";
        public static WRN_CA2000_DisposeObjectsBeforeLosingScope2 = "Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope.";
        public static WRN_CA2202_DoNotDisposeObjectsMultipleTimes = "Object '{0}' can be disposed more than once.";
        public static WRN_CallerFilePathParamForUnconsumedLocation = "The CalleFilePathAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments";
        public static WRN_CallerFilePathPreferredOverCallerMemberName = "The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerFilePathAttribute.";
        public static WRN_CallerLineNumberParamForUnconsumedLocation = "The CallerLineNumberAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments";
        public static WRN_CallerLineNumberPreferredOverCallerFilePath = "The CallerFilePathAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.";
        public static WRN_CallerLineNumberPreferredOverCallerMemberName = "The CallerMemberNameAttribute applied to parameter '{0}' will have no effect. It is overridden by the CallerLineNumberAttribute.";
        public static WRN_CallerMemberNameParamForUnconsumedLocation = "The CallerMemberNameAttribute applied to parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments";
        public static WRN_CallOnNonAgileField = "Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class";
        public static WRN_CantHaveManifestForModule = "Ignoring /win32manifest for module because it only applies to assemblies";
        public static WRN_CLS_ArrayArgumentToAttribute = "Arrays as attribute arguments is not CLS-compliant";
        public static WRN_CLS_AssemblyNotCLS = "'{0}' cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute";
        public static WRN_CLS_AssemblyNotCLS2 = "'{0}' does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute";
        public static WRN_CLS_BadArgType = "Argument type '{0}' is not CLS-compliant";
        public static WRN_CLS_BadAttributeType = "'{0}' has no accessible constructors which use only CLS-compliant types";
        public static WRN_CLS_BadBase = "'{0}': base type '{1}' is not CLS-compliant";
        public static WRN_CLS_BadFieldPropType = "Type of '{0}' is not CLS-compliant";
        public static WRN_CLS_BadIdentifier = "Identifier '{0}' is not CLS-compliant";
        public static WRN_CLS_BadIdentifierCase = "Identifier '{0}' differing only in case is not CLS-compliant";
        public static WRN_CLS_BadInterface = "'{0}' is not CLS-compliant because base interface '{1}' is not CLS-compliant";
        public static WRN_CLS_BadInterfaceMember = "'{0}': CLS-compliant interfaces must have only CLS-compliant members";
        public static WRN_CLS_BadReturnType = "Return type of '{0}' is not CLS-compliant";
        public static WRN_CLS_BadTypeVar = "Constraint type '{0}' is not CLS-compliant";
        public static WRN_CLS_IllegalTrueInFalse = "'{0}' cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type '{1}'";
        public static WRN_CLS_MeaninglessOnParam = "CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.";
        public static WRN_CLS_MeaninglessOnPrivateType = "CLS compliance checking will not be performed on '{0}' because it is not visible from outside this assembly";
        public static WRN_CLS_MeaninglessOnReturn = "CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.";
        public static WRN_CLS_ModuleMissingCLS = "Added modules must be marked with the CLSCompliant attribute to match the assembly";
        public static WRN_CLS_NoAbstractMembers = "'{0}': only CLS-compliant members can be abstract";
        public static WRN_CLS_NotOnModules = "You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking";
        public static WRN_CLS_NotOnModules2 = "You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly";
        public static WRN_CLS_NoVarArgs = "Methods with variable arguments are not CLS-compliant";
        public static WRN_CLS_OverloadRefOut = "Overloaded method '{0}' differing only in ref or out, or in array rank, is not CLS-compliant";
        public static WRN_CLS_OverloadUnnamed = "Overloaded method '{0}' differing only by unnamed array types is not CLS-compliant";
        public static WRN_CLS_VolatileField = "CLS-compliant field '{0}' cannot be volatile";
        public static WRN_CmdOptionConflictsSource = "Option '{0}' overrides attribute '{1}' given in a source file or added module";
        public static WRN_CmpAlwaysFalse = "Comparing with null of type '{0}' always produces 'false'";
        public static WRN_CoClassWithoutComImport = "'{0}' interface marked with 'CoClassAttribute' not marked with 'ComImportAttribute'";
        public static WRN_ComparisonToSelf = "Comparison made to same variable; did you mean to compare something else?";
        public static WRN_ConflictingChecksum = "Different checksum values given for '{0}'";
        public static WRN_ConflictingMachineAssembly = "Referenced assembly '{0}' targets a different processor.";
        public static WRN_DebugFullNameTooLong = "The fully qualified name for '{0}' is too long for debug information. Compile without '/debug' option.";
        public static WRN_DefaultValueForUnconsumedLocation = "The default value specified for parameter '{0}' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments";
        public static WRN_DefineIdentifierRequired = "Invalid value for '/define'; '{0}' is not a valid identifier";
        public static WRN_DelaySignButNoKey = "Delay signing was specified and requires a public key, but no public key was specified";
        public static WRN_DeprecatedCollectionInitAdd = "The best overloaded Add method '{0}' for the collection initializer element is obsolete.";
        public static WRN_DeprecatedCollectionInitAddStr = "The best overloaded Add method '{0}' for the collection initializer element is obsolete. {1}";
        public static WRN_DeprecatedSymbol = "'{0}' is obsolete";
        public static WRN_DeprecatedSymbolStr = "'{0}' is obsolete: '{1}'";
        public static WRN_DotOnDefault = "Expression will always cause a System.NullReferenceException because the default value of '{0}' is null";
        public static WRN_DuplicateParamTag = "XML comment has a duplicate param tag for '{0}'";
        public static WRN_DuplicateTypeParamTag = "XML comment has a duplicate typeparam tag for '{0}'";
        public static WRN_DuplicateUsing = "The using directive for '{0}' appeared previously in this namespace";
        public static WRN_DynamicDispatchToConditionalMethod = "The dynamically dispatched call to method '{0}' may fail at runtime because one or more applicable overloads are conditional methods.";
        public static WRN_EmptySwitch = "Empty switch block";
        public static WRN_EndOfPPLineExpected = "Single-line comment or end-of-line expected";
        public static WRN_EqualityOpWithoutEquals = "'{0}' defines operator == or operator != but does not override Object.Equals(object o)";
        public static WRN_EqualityOpWithoutGetHashCode = "'{0}' defines operator == or operator != but does not override Object.GetHashCode()";
        public static WRN_EqualsWithoutGetHashCode = "'{0}' overrides Object.Equals(object o) but does not override Object.GetHashCode()";
        public static WRN_ErrorOverride = "{0}. See also error CS{1}.";
        public static WRN_ExplicitImplCollision = "Explicit interface implementation '{0}' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.";
        public static WRN_ExternCtorNoImplementation = "Constructor '{0}' is marked external";
        public static WRN_ExternMethodNoImplementation = "Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.";
        public static WRN_FailedInclude = "Unable to include XML fragment '{1}' of file '{0}' -- {2}";
        public static WRN_FileAlreadyIncluded = "Source file '{0}' specified multiple times";
        public static WRN_FileNameTooLong = "Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.";
        public static WRN_FilterIsConstant = "Filter expression is a constant, consider removing the filter";
        public static WRN_FinalizeMethod = "Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?";
        public static WRN_GlobalAliasDefn = "Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias";
        public static WRN_GotoCaseShouldConvert = "The 'goto case' value is not implicitly convertible to type '{0}'";
        public static WRN_IdentifierOrNumericLiteralExpected = "Expected identifier or numeric literal.";
        public static WRN_IllegalPPChecksum = "Invalid #pragma checksum syntax; should be #pragma checksum \"filename\" \"{XXXXXXXX - XXXX - XXXX - XXXX - XXXXXXXXXXXX}\" \"XXXX...\"";
        public static WRN_IllegalPPWarning = "Expected disable or restore";
        public static WRN_IllegalPragma = "Unrecognized #pragma directive";
        public static WRN_IncorrectBooleanAssg = "Assignment in conditional expression is always constant; did you mean to use == instead of = ?";
        public static WRN_InvalidAssemblyName = "Assembly reference '{0}' is invalid and cannot be resolved";
        public static WRN_InvalidAttributeLocation = "'{0}' is not a recognized attribute location. All attributes in this block will be ignored.";
        public static WRN_InvalidInclude = "Invalid XML include element -- {0}";
        public static WRN_InvalidMainSig = "'{0}' has the wrong signature to be an entry point";
        public static WRN_InvalidNumber = "Invalid number";
        public static WRN_InvalidSearchPathDir = "Invalid search path '{0}' specified in '{1}' -- '{2}'";
        public static WRN_InvalidVersionFormat = "The specified version string does not conform to the recommended format - major.minor.build.revision";
        public static WRN_IsAlwaysFalse = "The given expression is never of the provided ('{0}') type";
        public static WRN_IsAlwaysTrue = "The given expression is always of the provided ('{0}') type";
        public static WRN_IsDynamicIsConfusing = "Using '{0}' to test compatibility with '{1}' is essentially identical to testing compatibility with '{2}' and will succeed for all non-null values";
        public static WRN_LowercaseEllSuffix = "The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity";
        public static WRN_MainCantBeGeneric = "'{0}': an entry point cannot be generic or in a generic type";
        public static WRN_MainIgnored = "The entry point of the program is global script code; ignoring '{0}' entry point.";
        public static WRN_MissingParamTag = "Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)";
        public static WRN_MissingTypeParamTag = "Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do)";
        public static WRN_MissingXMLComment = "Missing XML comment for publicly visible type or member '{0}'";
        public static WRN_MultiplePredefTypes = "The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'";
        public static WRN_MultipleRuntimeImplementationMatches = "Member '{0}' implements interface member '{1}' in type '{2}'. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.";
        public static WRN_MultipleRuntimeOverrideMatches = "Member '{1}' overrides '{0}'. There are multiple override candidates at run-time. It is implementation dependent which method will be called.";
        public static WRN_NegativeArrayIndex = "Indexing an array with a negative index (array indices always start at zero)";
        public static WRN_NewNotRequired = "The member '{0}' does not hide an inherited member. The new keyword is not required.";
        public static WRN_NewOrOverrideExpected = "'{0}' hides inherited member '{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.";
        public static WRN_NewRequired = "'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.";
        public static WRN_NoAnalyzerInAssembly = "The assembly {0} does not contain any analyzers.";
        public static WRN_NoConfigNotOnCommandLine = "Ignoring /noconfig option because it was specified in a response file";
        public static WRN_NonECMAFeature = "Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers";
        public static WRN_NonObsoleteOverridingObsolete = "Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.";
        public static WRN_NoRuntimeMetadataVersion = "No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.";
        public static WRN_NoSources = "No source files specified.";
        public static WRN_NubExprIsConstBool = "The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'";
        public static WRN_NubExprIsConstBool2 = "The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{2}'";
        public static WRN_ObsoleteOverridingNonObsolete = "Obsolete member '{0}' overrides non-obsolete member '{1}'";
        public static WRN_PatternBadSignature = "'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.";
        public static WRN_PatternIsAmbiguous = "'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{3}'.";
        public static WRN_PatternStaticOrInaccessible = "'{0}' does not implement the '{1}' pattern. '{2}' is either static or not public.";
        public static WRN_PdbLocalNameTooLong = "Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.";
        public static WRN_PossibleMistakenNullStatement = "Possible mistaken empty statement";
        public static WRN_ProtectedInSealed = "'{0}': new protected member declared in sealed class";
        public static WRN_RefCultureMismatch = "Referenced assembly '{0}' has different culture setting of '{1}'.";
        public static WRN_ReferencedAssemblyDoesNotHaveStrongName = "Referenced assembly '{0}' does not have a strong name.";
        public static WRN_ReferencedAssemblyReferencesLinkedPIA = "A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly created by assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.";
        public static WRN_SameFullNameThisAggAgg = "The type '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the type defined in '{0}'.";
        public static WRN_SameFullNameThisAggNs = "The type '{1}' in '{0}' conflicts with the imported namespace '{3}' in '{2}'. Using the type defined in '{0}'.";
        public static WRN_SameFullNameThisNsAgg = "The namespace '{1}' in '{0}' conflicts with the imported type '{3}' in '{2}'. Using the namespace defined in '{0}'.";
        public static WRN_SequentialOnPartialClass = "There is no defined ordering between fields in multiple declarations of partial struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.";
        public static WRN_TooManyLinesForDebugger = "Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect";
        public static WRN_TypeParameterSameAsOuterTypeParameter = "Type parameter '{0}' has the same name as the type parameter from outer type '{1}'";
        public static WRN_UnableToLoadAnalyzer = "Unable to load Analyzer assembly {0} : {1}";
        public static WRN_UnassignedInternalField = "Field '{0}' is never assigned to, and will always have its default value {1}";
        public static WRN_UnifyReferenceBldRev = "Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy";
        public static WRN_UnifyReferenceMajMin = "Assuming assembly reference '{0}' used by '{1}' matches identity '{2}' of '{3}', you may need to supply runtime policy";
        public static WRN_UnimplementedCommandLineSwitch = "The command line switch '{0}' is not yet implemented in Roslyn and was ignored.";
        public static WRN_UnmatchedParamRefTag = "XML comment on '{1}' has a paramref tag for '{0}', but there is no parameter by that name";
        public static WRN_UnmatchedParamTag = "XML comment has a param tag for '{0}', but there is no parameter by that name";
        public static WRN_UnmatchedTypeParamRefTag = "XML comment on '{1}' has a typeparamref tag for '{0}', but there is no type parameter by that name";
        public static WRN_UnmatchedTypeParamTag = "XML comment has a typeparam tag for '{0}', but there is no type parameter by that name";
        public static WRN_UnobservedAwaitableExpression = "Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.";
        public static WRN_UnprocessedXMLComment = "XML comment is not placed on a valid language element";
        public static WRN_UnqualifiedNestedTypeInCref = "Within cref attributes, nested types of generic types should be qualified.";
        public static WRN_UnreachableCode = "Unreachable code detected";
        public static WRN_UnreachableGeneralCatch = "A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException.";
        public static WRN_UnreferencedEvent = "The event '{0}' is never used";
        public static WRN_UnreferencedField = "The field '{0}' is never used";
        public static WRN_UnreferencedFieldAssg = "The field '{0}' is assigned but its value is never used";
        public static WRN_UnreferencedLabel = "This label has not been referenced";
        public static WRN_UnreferencedVar = "The variable '{0}' is declared but never used";
        public static WRN_UnreferencedVarAssg = "The variable '{0}' is assigned but its value is never used";
        public static WRN_VacuousIntegralComp = "Comparison to integral constant is useless; the constant is outside the range of type '{0}'";
        public static WRN_VolatileByRef = "'{0}': a reference to a volatile field will not be treated as volatile";
        public static WRN_WarningDirective = "#warning: '{0}'";
        public static WRN_XMLParseError = "XML comment has badly formed XML -- '{0}'";
        public static WRN_XMLParseIncludeError = "Badly formed XML in included comments file -- '{0}'";
        public static WrongNumberOfTypeArguments = "Wrong number of type arguments";
        public static WrongSemanticModelType = "Expected a {0} SemanticModel.";
        public static XML_CDataEndTagNotAllowed = "The literal string ']]>' is not allowed in element content.";
        public static XML_DuplicateAttribute = "Duplicate '{0}' attribute";
        public static XML_ElementTypeMatch = "End tag '{0}' does not match the start tag '{1}'.";
        public static XML_EndTagExpected = "Expected an end tag for element '{0}'.";
        public static XML_EndTagNotExpected = "End tag was not expected at this location.";
        public static XML_ExpectedEndOfTag = "Expected '>' or '/>' to close tag '{0}'.";
        public static XML_ExpectedEndOfXml = "Unexpected character at this location.";
        public static XML_ExpectedIdentifier = "An identifier was expected.";
        public static XML_IncorrectComment = "Incorrect syntax was used in a comment.";
        public static XML_InvalidCharEntity = "An invalid character was found inside an entity reference.";
        public static XML_InvalidToken = "The character(s) '{0}' cannot be used at this location.";
        public static XML_InvalidUnicodeChar = "Invalid unicode character.";
        public static XML_InvalidWhitespace = "Whitespace is not allowed at this location.";
        public static XML_LessThanInAttributeValue = "The character '<' cannot be used in an attribute value.";
        public static XML_MissingEqualsAttribute = "Missing equals sign between attribute and attribute value.";
        public static XML_RefUndefinedEntity_1 = "Reference to undefined entity '{0}'.";
        public static XML_StringLiteralNoEndQuote = "Missing closing quotation mark for string literal.";
        public static XML_StringLiteralNonAsciiQuote = "Non-ASCII quotations marks may not be used around string literals.";
        public static XML_StringLiteralNoStartQuote = "A string literal was expected, but no opening quotation mark was found.";
        public static XML_WhitespaceMissing = "Required white space was missing.";



    }
}